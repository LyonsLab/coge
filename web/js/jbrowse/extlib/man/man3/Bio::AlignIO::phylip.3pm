.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::AlignIO::phylip 3"
.TH Bio::AlignIO::phylip 3 "2013-05-09" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::AlignIO::phylip \- PHYLIP format sequence input/output stream
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
# Do not use this module directly.  Use it via the Bio::AlignIO class.
.PP
.Vb 10
\&    use Bio::AlignIO;
\&    use Bio::SimpleAlign;
\&    #you can set the name length to something other than the default 10
\&    #if you use a version of phylip (hacked) that accepts ids > 10
\&    my $phylipstream = Bio::AlignIO\->new(\-format  => \*(Aqphylip\*(Aq,
\&                                        \-fh      => \e*STDOUT,
\&                                        \-idlength=>30);
\&    # convert data from one format to another
\&    my $gcgstream     =  Bio::AlignIO\->new(\-format => \*(Aqmsf\*(Aq,
\&                                          \-file   => \*(Aqt/data/cysprot1a.msf\*(Aq);
\&
\&    while( my $aln = $gcgstream\->next_aln ) {
\&        $phylipstream\->write_aln($aln);
\&    }
\&
\&    # do it again with phylip sequential format format
\&    $phylipstream\->interleaved(0);
\&    # can also initialize the object like this
\&    $phylipstream = Bio::AlignIO\->new(\-interleaved => 0,
\&                                     \-format => \*(Aqphylip\*(Aq,
\&                                     \-fh   => \e*STDOUT,
\&                                     \-idlength=>10);
\&    $gcgstream     =  Bio::AlignIO\->new(\-format => \*(Aqmsf\*(Aq,
\&                                       \-file   => \*(Aqt/data/cysprot1a.msf\*(Aq);
\&
\&    while( my $aln = $gcgstream\->next_aln ) {
\&        $phylipstream\->write_aln($aln);
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This object can transform Bio::SimpleAlign objects to and from \s-1PHYLIP\s0
format. By default it works with the interleaved format. By specifying
the flag \-interleaved => 0 in the initialization the module can
read or write data in sequential format.
.PP
Long IDs up to 50 characters are supported by flag \-longid =>
1. \s-1ID\s0 strings can be surrounded by single quoted. They are mandatory
only if the IDs contain spaces.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution. Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  https://redmine.open\-bio.org/projects/bioperl/
.Ve
.SH "AUTHORS \- Heikki Lehvaslaiho and Jason Stajich"
.IX Header "AUTHORS - Heikki Lehvaslaiho and Jason Stajich"
Email: heikki at ebi.ac.uk
Email: jason at bioperl.org
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object
methods. Internal methods are usually preceded with a _
.SS "new"
.IX Subsection "new"
.Vb 10
\& Title   : new
\& Usage   : my $alignio = Bio::AlignIO\->new(\-format => \*(Aqphylip\*(Aq
\&                                          \-file   => \*(Aq>file\*(Aq,
\&                                          \-idlength => 10,
\&                                          \-idlinebreak => 1);
\& Function: Initialize a new L<Bio::AlignIO::phylip> reader or writer
\& Returns : L<Bio::AlignIO> object
\& Args    : [specific for writing of phylip format files]
\&           \-idlength => integer \- length of the id (will pad w/
\&                                                    spaces if needed)
\&           \-interleaved => boolean \- whether interleaved
\&                                     or sequential format required
\&           \-line_length  => integer of how long a sequence lines should be
\&           \-idlinebreak => insert a line break after the sequence id
\&                           so that sequence starts on the next line
\&           \-flag_SI => whether or not write a "S" or "I" just after
\&                       the num.seq. and line len., in the first line
\&           \-tag_length => integer of how long the tags have to be in
\&                         each line between the space separator. set it
\&                         to 0 to have 1 tag only.
\&           \-wrap_sequential => boolean for whether or not sequential
\&                                   format should be broken up or a single line
\&                                   default is false (single line)
\&           \-longid => boolean for allowing arbitrary long IDs (default is false)
.Ve
.SS "next_aln"
.IX Subsection "next_aln"
.Vb 7
\& Title   : next_aln
\& Usage   : $aln = $stream\->next_aln()
\& Function: returns the next alignment in the stream.
\&           Throws an exception if trying to read in PHYLIP
\&           sequential format.
\& Returns : L<Bio::SimpleAlign> object
\& Args    :
.Ve
.SS "write_aln"
.IX Subsection "write_aln"
.Vb 5
\& Title   : write_aln
\& Usage   : $stream\->write_aln(@aln)
\& Function: writes the $aln object into the stream in phylip format
\& Returns : 1 for success and 0 for error
\& Args    : L<Bio::Align::AlignI> object
.Ve
.SS "interleaved"
.IX Subsection "interleaved"
.Vb 5
\& Title   : interleaved
\& Usage   : my $interleaved = $obj\->interleaved
\& Function: Get/Set Interleaved status
\& Returns : boolean
\& Args    : boolean
.Ve
.SS "flag_SI"
.IX Subsection "flag_SI"
.Vb 7
\& Title   : flag_SI
\& Usage   : my $flag = $obj\->flag_SI
\& Function: Get/Set if the Sequential/Interleaved flag has to be shown
\&           after the number of sequences and sequence length
\& Example :
\& Returns : boolean
\& Args    : boolean
.Ve
.SS "idlength"
.IX Subsection "idlength"
.Vb 5
\& Title   : idlength
\& Usage   : my $idlength = $obj\->idlength
\& Function: Get/Set value of id length
\& Returns : string
\& Args    : string
.Ve
.SS "line_length"
.IX Subsection "line_length"
.Vb 5
\& Title   : line_length
\& Usage   : $obj\->line_length($newval)
\& Function:
\& Returns : value of line_length
\& Args    : newvalue (optional)
.Ve
.SS "tag_length"
.IX Subsection "tag_length"
.Vb 6
\& Title   : tag_length
\& Usage   : $obj\->tag_length($newval)
\& Function:
\& Example : my $tag_length = $obj\->tag_length
\& Returns : value of the length for each space\-separated tag in a line
\& Args    : newvalue (optional) \- set to zero to have one tag per line
.Ve
.SS "id_linebreak"
.IX Subsection "id_linebreak"
.Vb 5
\& Title   : id_linebreak
\& Usage   : $obj\->id_linebreak($newval)
\& Function:
\& Returns : value of id_linebreak
\& Args    : newvalue (optional)
.Ve
.SS "wrap_sequential"
.IX Subsection "wrap_sequential"
.Vb 5
\& Title   : wrap_sequential
\& Usage   : $obj\->wrap_sequential($newval)
\& Function:
\& Returns : value of wrap_sequential
\& Args    : newvalue (optional)
.Ve
.SS "longid"
.IX Subsection "longid"
.Vb 5
\& Title   : longid
\& Usage   : $obj\->longid($newval)
\& Function:
\& Returns : value of longid
\& Args    : newvalue (optional)
.Ve
