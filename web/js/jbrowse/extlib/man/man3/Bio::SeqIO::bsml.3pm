.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::SeqIO::bsml 3"
.TH Bio::SeqIO::bsml 3 "2013-05-09" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::SeqIO::bsml \- BSML sequence input/output stream
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& It is probably best not to use this object directly, but rather go
\& through the SeqIO handler system. To read a BSML file:
\&
\&    $stream = Bio::SeqIO\->new( \-file => $filename, \-format => \*(Aqbsml\*(Aq);
\&
\&    while ( my $bioSeqObj = $stream\->next_seq() ) {
\&        # do something with $bioSeqObj
\&    }
\&
\& To write a Seq object to the current file handle in BSML XML format:
\&
\&    $stream\->write_seq( \-seq => $seqObj);
\&
\& If instead you would like a XML::DOM object containing the BSML, use:
\&
\&    my $newXmlObject = $stream\->to_bsml( \-seq => $seqObj);
.Ve
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
.Vb 1
\& In addition to parts of the Bio:: hierarchy, this module uses:
\&
\& XML::DOM
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.Vb 2
\& This object can transform Bio::Seq objects to and from BSML (XML)
\& flatfiles.
.Ve
.SS "\s-1NOTE:\s0"
.IX Subsection "NOTE:"
.Vb 4
\& 2/1/02 \- I have changed the API to more closely match argument
\& passing used by other BioPerl methods ( \-tag => value ). Internal
\& methods are using the same API, but you should not be calling those
\& anyway...
.Ve
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
.Vb 3
\& Report bugs to the Bioperl bug tracking system to help us keep track
\& the bugs and their resolution.
\& Bug reports can be submitted via the web:
\&
\&  https://redmine.open\-bio.org/projects/bioperl/
.Ve
.SS "Things Still to Do"
.IX Subsection "Things Still to Do"
.Vb 3
\& * The module now uses the new Collection.pm system. However,
\&   Annotations associated with a Feature object still seem to use the
\&   old system, so parsing with the old methods are included..
\&
\& * Generate Seq objects with no sequence data but an assigned
\&   length. This appears to be an issue with Bio::Seq. It is possible
\&   (and reasonable) to make a BSML document with features but no
\&   sequence data.
\&
\& * Support <Seq\-data\-import>. Do not know how commonly this is used.
\&
\& * Some features are awaiting implementation in later versions of
\&   BSML. These include:
\&
\&       * Nested feature support
\&
\&       * Complex feature (ie joins)
\&
\&       * Unambiguity in strand (ie \-1,0,1, not just  \*(Aqcomplement\*(Aq )
\&
\&       * More friendly dblink structures
\&
\& * Location.pm (or RangeI::union?) appears to have a bug when \*(Aqexpand\*(Aq
\&   is used.
\&
\& * More intelligent hunting for sequence and feature titles? It is not
\&   terribly clear where the most appropriate field is located, better
\&   grepping (eg looking for a reasonable count for spaces and numbers)
\&   may allow for titles better than "AE008041".
.Ve
.SH "AUTHOR \- Charles Tilford"
.IX Header "AUTHOR - Charles Tilford"
Bristol-Myers Squibb Bioinformatics
.PP
Email tilfordc@bms.com
.PP
I have developed the \s-1BSML\s0 specific code for this package, but have used
code from other SeqIO packages for much of the nuts-and-bolts. In particular
I have used code from the embl.pm module either directly or as a framework
for many of the subroutines that are common to SeqIO modules.
.SH "METHODS"
.IX Header "METHODS"
.SS "next_seq"
.IX Subsection "next_seq"
.Vb 5
\& Title   : next_seq
\& Usage   : my $bioSeqObj = $stream\->next_seq
\& Function: Retrieves the next sequence from a SeqIO::bsml stream.
\& Returns : A reference to a Bio::Seq::RichSeq object
\& Args    :
.Ve
.SS "to_bsml"
.IX Subsection "to_bsml"
.Vb 7
\& Title   : to_bsml
\& Usage   : my $domDoc = $obj\->to_bsml(@args)
\& Function: Generates an XML structure for one or more Bio::Seq objects.
\&           If $seqref is an array ref, the XML tree generated will include
\&           all the sequences in the array.
\& Returns : A reference to the XML DOM::Document object generated / modified
\& Args    : Argument array in form of \-key => val. Recognized keys:
\&
\&      \-seq A Bio::Seq reference, or an array reference of many of them
\&
\&   \-xmldoc Specifies an existing XML DOM document to add the sequences
\&           to. If included, then only data (no page formatting) will
\&           be added. If not, a new XML::DOM::Document will be made,
\&           and will be populated with both <Sequence> data, as well as
\&           <Page> display elements.
\&
\&   \-nodisp Do not generate <Display> elements, or any children
\&           thereof, even if \-xmldoc is not set.
\&
\& \-skipfeat If set to \*(Aqall\*(Aq, all <Feature>s will be skipped.  If it is
\&           a hash reference, any <Feature> with a class matching a key
\&           in the hash will be skipped \- for example, to skip \*(Aqsource\*(Aq
\&           and \*(Aqscore\*(Aq features, use:
\&
\&               \-skipfeat => { source => \*(AqY\*(Aq, score => \*(AqY\*(Aq }
\&
\& \-skiptags As above: if set to \*(Aqall\*(Aq, no tags are included, and if a
\&           hash reference, those specific tags will be ignored.
\&
\&           Skipping some or all tags and features can result in
\&           noticeable speed improvements.
\&
\&   \-nodata If true, then <Seq\-data> will not be included.  This may be
\&           useful if you just want annotations and do not care about
\&           the raw ACTG information.
\&
\&   \-return Default is \*(Aqxml\*(Aq, which will return a reference to the BSML
\&           XML object. If set to \*(Aqseq\*(Aq will return an array ref of the
\&           <Sequence> objects added (rather than the whole XML object)
\&
\&    \-close Early BSML browsers will crash if an element *could* have
\&           children but does not, and is closed as an empty element
\&           e.g. <Styles/>. If \-close is true, then such tags are given
\&           a comment child to explicitly close them e.g.  <Styles><!\-\-
\&           \-\-></Styles>. This is default true, set to "0" if you do
\&           not want this behavior.
\&
\& Examples : my $domObj = $stream\->to_bsml( \-seq => \e@fourCoolSequenceObjects,
\&                                           \-skipfeat => { source => 1 },
\&                                           );
\&
\&            # Or add sequences to an existing BSML document:
\&            $stream\->to_bsml( \-seq => \e@fourCoolSequenceObjects,
\&                              \-skipfeat => { source => 1 },
\&                              \-xmldoc => $myBsmlDocumentInProgress,  );
.Ve
.SS "write_seq"
.IX Subsection "write_seq"
.Vb 8
\& Title   : write_seq
\& Usage   : $obj\->write_seq(@args)
\& Function: Prints out an XML structure for one or more Bio::Seq objects.
\&           If $seqref is an array ref, the XML tree generated will include
\&           all the sequences in the array. This method is fairly simple,
\&           most of the processing is performed within to_bsml.
\& Returns : A reference to the XML object generated / modified
\& Args    : Argument array. Recognized keys:
\&
\&      \-seq A Bio::Seq reference, or an array reference of many of them
\&
\&           Alternatively, the method may be called simply as...
\&
\&           $obj\->write_seq( $bioseq )
\&
\&           ... if only a single argument is passed, it is assumed that
\&           it is the sequence object (can also be an array ref of
\&           many Seq objects )
.Ve
.PP
\&\-printmime If true prints \*(L"Content-type: \f(CW$mimetype\fR\en\en\*(R" at top of
           document, where \f(CW$mimetype\fR is the value designated by this
           key. For generic \s-1XML\s0 use text/xml, for \s-1BSML\s0 use text/x\-bsml
.PP
.Vb 4
\&   \-return This option will be supressed, since the nature of this
\&           method is to print out the XML document. If you wish to
\&           retrieve the <Sequence> objects generated, use the to_bsml
\&           method directly.
.Ve
.SH "INTERNAL METHODS #\-#\-#\-#\-#\-#\-#\-#\-#\-#\-#\-#\-#\-#\-#\-#\-#\-#\-#\-#\-#\-#\-#\-#\-#\-#\-#\-#\-#\-#\-#\-#\-#\-#\-#\-#\-#\-#\-#\-"
.IX Header "INTERNAL METHODS #-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-"
.Vb 2
\& The following methods are used for internal processing, and should probably
\& not be accessed by the user.
.Ve
.SS "_parse_location"
.IX Subsection "_parse_location"
.Vb 10
\& Title   : _parse_location
\& Usage   : $obj\->_parse_location($xmlDocument, $parentElem, $SeqFeatureObj)
\& Function: Adds <Interval\-loc> and <Site\-loc> children to <$parentElem> based
\&           on locations / sublocations found in $SeqFeatureObj. If
\&           sublocations exist, the original location will be ignored.
\& Returns : An array ref containing the elements added to the parent.
\&           These will have already been added to <$parentElem>
\& Args    : 0 The DOM::Document being modified
\&           1 The DOM::Element parent that you want to add to
\&           2 Reference to the Bio::SeqFeature being analyzed
.Ve
.SS "_parse_bsml_feature"
.IX Subsection "_parse_bsml_feature"
.Vb 6
\& Title   : _parse_bsml_feature
\& Usage   : $obj\->_parse_bsml_feature($xmlFeature )
\& Function: Will examine the <Feature> element provided by $xmlFeature and
\&           return a generic seq feature.
\& Returns : Bio::SeqFeature::Generic
\& Args    : 0 XML::DOM::Element <Feature> being analyzed.
.Ve
.SS "_parse_bsml_location"
.IX Subsection "_parse_bsml_location"
.Vb 6
\& Title   : _parse_bsml_location
\& Usage   : $obj\->_parse_bsml_feature( $intOrSiteLoc, $gsfObject )
\& Function: Will examine the <Interval\-loc> or <Site\-loc> element provided
\& Returns : Bio::SeqFeature::Generic
\& Args    : 0 XML::DOM::Element <Interval/Site\-loc> being analyzed.
\&           1 Optional SeqFeature::Generic to use
.Ve
.SS "_parse_reference"
.IX Subsection "_parse_reference"
.Vb 7
\& Title   : _parse_reference
\& Usage   : $obj\->_parse_reference(@args )
\& Function: Makes a new <Reference> object from a ::Reference, which is
\&           then stored in an array provide by \-refs. It will be
\&           appended to the XML tree later.
\& Returns :
\& Args    : Argument array. Recognized keys:
\&
\&      \-xml The DOM::Document being modified
\&
\&   \-refobj The Annotation::Reference Object
\&
\&     \-refs An array reference to hold the new <Reference> DOM object
\&
\&       \-id Optional. If the XML id for the \*(Aqcalling\*(Aq element is
\&           provided, it will be placed in any <Reference> refs
\&           attribute.
.Ve
.SS "_parse_annotation"
.IX Subsection "_parse_annotation"
.Vb 10
\& Title   : _parse_annotation
\& Usage   : $obj\->_parse_annotation(@args )
\& Function: Will examine any Annotations found in \-obj. Data found in
\&           ::Comment and ::DBLink structures, as well as Annotation
\&           description fields are stored in \-desc for later
\&           generation of <Attribute>s. <Reference> objects are generated
\&           from ::References, and are stored in \-refs \- these will
\&           be appended to the XML tree later.
\& Returns :
\& Args    : Argument array. Recognized keys:
\&
\&      \-xml The DOM::Document being modified
\&
\&      \-obj Reference to the Bio object being analyzed
\&
\&    \-descr An array reference for holding description text items
\&
\&     \-refs An array reference to hold <Reference> DOM objects
\&
\&       \-id Optional. If the XML id for the \*(Aqcalling\*(Aq element is
\&           provided, it will be placed in any <Reference> refs
\&           attribute.
.Ve
.SS "_parse_annotation_old"
.IX Subsection "_parse_annotation_old"
.Vb 7
\&    Title   : _parse_annotation_old
\& Usage   : $obj\->_parse_annotation_old(@args)
\& Function: As above, but for the old Annotation system.
\&           Apparently needed because Features are still using the old\-style
\&           annotations?
\& Returns :
\& Args    : Argument array. Recognized keys:
\&
\&      \-xml The DOM::Document being modified
\&
\&      \-obj Reference to the Bio object being analyzed
\&
\&    \-descr An array reference for holding description text items
\&
\&     \-refs An array reference to hold <Reference> DOM objects
\&
\&       \-id Optional. If the XML id for the \*(Aqcalling\*(Aq element is
\&           provided, it will be placed in any <Reference> refs
\&           attribute.
.Ve
.SS "_add_page"
.IX Subsection "_add_page"
.Vb 6
\& Title   : _add_page
\& Usage   : $obj\->_add_page($xmlDocument, $xmlSequenceObject)
\& Function: Adds a simple <Page> and <View> structure for a <Sequence>
\& Returns : a reference to the newly created <Page>
\& Args    : 0 The DOM::Document being modified
\&           1 Reference to the <Sequence> object
.Ve
.SS "_addel"
.IX Subsection "_addel"
.Vb 9
\& Title   : _addel
\& Usage   : $obj\->_addel($parentElem, \*(AqChildName\*(Aq,
\&                        { anAttr => \*(AqsomeValue\*(Aq, anotherAttr => \*(AqaValue\*(Aq,})
\& Function: Add an element with attribute values to a DOM tree
\& Returns : a reference to the newly added element
\& Args    : 0 The DOM::Element parent that you want to add to
\&           1 The name of the new child element
\&           2 Optional hash reference containing
\&             attribute name => attribute value assignments
.Ve
.SS "_show_dna"
.IX Subsection "_show_dna"
.Vb 5
\& Title   : _show_dna
\& Usage   : $obj\->_show_dna($newval)
\& Function: (cut\-and\-pasted directly from embl.pm)
\& Returns : value of _show_dna
\& Args    : newvalue (optional)
.Ve
.SS "_initialize"
.IX Subsection "_initialize"
.Vb 6
\& Title   : _initialize
\& Usage   : $dom = $obj\->_initialize(@args)
\& Function: Coppied from embl.pm, and augmented with initialization of the
\&           XML DOM tree
\& Returns :
\& Args    : \-file => the XML file to be parsed
.Ve
.SS "_parseparams"
.IX Subsection "_parseparams"
.Vb 9
\& Title   : _parseparams
\& Usage   : my $paramHash = $obj\->_parseparams(@args)
\& Function: Borrowed from Bio::Parse.pm, who borrowed it from CGI.pm
\&           Lincoln Stein \-> Richard Resnick \-> here
\& Returns : A hash reference of the parameter keys (uppercase) pointing to
\&           their values.
\& Args    : An array of key, value pairs. Easiest to pass values as:
\&           \-key1 => value1, \-key2 => value2, etc
\&           Leading "\-" are removed.
.Ve
.SS "_parse_xml"
.IX Subsection "_parse_xml"
.Vb 5
\& Title   : _parse_xml
\& Usage   : $dom = $obj\->_parse_xml($filename)
\& Function: uses XML::DOM to construct a DOM tree from the BSML document
\& Returns : a reference to the parsed DOM tree
\& Args    : 0 Path to the XML file needing to be parsed
.Ve
.SH "TESTING SCRIPT"
.IX Header "TESTING SCRIPT"
.Vb 7
\& The following script may be used to test the conversion process. You
\& will need a file of the format you wish to test. The script will
\& convert the file to BSML, store it in /tmp/bsmltemp, read that file
\& into a new SeqIO stream, and write it back as the original
\& format. Comparison of this second file to the original input file
\& will allow you to track where data may be lost or corrupted. Note
\& that you will need to specify $readfile and $readformat.
\&
\& use Bio::SeqIO;
\& # Tests preservation of details during round\-trip conversion:
\& # $readformat \-> BSML \-> $readformat
\& my $tempspot = "/tmp/bsmltemp";  # temp folder to hold generated files
\& my $readfile = "rps4y.embl";     # The name of the file you want to test
\& my $readformat = "embl";         # The format of the file being tested
\&
\& system "mkdir $tempspot" unless (\-d $tempspot);
\& # Make Seq object from the $readfile
\& my $biostream = Bio::SeqIO\->new( \-file => "$readfile" );
\& my $seq = $biostream\->next_seq();
\&
\& # Write BSML from SeqObject
\& my $bsmlout = Bio::SeqIO\->new( \-format => \*(Aqbsml\*(Aq,
\&                                   \-file => ">$tempspot/out.bsml");
\& warn "\enBSML written to $tempspot/out.bsml\en";
\& $bsmlout\->write_seq($seq);
\& # Need to kill object for following code to work... Why is this so?
\& $bsmlout = "";
\&
\& # Make Seq object from BSML
\& my $bsmlin = Bio::SeqIO\->new( \-file => "$tempspot/out.bsml",
\&                                  \-format => \*(Aqbsml\*(Aq);
\& my $seq2 = $bsmlin\->next_seq();
\&
\& # Write format back from Seq Object
\& my $genout = Bio::SeqIO\->new( \-format => $readformat,
\&                                   \-file => ">$tempspot/out.$readformat");
\& $genout\->write_seq($seq2);
\& warn "$readformat  written to $tempspot/out.$readformat\en";
\&
\& # BEING LOST:
\& # Join information (not possible in BSML 2.2)
\& # Sequence type (??)
.Ve
