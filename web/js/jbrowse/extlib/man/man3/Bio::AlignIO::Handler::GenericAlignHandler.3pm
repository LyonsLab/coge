.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::AlignIO::Handler::GenericAlignHandler 3"
.TH Bio::AlignIO::Handler::GenericAlignHandler 3 "2013-05-09" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::AlignIO::Handler::GenericAlignHandler \- Bio::HandlerI\-based
generic data handler class for alignment\-based data
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  # MyHandler is a GenericAlignHandler object.
\&  # inside a parser (driver) constructor....
\&
\&  $self\->alignhandler($handler || MyHandler\->new(\-format => \*(Aqstockholm\*(Aq));
\&
\&  # in next_aln() in driver...
\&
\&  $hobj = $self\->alignhandler();
\&
\&  # roll data up into hashref chunks, pass off into Handler for processing...
\&
\&  $hobj\->data_handler($data);
\&
\&  # or retrieve Handler methods and pass data directly to Handler methods...
\&
\&  my $hmeth = $hobj\->handler_methods;
\&
\&  if ($hmeth\->{ $data\->{NAME} }) {
\&      my $mth = $hmeth\->{ $data\->{NAME} };
\&      $hobj\->$mth($data);
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is an experimental implementation of a alignment-based HandlerBaseI parser
and may change over time. It is possible that the way handler methods are set up
will change over development to allow more flexibility.
.PP
Standard Developer caveats:
.PP
Here thar be dragoons...
.PP
Consider yourself warned!
.SS "\s-1NOTES\s0"
.IX Subsection "NOTES"
As in the SeqIO Handler object (still in development), data is passed in as
chunks. The Annotation and SeqFeatures are essentially the same as the SeqIO
parser; the significant difference is that data hash being passed could pertain
to either the alignment or to a specific sequence, so an extra tag may be needed
to disambiguate between the two in some cases. Here I use the \s-1ALIGNMENT\s0 tag as a
boolean flag: it must be present and set to 0 for the data to be tagged for
Bio::LocatableSeq or similar (in all other cases it is assumed to be for the
alignment). In some cases this will not matter (the actual sequence data, for
instance) but it is highly recommmended adding this tag in to prevent possible
ambiguities.
.PP
This is the current Annotation data chunk (via Data::Dumper):
.PP
.Vb 8
\&  $VAR1 = {
\&            \*(AqNAME\*(Aq => \*(AqREFERENCE\*(Aq,
\&            \*(AqDATA\*(Aq => \*(Aq1  (bases 1 to 10001)\*(Aq
\&            \*(AqAUTHORS\*(Aq => \*(AqInternational Human Genome Sequencing Consortium.\*(Aq
\&            \*(AqTITLE\*(Aq => \*(AqThe DNA sequence of Homo sapiens\*(Aq
\&            \*(AqJOURNAL\*(Aq => \*(AqUnpublished (2003)\*(Aq
\&            \*(AqALIGNMENT\*(Aq => 1,
\&          };
.Ve
.PP
In the case of LocatableSeqs, one can pass them in as follows for simplicity
(note the block line):
.PP
.Vb 8
\&  $VAR1 = {
\&            \*(AqNAME\*(Aq => \*(AqSEQUENCE\*(Aq, 
\&            \*(AqBLOCK_LINE\*(Aq => 0,
\&            \*(AqNSE\*(Aq => \*(AqQ7WNI7_BORBR/113\-292\*(Aq,
\&            \*(AqALPHABET\*(Aq => \*(Aqprotein\*(Aq,
\&            \*(AqDATA\*(Aq => \*(AqVALILGVYRRL...CYVNREM..RAG....QW\*(Aq,
\&            \*(AqALIGNMENT\*(Aq => 0            
\&          };
.Ve
.PP
This can be done as the parser parses each block instead of parsing all the
blocks and then passing them in one at a time; the handler will store the
sequence data by the block line in an internal hash, concatenating them along
the way.  This behaviour is b/c the alignment building step requires that
the sequence be checked for start/end/strand, possible meta sequence, optional
accession, etc.
.PP
Similarly, a Meta sequence line can be passed in as follows:
.PP
.Vb 8
\&  $VAR1 = {
\&            \*(AqNAME\*(Aq => \*(AqNAMED_META\*(Aq,
\&            \*(AqBLOCK_LINE\*(Aq => 0,
\&            \*(AqNSE\*(Aq => \*(AqQ7WNI7_BORBR/113\-292\*(Aq,
\&            \*(AqMETA_KEY\*(Aq => \*(AqpAS\*(Aq,
\&            \*(AqDATA\*(Aq => \*(Aq................................\*(Aq,
\&            \*(AqALIGNMENT\*(Aq => 0
\&          };
.Ve
.PP
The meta sequence will be checked against the \s-1NSE\s0 for the block position and
stored based on the meta tag. A meta sequence does not have to correspond to a
real sequence. At this time, unique meta sequence tags must be used for each
sequence or they will be overwritten (this may change).
.PP
An alignment consensus string:
.PP
.Vb 5
\&  $VAR1 = {
\&            \*(AqNAME\*(Aq => \*(AqCONSENSUS\*(Aq,
\&            \*(AqDATA\*(Aq => \*(AqVALILGVYRRL...CYVNREM..RAG....QW\*(Aq,
\&            \*(AqALIGNMENT\*(Aq => 1
\&          };
.Ve
.PP
A consensus meta sequence:
.PP
.Vb 6
\&  $VAR1 = {
\&            \*(AqNAME\*(Aq => \*(AqCONSENSUS_META\*(Aq,
\&            \*(AqMETA_KEY\*(Aq => \*(AqpAS\*(Aq,
\&            \*(AqDATA\*(Aq => \*(Aq................................\*(Aq,
\&            \*(AqALIGNMENT\*(Aq => 1
\&          };
.Ve
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  https://redmine.open\-bio.org/projects/bioperl/
.Ve
.SH "AUTHOR \- Chris Fields"
.IX Header "AUTHOR - Chris Fields"
Email cjfields at bioperl dot org
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods. Internal
methods are usually preceded with a _
.SS "new"
.IX Subsection "new"
.Vb 9
\& Title   :  new
\& Usage   :  
\& Function:  
\& Returns :  
\& Args    :  \-format    Sequence format to be mapped for handler methods
\&            \-builder   Bio::Seq::SeqBuilder object (normally defined in
\&                       SequenceStreamI object implementation constructor)
\& Throws  :  On undefined \*(Aq\-format\*(Aq sequence format parameter
\& Note    :  Still under heavy development
.Ve
.SH "Bio::HandlerBaseI implementing methods"
.IX Header "Bio::HandlerBaseI implementing methods"
.SS "handler_methods"
.IX Subsection "handler_methods"
.Vb 11
\& Title   :  handler_methods
\& Usage   :  $handler\->handler_methods(\*(AqGenBank\*(Aq)
\&            %handlers = $handler\->handler_methods();
\& Function:  Retrieve the handler methods used for the current format() in
\&            the handler.  This assumes the handler methods are already
\&            described in the HandlerI\-implementing class.
\& Returns :  a hash reference with the data type handled and the code ref
\&            associated with it.
\& Args    :  [optional] String representing the sequence format.  If set here
\&            this will also set sequence_format()
\& Throws  :  On unimplemented sequence format in %HANDLERS
.Ve
.SS "data_handler"
.IX Subsection "data_handler"
.Vb 5
\& Title   :  data_handler
\& Usage   :  $handler\->data_handler($data)
\& Function:  Centralized method which accepts all data chunks, then distributes
\&            to the appropriate methods for processing based on the chunk name
\&            from within the HandlerBaseI object.
\&
\&            One can also use 
\& Returns :  None
\& Args    :  an hash ref containing a data chunk.
.Ve
.SS "reset_parameters"
.IX Subsection "reset_parameters"
.Vb 6
\& Title   :  reset_parameters
\& Usage   :  $handler\->reset_parameters()
\& Function:  Resets the internal cache of data (normally object parameters for
\&            a builder or factory)
\& Returns :  None
\& Args    :  None
.Ve
.SS "format"
.IX Subsection "format"
.Vb 9
\& Title   :  format
\& Usage   :  $handler\->format(\*(AqGenBank\*(Aq)
\& Function:  Get/Set the format for the report/record being parsed. This can be
\&            used to set handlers in classes which are capable of processing
\&            similar data chunks from multiple driver modules.
\& Returns :  String with the sequence format
\& Args    :  [optional] String with the sequence format
\& Note    :  The format may be used to set the handlers (as in the
\&            current GenericRichSeqHandler implementation)
.Ve
.SS "get_params"
.IX Subsection "get_params"
.Vb 8
\& Title   :  get_params
\& Usage   :  $handler\->get_params(\*(Aq\-species\*(Aq)
\& Function:  Convenience method used to retrieve the specified
\&            parameters from the internal parameter cache
\& Returns :  Hash ref containing parameters requested and data as
\&            key\-value pairs.  Note that some parameter values may be 
\&            objects, arrays, etc.
\& Args    :  List (array) representing the parameters requested
.Ve
.SS "set_params"
.IX Subsection "set_params"
.Vb 5
\& Title   :  set_params
\& Usage   :  $handler\->set_param({\*(Aq\-seqs\*(Aq => $seqs})
\& Function:  Convenience method used to set specific parameters
\& Returns :  None
\& Args    :  Hash ref containing the data to be passed as key\-value pairs
.Ve
.SH "Methods unique to this implementation"
.IX Header "Methods unique to this implementation"
.SS "build_alignment"
.IX Subsection "build_alignment"
.Vb 7
\& Title   :  build_alignment
\& Usage   :  
\& Function:  
\& Returns :  a Bio::SimpleAlign
\& Args    :
\& Throws  :
\& Note    :  This may be replaced by a Builder object at some point
.Ve
.SS "annotation_collection"
.IX Subsection "annotation_collection"
.Vb 7
\& Title   :  annotation_collection
\& Usage   :  
\& Function:  
\& Returns :  
\& Args    :
\& Throws  :
\& Note    :
.Ve
.SS "seq_annotation_collection"
.IX Subsection "seq_annotation_collection"
.Vb 7
\& Title   :  seq_annotation_collection
\& Usage   :  
\& Function:  
\& Returns :  
\& Args    :
\& Throws  :
\& Note    :
.Ve
.SS "process_seqs"
.IX Subsection "process_seqs"
.Vb 6
\& Title   :  process_seqs
\& Usage   :  $handler\->process_seqs;
\& Function:  checks internal sequences to ensure they are converted over
\&            to the proper Bio::AlignI\-compatible sequence class
\& Returns :  1 if successful
\& Args    :  none
.Ve
