.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Tools::Run::WrapperBase::CommandExts 3"
.TH Bio::Tools::Run::WrapperBase::CommandExts 3 "2013-05-09" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::Tools::Run::WrapperBase::CommandExts \- Extensions to WrapperBase for handling programs with commands *ALPHA*
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Devs, see \*(L"\s-1DEVELOPER\s0 \s-1INTERFACE\s0\*(R".
Users, see \*(L"\s-1USER\s0 \s-1INTERFACE\s0\*(R".
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a developer-focused experimental module. The main idea is to
extend Bio::Tools::Run::WrapperBase to make it relatively easy to
create run wrappers around \fIsuites\fR of related programs, like
\&\f(CW\*(C`samtools\*(C'\fR or \f(CW\*(C`blast+\*(C'\fR.
.PP
Some definitions:
.IP "\(bu" 4
program
.Sp
The program is the command-line frontend application. \f(CW\*(C`samtools\*(C'\fR, for example, is run from the command line as follows:
.Sp
.Vb 2
\& $ samtools view \-bS in.bam > out.sam
\& $ samtools faidx
.Ve
.IP "\(bu" 4
command
.Sp
The command is the specific component of a suite run by executing the
program. In the example above, \f(CW\*(C`view\*(C'\fR and \f(CW\*(C`faidx\*(C'\fR are commands.
.IP "\(bu" 4
command prefix
.Sp
The command prefix is an abbreviation of the command name used
internally by \f(CW\*(C`CommandExts\*(C'\fR method, and sometimes by the user of the
factory for specifying command line parameters to subcommands of
composite commands.
.IP "\(bu" 4
composite command
.Sp
A composite command is a pipeline or script representing a series of
separate executions of different commands. Composite commands can be
specified by configuring \f(CW\*(C`CommandExts\*(C'\fR appropriately; the composite
command can be run by the user from a factory in the same way as
ordinary commands.
.IP "\(bu" 4
options, parameters, switches and filespecs
.Sp
An option is any command-line option; i.e., a specification set off by
a command-line by a specifier (like \f(CW\*(C`\-v\*(C'\fR or \f(CW\*(C`\-\-outfile\*(C'\fR). Parameters
are command-line options that accept a value (\f(CW\*(C`\-title mydb\*(C'\fR);
switches are boolean flags (\f(CW\*(C`\-\-no\-filter\*(C'\fR). Filespecs are barewords
at the end of the command line that usually indicate input or output
files. In this module, this includes files that capture \s-1STDIN\s0, \s-1STDOUT\s0,
or \s-1STDERR\s0 via redirection.
.IP "\(bu" 4
pseudo-program
.Sp
A \*(L"pseudo-program\*(R" is a way to refer to a collection of related
applications that are run independently from the command line, rather
than via a frontend program. The \f(CW\*(C`blast+\*(C'\fR suite of programs is an
example: \f(CW\*(C`blastn\*(C'\fR, \f(CW\*(C`makeblastdb\*(C'\fR, etc. \f(CW\*(C`CommandExts\*(C'\fR can be
configured to create a single factory for a suite of related,
independent programs that treats each independent program as a
\&\*(L"pseudo-program\*(R" command.
.PP
This module essentially adds the non-assembler-specific wrapper
machinery of fangly's Bio::Tools::Run::AssemblerBase to the
Bio::Tools::Run::WrapperBase namespace, adding the general
command-handling capability of Bio::Tools::Run::BWA. It creates run
factories that are automatically Bio::ParameterBaseI compliant,
meaning that \f(CW\*(C`available_parameters()\*(C'\fR, \f(CW\*(C`set_parameters()\*(C'\fR,
\&\f(CW\*(C`get_parameters\*(C'\fR, \f(CW\*(C`reset_parameters()\*(C'\fR, and \f(CW\*(C`parameters_changed()\*(C'\fR
are available.
.SH "DEVELOPER INTERFACE"
.IX Header "DEVELOPER INTERFACE"
\&\f(CW\*(C`CommandExts\*(C'\fR is currently set up to read particular package globals
which define the program, the commands available, command-line options
for those commands, and human-readable aliases for those options.
.PP
The easiest way to use \f(CW\*(C`CommandExts\*(C'\fR is probably to create two modules:
.PP
.Vb 2
\& Bio::Tools::Run::YourRunPkg
\& Bio::Tools::Run::YourRunPkg::Config
.Ve
.PP
The package globals should be defined in the \f(CW\*(C`Config\*(C'\fR module, and the
run package itself should begin with the following mantra:
.PP
.Vb 10
\& use YourRunPkg::Config;
\& use Bio::Tools::Run::WrapperBase;
\& use Bio::Tools::Run::WrapperBase::CommandExts;
\& sub new {
\&     my $class = shift;
\&     my @args = @_;
\&     my $self = $class\->SUPER::new(@args);
\&     ...
\&     return $self;
\& }
.Ve
.PP
The following globals can/should be defined in the \f(CW\*(C`Config\*(C'\fR module:
.PP
.Vb 11
\&  $program_name
\&  $program_dir
\&  $use_dash
\&  $join
\&  @program_commands 
\&  %command_prefixes
\&  @program_params
\&  @program_switches 
\&  %param_translation
\&  %composite_commands
\&  %command_files
.Ve
.PP
See \*(L"Config Globals\*(R" for detailed descriptions.
.PP
The work of creating a run wrapper with \f(CW\*(C`CommandExts\*(C'\fR lies mainly in
setting up the globals. The key methods for the developer interface are:
.IP "\(bu" 4
program_dir($path_to_programs)
.Sp
Set this to point the factory to the executables.
.IP "\(bu" 4
_run(@file_args)
.Sp
Runs an instantiated factory with the given file args. Use in the
 \f(CW\*(C`run()\*(C'\fR method override.
.IP "\(bu" 4
\&\fI_create_factory_set()\fR
.Sp
Returns a hash of instantiated factories for each true command from a
composite command factory. The hash keys are the true command names, so
you could do
.Sp
.Vb 4
\& $cmds = $composite_fac\->_create_factory_set;
\& for (@true_commands) {
\&    $cmds\->{$_}\->_run(@file_args);
\& }
.Ve
.IP "\(bu" 4
executables($cmd,[$fullpath])
.Sp
For pseudo-programs, this gets/sets the full path to the executable of
the true program corresponding to the command \f(CW$cmd\fR.
.SS "Implementing Composite Commands"
.IX Subsection "Implementing Composite Commands"
.SS "Implementing Pseudo-programs"
.IX Subsection "Implementing Pseudo-programs"
To indicate that a package wraps disparate programs under a single pseudo program, use an asterisk before the program name:
.PP
.Vb 3
\& package Bio::Tools::Run::YourPkg::Config;
\& ...
\& our $program_name = \*(Aq*blast+\*(Aq;
.Ve
.PP
and \f(CW\*(C`_run\*(C'\fR will know what to do. Specify the rest of the globals as
if the desired programs were commands. Use the basename of the
programs for the command names.
.PP
If all the programs can be found in a single directory, just specify
that directory in \f(CW\*(C`program_dir()\*(C'\fR. If not, use \f(CW\*(C`executables()\*(C'\fR to set the paths to each program explicitly:
.PP
.Vb 3
\& foreach (keys %cmdpaths) {
\&    $self\->executables($_, $cmdpaths{$_});
\& }
.Ve
.SS "Config Globals"
.IX Subsection "Config Globals"
Here is an example config file. Further details in prose are below.
.PP
.Vb 10
\& package Dummy::Config;
\& use strict;
\& use warnings;
\& no warnings qw(qw);
\& use Exporter;
\& our (@ISA, @EXPORT, @EXPORT_OK);
\& push @ISA, \*(AqExporter\*(Aq;
\& @EXPORT = qw(
\&              $program_name
\&              $program_dir
\&              $use_dash
\&              $join
\&              @program_commands
\&              %command_prefixes
\&              @program_params
\&              @program_switches
\&              %param_translation
\&              %command_files
\&              %composite_commands
\&             );
\&
\& our $program_name = \*(Aq*flurb\*(Aq;
\& our $program_dir = \*(AqC:\ecygwin\eusr\elocal\ebin\*(Aq;
\& our $use_dash = \*(Aqmixed\*(Aq;
\& our $join = \*(Aq \*(Aq;
\& 
\& our @program_commands = qw(
\&  rpsblast
\&  cat
\&  goob
\&  blorb
\&  multiglob
\&   );
\&
\& our %command_prefixes = (
\&     blastp => \*(Aqblp\*(Aq,
\&     tblastn => \*(Aqtbn\*(Aq,
\&     goob => \*(Aqg\*(Aq,
\&     blorb => \*(Aqb\*(Aq,
\&     multiglob => \*(Aqm\*(Aq
\&     );
\&
\& our @program_params = qw(
\&     command
\&     g|narf
\&     g|schlurb
\&     b|scroob
\&     b|frelb
\&     m|trud
\& );
\& 
\& our @program_switches = qw(
\&     g|freen
\&     b|klep
\& );
\& 
\& our %param_translation = (
\&     \*(Aqg|narf\*(Aq     => \*(Aqn\*(Aq,
\&     \*(Aqg|schlurb\*(Aq  => \*(Aqschlurb\*(Aq,
\&     \*(Aqg|freen\*(Aq    => \*(Aqf\*(Aq,
\&     \*(Aqb|scroob\*(Aq   => \*(Aqs\*(Aq,
\&     \*(Aqb|frelb\*(Aq    => \*(Aqfrelb\*(Aq
\&     );
\& 
\& our %command_files = (
\&     \*(Aqgoob\*(Aq       => [qw( fas faq )],
\&     );
\& 
\& our %composite_commands = (
\&     \*(Aqmultiglob\*(Aq => [qw( blorb goob )]
\&     );
\& 1;
.Ve
.PP
\&\f(CW$use_dash\fR can be one of \f(CW\*(C`single\*(C'\fR, \f(CW\*(C`double\*(C'\fR, or \f(CW\*(C`mixed\*(C'\fR. See Bio::Tools::Run::WrapperBase.
.PP
There is a syntax for the \f(CW%command_files\fR specification. The token
matching \f(CW\*(C`[a\-zA\-Z0\-9_]+\*(C'\fR in each element of each arrayref becomes the
named filespec parameter for the \f(CW\*(C`_run()\*(C'\fR method in the wrapper
class. Additional symbols surrounding this token indicate how this
argument should be handled. Some examples:
.PP
.Vb 10
\& >out  : stdout is redirected into the file 
\&         specified by (..., \-out => $file,... )
\& <in   : stdin is accepted from the file 
\&         specified by (..., \-in => $file,... )
\& 2>log : stderr is redirected into the file
\&         specified by (..., \-log => $file,... )
\& #opt  : this filespec argument is optional
\&         (no throw if \-opt => $option is missing)
\& 2>#log: if \-log is not specified in the arguments, the stderr() 
\&         method will capture stderr
\& *lst  : this filespec can take multiple arguments,
\&         specify using an arrayref (..., \-lst => [$file1, $file2], ...)
\& *#lst : an optional list
.Ve
.PP
The tokens above are examples; they can be anything matching the above regexp.
.SH "USER INTERFACE"
.IX Header "USER INTERFACE"
Using a wrapper created with \f(CW\*(C`Bio::Tools::Run::WrapperBase::CommandExts\*(C'\fR:
.IP "\(bu" 4
Getting a list of available commands, parameters, and filespecs:
.Sp
To get a list of commands, simply:
.Sp
.Vb 1
\& @commands = Bio::Tools::Run::ThePkg\->available_commands;
.Ve
.Sp
The wrapper will generally have human-readable aliases for each of the
command-line options for the wrapped program and commands. To obtain a
list of the parameters and switches available for a particular
command, do
.Sp
.Vb 5
\& $factory = Bio::Tools::Run::ThePkg\->new( \-command => \*(Aqglurb\*(Aq );
\& @params = $factory\->available_parameters(\*(Aqparams\*(Aq);
\& @switches = $factory\->available_parameters(\*(Aqswitches\*(Aq);
\& @filespec = $factory\->available_parameters(\*(Aqfilespec\*(Aq);
\& @filespec = $factory\->filespec; # alias
.Ve
.IP "\(bu" 4
Create factories
.Sp
The factory is a handle on the program and command you wish to
run. Create a factory using \f(CW\*(C`new\*(C'\fR to set command-line parameters:
.Sp
.Vb 3
\& $factory = Bio::Tools::Run::ThePkg\->new( \-command => \*(Aqglurb\*(Aq, 
\&                                          \-freen => 1,
\&                                          \-furschlugginer => \*(Aqvreeble\*(Aq );
.Ve
.Sp
A shorthand for this is:
.Sp
.Vb 3
\& $factory = Bio::Tools::Run::ThePkg\->new_glurb( 
\&                                       \-freen => 1, 
\&                                       \-furschlugginer => \*(Aqvreeble\*(Aq );
.Ve
.IP "\(bu" 4
Running programs
.Sp
To run the program, use the \f(CW\*(C`run\*(C'\fR method, providing filespecs as arguments
.Sp
.Vb 6
\& $factory = Bio::Tools::Run::ThePkg\->new_assemble( \-min_qual => 63 );
\& $factory\->run( \-faq1 => \*(Aqread1.fq\*(Aq, \-faq2 => \*(Aqread2.fq\*(Aq, 
\&                \-ref => \*(Aqrefseq.fas\*(Aq, \-out => \*(Aqnew.sam\*(Aq );
\& # do another
\& $factory\->run( \-faq1 => \*(Aqread\-old1.fq\*(Aq, \-faq2 => \*(Aqread\-old2.fq\*(Aq, 
\&                \-ref => \*(Aqrefseq.fas\*(Aq, \-out => \*(Aqold.sam\*(Aq );
.Ve
.Sp
Messages on \s-1STDOUT\s0 and \s-1STDERR\s0 are dumped into their respective attributes:
.Sp
.Vb 2
\& $stdout = $factory\->stdout;
\& $stderr = $factory\->stderr;
.Ve
.Sp
unless \s-1STDOUT\s0 and/or \s-1STDERR\s0 are part of the named files in the filespec.
.IP "\(bu" 4
Setting/getting/resetting/polling parameters.
.Sp
A \f(CW\*(C`CommandExts\*(C'\fR\-based factory is always Bio::ParameterBaseI
compliant. That means that you may set, get, and reset parameters
using \f(CW\*(C`set_parameters()\*(C'\fR, \f(CW\*(C`get_parameters()\*(C'\fR, and
\&\f(CW\*(C`reset_parameters\*(C'\fR. You can ask whether parameters have changed since
they were last accessed by using the predicate
\&\f(CW\*(C`parameters_changed\*(C'\fR. See Bio::ParameterBaseI for more details.
.Sp
Once set, parameters become attributes of the factory. Thus, you can get their values as follows:
.Sp
.Vb 4
\& if ($factory\->freen) { 
\&    $furs = $factory\->furshlugginer;
\&    #...
\& }
.Ve
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to
the Bioperl mailing list.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
bioperl\-l@bioperl.org
.PP
rather than to the module maintainer directly. Many experienced and
reponsive experts will be able look at the problem and quickly
address it. Please include a thorough description of the problem
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
of the bugs and their resolution. Bug reports can be submitted via
the web:
.PP
.Vb 1
\&  https://redmine.open\-bio.org/projects/bioperl/
.Ve
.SH "AUTHOR \- Mark A. Jensen"
.IX Header "AUTHOR - Mark A. Jensen"
Email maj \-at\- fortinbras \-dot\- us
.PP
Describe contact details here
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Dan Kortschak ( dan \-dot\- kortschak \-at\- adelaide \-dot\- edu \-dot\- au )
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _
.SS "\fInew()\fP"
.IX Subsection "new()"
.Vb 10
\& Title   : new
\& Usage   : 
\& Function: constructor for WrapperBase::CommandExts ; 
\&           correctly binds configuration variables
\&           to the WrapperBase object
\& Returns : Bio::Tools::Run::WrapperBase object with command extensions
\& Args    : 
\& Note    : this method subsumes the old _register_program_commands and
\&           _set_program_options, leaving out the assembler\-specific
\&           parms ($qual_param and out_type())
.Ve
.SS "program_name"
.IX Subsection "program_name"
.Vb 5
\& Title   : program_name
\& Usage   : $factory\->program_name($name)
\& Function: get/set the executable name
\& Returns:  string
\& Args    : string
.Ve
.SS "program_dir"
.IX Subsection "program_dir"
.Vb 5
\& Title   : program_dir
\& Usage   : $factory\->program_dir($dir)
\& Function: get/set the program dir
\& Returns:  string
\& Args    : string
.Ve
.SS "\fI_register_program_commands()\fP"
.IX Subsection "_register_program_commands()"
.Vb 10
\& Title   : _register_program_commands
\& Usage   : $factory\->_register_program_commands( \e@commands, \e%prefixes )
\& Function: Register the commands a program accepts (for programs that act
\&           as frontends for a set of commands, each command having its own
\&           set of params/switches)
\& Returns : true on success
\& Args    : arrayref to a list of commands (scalar strings),
\&           hashref to a translation table of the form
\&           { $prefix1 => $command1, ... } [optional]
\& Note    : To implement a program with this kind of calling structure, 
\&           include a parameter called \*(Aqcommand\*(Aq in the 
\&           @program_params global
\& Note    : The translation table is used to associate parameters and 
\&           switches specified in _set_program_options with the correct
\&           program command. In the globals @program_params and
\&           @program_switches, specify elements as \*(Aqprefix1|param\*(Aq and 
\&           \*(Aqprefix1|switch\*(Aq, etc.
.Ve
.SS "_set_program_options"
.IX Subsection "_set_program_options"
.Vb 11
\& Title   : _set_program_options
\& Usage   : $factory\->_set_program_options( \e@ args );
\& Function: Register the parameters and flags that an assembler takes.
\& Returns : 1 for success
\& Args    : \- arguments passed by the user
\&           \- parameters that the program accepts, optional (default: none)
\&           \- switches that the program accepts, optional (default: none)
\&           \- parameter translation, optional (default: no translation occurs)
\&           \- dash option for the program parameters, [1|single|double|mixed],
\&             optional (default: yes, use single dashes only)
\&           \- join, optional (default: \*(Aq \*(Aq)
.Ve
.SS "_translate_params"
.IX Subsection "_translate_params"
.Vb 6
\& Title   : _translate_params
\& Usage   : @options = $assembler\->_translate_params( );
\& Function: Translate the Bioperl arguments into the arguments to pass to the
\&           program on the command line
\& Returns : Arrayref of arguments
\& Args    : none
.Ve
.SS "\fIexecutable()\fP"
.IX Subsection "executable()"
.Vb 10
\& Title   : executable
\& Usage   : 
\& Function: find the full path to the main executable,
\&           or to the command executable for pseudo\-programs
\& Returns : full path, if found
\& Args    : [optional] explicit path to the executable
\&           (will set the appropriate command exec if
\&            applicable)
\&           [optional] boolean flag whether or not to warn when exe no found
\& Note    : overrides WrapperBase.pm
.Ve
.SS "\fIexecutables()\fP"
.IX Subsection "executables()"
.Vb 7
\& Title   : executables
\& Usage   : 
\& Function: find the full path to a command\*(Aqs executable
\& Returns : full path (scalar string)
\& Args    : command (scalar string), 
\&           [optional] explicit path to this command exe
\&           [optional] boolean flag whether or not to warn when exe no found
.Ve
.SS "\fI_find_executable()\fP"
.IX Subsection "_find_executable()"
.Vb 8
\& Title   : _find_executable
\& Usage   : my $exe_path = $fac\->_find_executable($exe, $warn);
\& Function: find the full path to a named executable,
\& Returns : full path, if found
\& Args    : name of executable to find
\&           [optional] boolean flag whether or not to warn when exe no found
\& Note    : differs from executable and executables in not
\&           setting any object attributes
.Ve
.SS "\fI_register_composite_commands()\fP"
.IX Subsection "_register_composite_commands()"
.Vb 7
\& Title   : _register_composite_commands
\& Usage   : 
\& Function: adds subcomand params and switches for composite commands
\& Returns : true on success
\& Args    : \e%composite_commands,
\&           \e@program_params,
\&           \e@program_switches
.Ve
.SS "\fI_create_factory_set()\fP"
.IX Subsection "_create_factory_set()"
.Vb 8
\& Title   : _create_factory_set
\& Usage   : @facs = $self\->_create_factory_set
\& Function: instantiate a set of individual command factories for
\&           a given composite command
\&           Factories will have the correct parameter fields set for
\&           their own subcommand
\& Returns : hash of factories: ( $subcmd_prefix => $subcmd_factory, ... )
\& Args    : none
.Ve
.SS "\fI_collate_subcmd_args()\fP"
.IX Subsection "_collate_subcmd_args()"
.Vb 7
\& Title   : _collate_subcmd_args
\& Usage   : $args_hash = $self\->_collate_subcmd_args
\& Function: collate parameters and switches into command\-specific
\&           arg lists for passing to new()
\& Returns : hash of named argument lists
\& Args    : [optional] composite cmd prefix (scalar string) 
\&           [default is \*(Aqrun\*(Aq]
.Ve
.SS "_run"
.IX Subsection "_run"
.Vb 6
\& Title   : _run
\& Usage   : $fac\->_run( @file_args )
\& Function: Run a command as specified during object contruction
\& Returns : true on success
\& Args    : a specification of the files to operate on according
\&           to the filespec
.Ve
.SS "\fIno_throw_on_crash()\fP"
.IX Subsection "no_throw_on_crash()"
.Vb 5
\& Title   : no_throw_on_crash
\& Usage   : 
\& Function: prevent throw on execution error
\& Returns : 
\& Args    : [optional] boolean
.Ve
.SS "\fIlast_execution()\fP"
.IX Subsection "last_execution()"
.Vb 5
\& Title   : last_execution
\& Usage   : 
\& Function: return the last executed command with options
\& Returns : string of command line sent to IPC::Run
\& Args    :
.Ve
.SS "\fI_dash_switch()\fP"
.IX Subsection "_dash_switch()"
.Vb 5
\& Title   : _dash_switch
\& Usage   : $version = $fac\->_dash_switch( $switch )
\& Function: Returns an appropriately dashed switch for the executable
\& Args    : A string containing a switch without dashes
\& Returns : string containing an appropriately dashed switch for the current executable
.Ve
.SS "\fIstdout()\fP"
.IX Subsection "stdout()"
.Vb 7
\& Title   : stdout
\& Usage   : $fac\->stdout()
\& Function: store the output from STDOUT for the run, 
\&           if no file specified in _run arguments
\& Example : 
\& Returns : scalar string
\& Args    : on set, new value (a scalar or undef, optional)
.Ve
.SS "\fIstderr()\fP"
.IX Subsection "stderr()"
.Vb 7
\& Title   : stderr
\& Usage   : $fac\->stderr()
\& Function: store the output from STDERR for the run, 
\&           if no file is specified in _run arguments
\& Example : 
\& Returns : scalar string
\& Args    : on set, new value (a scalar or undef, optional)
.Ve
.SS "\fIis_pseudo()\fP"
.IX Subsection "is_pseudo()"
.Vb 7
\& Title   : is_pseudo
\& Usage   : $obj\->is_pseudo($newval)
\& Function: returns true if this factory represents
\&           a pseudo\-program
\& Example : 
\& Returns : value of is_pseudo (boolean)
\& Args    : on set, new value (a scalar or undef, optional)
.Ve
.SS "\s-1AUTOLOAD\s0"
.IX Subsection "AUTOLOAD"
\&\s-1AUTOLOAD\s0 permits
.PP
.Vb 1
\& $class\->new_yourcommand(@args);
.Ve
.PP
as an alias for
.PP
.Vb 1
\& $class\->new( \-command => \*(Aqyourcommand\*(Aq, @args );
.Ve
.SH "Bio:ParameterBaseI compliance"
.IX Header "Bio:ParameterBaseI compliance"
.SS "\fIset_parameters()\fP"
.IX Subsection "set_parameters()"
.Vb 5
\& Title   : set_parameters
\& Usage   : $pobj\->set_parameters(%params);
\& Function: sets the parameters listed in the hash or array
\& Returns : true on success
\& Args    : [optional] hash or array of parameter/values.
.Ve
.SS "\fIreset_parameters()\fP"
.IX Subsection "reset_parameters()"
.Vb 5
\& Title   : reset_parameters
\& Usage   : resets values
\& Function: resets parameters to either undef or value in passed hash
\& Returns : none
\& Args    : [optional] hash of parameter\-value pairs
.Ve
.SS "\fIparameters_changed()\fP"
.IX Subsection "parameters_changed()"
.Vb 5
\& Title   : parameters_changed
\& Usage   : if ($pobj\->parameters_changed) {...}
\& Function: Returns boolean true (1) if parameters have changed
\& Returns : Boolean (0 or 1)
\& Args    : [optional] Boolean
.Ve
.SS "\fIavailable_parameters()\fP"
.IX Subsection "available_parameters()"
.Vb 7
\& Title   : available_parameters
\& Usage   : @params = $pobj\->available_parameters()
\& Function: Returns a list of the available parameters
\& Returns : Array of parameters
\& Args    : \*(Aqparams\*(Aq for settable program parameters
\&           \*(Aqswitches\*(Aq for boolean program switches
\&           default: all
.Ve
.SS "\fIget_parameters()\fP"
.IX Subsection "get_parameters()"
.Vb 6
\& Title   : get_parameters
\& Usage   : %params = $pobj\->get_parameters;
\& Function: Returns list of key\-value pairs of parameter => value
\& Returns : List of key\-value pairs
\& Args    : [optional] A string is allowed if subsets are wanted or (if a
\&           parameter subset is default) \*(Aqall\*(Aq to return all parameters
.Ve
