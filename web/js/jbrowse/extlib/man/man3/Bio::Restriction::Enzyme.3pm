.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Restriction::Enzyme 3"
.TH Bio::Restriction::Enzyme 3 "2013-05-09" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::Restriction::Enzyme \- A single restriction endonuclease
(cuts DNA at specific locations)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  # set up a single restriction enzyme. This contains lots of
\&  # information about the enzyme that is generally parsed from a
\&  # rebase file and can then be read back
\&
\&  use Bio::Restriction::Enzyme;
\&
\&  # define a new enzyme with the cut sequence
\&  my $re=Bio::Restriction::Enzyme\->new
\&      (\-enzyme=>\*(AqEcoRI\*(Aq, \-seq=>\*(AqG^AATTC\*(Aq);
\&
\&  # once the sequence has been defined a bunch of stuff is calculated
\&  # for you:
\&
\&  #### PRECALCULATED
\&
\&  # find where the enzyme cuts after ...
\&  my $ca=$re\->cut;
\&
\&  # ... and where it cuts on the opposite strand
\&  my $oca = $re\->complementary_cut;
\&
\&  # get the cut sequence string back.
\&  # Note that site will return the sequence with a caret
\&  my $with_caret=$re\->site; #returns \*(AqG^AATTC\*(Aq;
\&
\&  # but it is also a Bio::PrimarySeq object ....
\&  my $without_caret=$re\->seq; # returns \*(AqGAATTC\*(Aq;
\&  # ... and so does string
\&  $without_caret=$re\->string; #returns \*(AqGAATTC\*(Aq;
\&
\&  # what is the reverse complement of the cut site
\&  my $rc=$re\->revcom; # returns \*(AqGAATTC\*(Aq;
\&
\&  # now the recognition length. There are two types:
\&  #   recognition_length() is the length of the sequence
\&  #   cutter() estimate of cut frequency
\&
\&  my $recog_length = $re\->recognition_length; # returns 6
\&  # also returns 6 in this case but would return 
\&  # 4 for GANNTC and 5 for RGATCY (BstX2I)!
\&  $recog_length=$re\->cutter; 
\&
\&  # is the sequence a palindrome  \- the same forwards and backwards
\&  my $pal= $re\->palindromic; # this is a boolean
\&
\&  # is the sequence blunt (i.e. no overhang \- the forward and reverse
\&  # cuts are the same)
\&  print "blunt\en" if $re\->overhang eq \*(Aqblunt\*(Aq;
\&
\&  # Overhang can have three values: "5\*(Aq", "3\*(Aq", "blunt", and undef
\&  # Direction is very important if you use Klenow!
\&  my $oh=$re\->overhang;
\&
\&  # what is the overhang sequence
\&  my $ohseq=$re\->overhang_seq; # will return \*(AqAATT\*(Aq;
\&
\&  # is the sequence ambiguous \- does it contain non\-GATC bases?
\&  my $ambig=$re\->is_ambiguous; # this is boolean
\&
\&  print "Stuff about the enzyme\enCuts after: $ca\en",
\&        "Complementary cut: $oca\enSite:\en\et$with_caret or\en",
\&        "\et$without_caret\en";
\&  print "Reverse of the sequence: $rc\enRecognition length: $recog_length\en",
\&        "Is it palindromic? $pal\en";
\&  print "The overhang is $oh with sequence $ohseq\en",
\&        "And is it ambiguous? $ambig\en\en";
\&
\&
\&  ### THINGS YOU CAN SET, and get from rich REBASE file
\&
\&  # get or set the isoschizomers (enzymes that recognize the same
\&  # site)
\&  $re\->isoschizomers(\*(AqPvuII\*(Aq, \*(AqSmaI\*(Aq); # not really true :)
\&  print "Isoschizomers are ", join " ", $re\->isoschizomers, "\en";
\&
\&  # get or set the methylation sites
\&  $re\->methylation_sites(2); # not really true :)
\&  print "Methylated at ", join " ", keys %{$re\->methylation_sites},"\en";
\&
\&  #Get or set the source microbe
\&  $re\->microbe(\*(AqE. coli\*(Aq);
\&  print "It came from ", $re\->microbe, "\en";
\&
\&  # get or set the person who isolated it
\&  $re\->source("Rob"); # not really true :)
\&  print $re\->source, " sent it to us\en";
\&
\&  # get or set whether it is commercially available and the company
\&  # that it can be bought at
\&  $re\->vendors(\*(AqNEB\*(Aq); # my favorite
\&  print "Is it commercially available :";
\&  print $re\->vendors ? "Yes" : "No";
\&  print " and it can be got from ", join " ", 
\&      $re\->vendors, "\en";
\&
\&  # get or set a reference for this
\&  $re\->reference(\*(AqEdwards et al. J. Bacteriology\*(Aq);
\&  print "It was not published in ", $re\->reference, "\en";
\&
\&  # get or set the enzyme name
\&  $re\->name(\*(AqBamHI\*(Aq);
\&  print "The name of EcoRI is not really ", $re\->name, "\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module defines a single restriction endonuclease.  You can use it
to make custom restriction enzymes, and it is used by
Bio::Restriction::IO to define enzymes in the New England Biolabs
\&\s-1REBASE\s0 collection.
.PP
Use Bio::Restriction::Analysis to figure out which enzymes are available
and where they cut your sequence.
.SH "RESTRICTION MODIFICATION SYSTEMS"
.IX Header "RESTRICTION MODIFICATION SYSTEMS"
At least three geneticaly and biochamically distinct restriction
modification systems exist. The cutting components of them are known
as restriction endonuleases.  The three systems are known by roman
numerals: Type I, \s-1II\s0, and \s-1III\s0 restriction enzymes.
.PP
\&\s-1REBASE\s0 format 'cutzymes'(#15) lists enzyme type in its last field. The
categories there do not always match the the following short
descriptions of the enzymes types. See
http://it.stlawu.edu/~tbudd/rmsyst.html for a better overview.
.SS "TypeI"
.IX Subsection "TypeI"
Type I systems recognize a bipartite asymetrical sequence of 5\-7 bp:
.PP
.Vb 2
\&  \-\-\-TGA*NnTGCT\-\-\- * = methylation sites
\&  \-\-\-ACTNnA*CGA\-\-\- n = 6 for EcoK, n = 8 for EcoB
.Ve
.PP
The cleavage site is roughly 1000 (400\-7000) base pairs from the
recognition site.
.SS "TypeII"
.IX Subsection "TypeII"
The simplest and most common (at least commercially).
.PP
Site recognition is via short palindromic base sequences that are 4\-6
base pairs long. Cleavage is at the recognition site (but may
occasionally be just adjacent to the palindromic sequence, usually
within) and may produce blunt end termini or staggered, \*(L"sticky
end\*(R" termini.
.SS "TypeIII"
.IX Subsection "TypeIII"
The recognition site is a 5\-7 bp asymmetrical sequence. Cleavage is
\&\s-1ATP\s0 dependent 24\-26 base pairs downstream from the recognition site
and usually yields staggered cuts 2\-4 bases apart.
.SH "COMMENTS"
.IX Header "COMMENTS"
I am trying to make this backwards compatible with
Bio::Tools::RestrictionEnzyme.  Undoubtedly some things will break,
but we can fix things as we progress.....!
.PP
I have added another comments section at the end of this \s-1POD\s0 that
discusses a couple of areas I know are broken (at the moment)
.SH "TO DO"
.IX Header "TO DO"
.IP "\(bu" 2
Convert vendors touse full names of companies instead of code
.IP "\(bu" 2
Add regular expression based matching to vendors
.IP "\(bu" 2
Move away from the archaic ^ notation for cut sites. Ideally
I'd totally like to remove this altogether, or add a method
that adds it in if someone really wants it. We should be
fixed on a sequence, number notation.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists. Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution. Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  https://redmine.open\-bio.org/projects/bioperl/
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Rob Edwards, redwards@utmem.edu
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Heikki Lehvaslaiho, heikki-at-bioperl-dot-org
Peter Blaiklock, pblaiklo@restrictionmapper.org
Mark A. Jensen, maj-at-fortinbras-dot-us
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2003 Rob Edwards.
.PP
Some of this work is Copyright (c) 1997\-2002 Steve A. Chervitz. All
Rights Reserved.  This module is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Bio::Restriction::Analysis, 
Bio::Restriction::EnzymeCollection, Bio::Restriction::IO
.SH "APPENDIX"
.IX Header "APPENDIX"
Methods beginning with a leading underscore are considered private and
are intended for internal use by this module. They are not considered
part of the public interface and are described here for documentation
purposes only.
.SS "new"
.IX Subsection "new"
.Vb 10
\& Title     : new
\& Function
\& Function  : Initializes the Enzyme object
\& Returns   : The Restriction::Enzyme object
\& Argument  : A standard definition can have several formats. For example:
\&             $re\->new(\-enzyme=\*(AqEcoRI\*(Aq, \-seq\->\*(AqGAATTC\*(Aq \-cut\->\*(Aq1\*(Aq)
\&             Or, you can define the cut site in the sequence, for example
\&             $re\->new(\-enzyme=\*(AqEcoRI\*(Aq, \-seq\->\*(AqG^AATTC\*(Aq), but you must use a caret
\&             Or, a sequence can cut outside the recognition site, for example
\&             $re\->new(\-enzyme=\*(AqAbeI\*(Aq, \-seq\->\*(AqCCTCAGC\*(Aq \-cut\->\*(Aq\-5/\-2\*(Aq)
\&
\&             Other arguments:
\&             \-isoschizomers=>\e@list  a reference to an array of
\&              known isoschizomers
\&             \-references=>$ref a reference to the enzyme
\&             \-source=>$source the source (person) of the enzyme
\&             \-commercial_availability=>@companies a list of companies
\&              that supply the enzyme
\&             \-methylation_site=>\e%sites a reference to hash that has
\&              the position as the key and the type of methylation
\&              as the value
\&             \-xln_sub => sub { ($self,$cut) = @_; ...; return $xln_cut },
\&              a coderef to a routine that translates the input cut value
\&              into Bio::Restriction::Enzyme coordinates
\&              ( e.g., for withrefm format, this might be
\&               \-xln_sub => sub { length( shift()\->string ) + shift } )
.Ve
.PP
A Restriction::Enzyme object manages its recognition sequence as a
Bio::PrimarySeq object.
.PP
The minimum requirement is for a name and a sequence.
.PP
This will create the restriction enzyme object, and define several
things about the sequence, such as palindromic, size, etc.
.SH "Essential methods"
.IX Header "Essential methods"
.SS "name"
.IX Subsection "name"
.Vb 6
\& Title    : name
\& Usage    : $re\->name($newval)
\& Function : Gets/Sets the restriction enzyme name
\& Example  : $re\->name(\*(AqEcoRI\*(Aq)
\& Returns  : value of name
\& Args     : newvalue (optional)
.Ve
.PP
This will also clean up the name. I have added this because some
people get confused about restriction enzyme names.  The name should
be One upper case letter, and two lower case letters (because it is
derived from the organism name, eg.  EcoRI is from E. coli). After
that it is all confused, but the numbers should be roman numbers not
numbers, therefore we'll correct those. At least this will provide
some standard, I hope.
.SS "site"
.IX Subsection "site"
.Vb 8
\& Title     : site
\& Usage     : $re\->site();
\& Function  : Gets/sets the recognition sequence for the enzyme.
\& Example   : $seq_string = $re\->site();
\& Returns   : String containing recognition sequence indicating
\&           : cleavage site as in  \*(AqG^AATTC\*(Aq.
\& Argument  : n/a
\& Throws    : n/a
.Ve
.PP
Side effect: the sequence is always converted to upper case.
.PP
The cut site can also be set by using methods cut and
complementary_cut.
.PP
This will pad out missing sequence with N's. For example the enzyme
Acc36I cuts at \s-1ACCTGC\s0(4/8). This will be returned as ACCTGCNNNN^
.PP
Note that the common notation \s-1ACCTGC\s0(4/8) means that the forward
strand cut is four nucleotides after the \s-1END\s0 of the recognition
site. The forward \fIcut()\fR in the coordinates used here in Acc36I
\&\s-1ACCTGC\s0(4/8) is at 6+4 i.e. 10.
.PP
** This is the main setable method for the recognition site.
.SS "revcom_site"
.IX Subsection "revcom_site"
.Vb 8
\& Title     : revcom_site
\& Usage     : $re\->revcom_site();
\& Function  : Gets/sets the complementary recognition sequence for the enzyme.
\& Example   : $seq_string = $re\->revcom_site();
\& Returns   : String containing recognition sequence indicating
\&           : cleavage site as in  \*(AqG^AATTC\*(Aq.
\& Argument  : none (sets on first call)
\& Throws    : n/a
.Ve
.PP
This is the same as site, except it returns the revcom site. For
palindromic enzymes these two are identical. For non-palindromic
enzymes they are not!
.PP
On set, this also handles setting the revcom_recog attribute.
.PP
See also site above.
.SS "cut"
.IX Subsection "cut"
.Vb 5
\& Title     : cut
\& Usage     : $num = $re\->cut(1);
\& Function  : Sets/gets an integer indicating the position of cleavage
\&             relative to the 5\*(Aq end of the recognition sequence in the
\&             forward strand.
\&
\&             For type II enzymes, sets the symmetrically positioned
\&             reverse strand cut site by calling complementary_cut().
\&
\& Returns   : Integer, 0 if not set
\& Argument  : an integer for the forward strand cut site (optional)
.Ve
.PP
Note that the common notation \s-1ACCTGC\s0(4/8) means that the forward
strand cut is four nucleotides after the \s-1END\s0 of the recognition
site. The forwad cut in the coordinates used here in Acc36I
\&\s-1ACCTGC\s0(4/8) is at 6+4 i.e. 10.
.PP
Note that \s-1REBASE\s0 uses notation where cuts within symmetic sites are
marked by '^' within the forward sequence but if the site is
asymmetric the parenthesis syntax is used where numbering \s-1ALWAYS\s0
starts from last nucleotide in the forward strand. That's why AciI has
a site usually written as \s-1CCGC\s0(\-3/\-1) actualy cuts in
.PP
.Vb 2
\&  C^C G C
\&  G G C^G
.Ve
.PP
In our notation, these locations are 1 and 3.
.PP
The cuts locations in the notation used are relative to the first
(non-N) nucleotide of the reported forward strand of the recognition
sequence. The following diagram numbers the phosphodiester bonds
(marked by + ) which can be cut by the restriction enzymes:
.PP
.Vb 3
\&                           1   2   3   4   5   6   7   8  ...
\&     N + N + N + N + N + G + A + C + T + G + G + N + N + N
\&  ... \-5  \-4  \-3  \-2  \-1
.Ve
.SS "cuts_after"
.IX Subsection "cuts_after"
.Vb 2
\& Title     : cuts_after
\& Usage     : Alias for cut()
.Ve
.SS "complementary_cut"
.IX Subsection "complementary_cut"
.Vb 7
\& Title     : complementary_cut
\& Usage     : $num = $re\->complementary_cut(\*(Aq1\*(Aq);
\& Function  : Sets/Gets an integer indicating the position of cleavage
\&           : on the reverse strand of the restriction site.
\& Returns   : Integer
\& Argument  : An integer (optional)
\& Throws    : Exception if argument is non\-numeric.
.Ve
.PP
This method determines the cut on the reverse strand of the sequence.
For most enzymes this will be within the sequence, and will be set
automatically based on the forward strand cut, but it need not be.
.PP
\&\fBNote\fR that the returned location indicates the location \s-1AFTER\s0 the
first non-N site nucleotide in the \s-1FORWARD\s0 strand.
.SH "Read only (usually) recognition site descriptive methods"
.IX Header "Read only (usually) recognition site descriptive methods"
.SS "type"
.IX Subsection "type"
.Vb 5
\& Title     : type
\& Usage     : $re\->type();
\& Function  : Get/set the restriction system type
\& Returns   : 
\& Argument  : optional type: (\*(AqI\*(Aq|II|III)
.Ve
.PP
Restriction enzymes have been catezorized into three types. Some
\&\s-1REBASE\s0 formats give the type, but the following rules can be used to
classify the known enzymes:
.IP "1." 4
Bipartite site (with 6\-8 Ns in the middle and the cut site
is > 50 nt away) => type I
.IP "2." 4
Site length < 3  => type I
.IP "3." 4
5\-6 asymmetric site and cuts >20 nt away => type \s-1III\s0
.IP "4." 4
All other  => type \s-1II\s0
.PP
There are some enzymes in \s-1REBASE\s0 which have bipartite recognition site
and cat far from the site but are still classified as type I. I've no
idea if this is really so.
.SS "seq"
.IX Subsection "seq"
.Vb 8
\& Title     : seq
\& Usage     : $re\->seq();
\& Function  : Get the Bio::PrimarySeq.pm object representing
\&           : the recognition sequence
\& Returns   : A Bio::PrimarySeq object representing the
\&             enzyme recognition site
\& Argument  : n/a
\& Throws    : n/a
.Ve
.SS "string"
.IX Subsection "string"
.Vb 7
\& Title     : string
\& Usage     : $re\->string();
\& Function  : Get a string representing the recognition sequence.
\& Returns   : String. Does NOT contain a  \*(Aq^\*(Aq representing the cut location
\&             as returned by the site() method.
\& Argument  : n/a
\& Throws    : n/a
.Ve
.SS "recog"
.IX Subsection "recog"
.Vb 9
\& Title   : recog
\& Usage   : $enz\->recog($recognition_sequence)
\& Function: Gets/sets the pure recognition site. Sets as 
\&           regexp if appropriate.
\&           As for string(), the cut indicating carets (^)
\&           are expunged.
\& Example : 
\& Returns : value of recog (a scalar)
\& Args    : on set, new value (a scalar or undef, optional)
.Ve
.SS "revcom_recog"
.IX Subsection "revcom_recog"
.Vb 8
\& Title   : revcom_recog
\& Usage   : $enz\->revcom_recog($recognition_sequence)
\& Function: Gets/sets the pure reverse\-complemented recognition site.
\&           Sets as regexp if appropriate.
\&           As for string(), the cut indicating carets (^) are expunged.
\& Example : 
\& Returns : value of recog (a scalar)
\& Args    : on set, new value (a scalar or undef, optional)
.Ve
.SS "revcom"
.IX Subsection "revcom"
.Vb 7
\& Title     : revcom
\& Usage     : $re\->revcom();
\& Function  : Get a string representing the reverse complement of
\&           : the recognition sequence.
\& Returns   : String
\& Argument  : n/a
\& Throws    : n/a
.Ve
.SS "recognition_length"
.IX Subsection "recognition_length"
.Vb 7
\& Title     : recognition_length
\& Usage     : $re\->recognition_length();
\& Function  : Get the length of the RECOGNITION sequence.
\&             This is the total recognition sequence,
\&             inluding the ambiguous codes.
\& Returns   : An integer
\& Argument  : Nothing
.Ve
.PP
See also: non_ambiguous_length
.SS "cutter"
.IX Subsection "cutter"
.Vb 3
\& Title    : cutter
\& Usage    : $re\->cutter
\& Function : Returns the "cutter" value of the recognition site.
\&
\&            This is a value relative to site length and lack of
\&            ambiguity codes. Hence: \*(AqRCATGY\*(Aq is a five (5) cutter site
\&            and \*(AqCCTNAGG\*(Aq a six cutter
\&
\&            This measure correlates to the frequency of the enzyme
\&            cuts much better than plain recognition site length.
\&
\& Example  : $re\->cutter
\& Returns  : integer or float number
\& Args     : none
.Ve
.PP
Why is this better than just stripping the ambiguos codes? Think about
it like this: You have a random sequence; all nucleotides are equally
probable. You have a four nucleotide re site. The probability of that
site finding a match is one out of 4^4 or 256, meaning that on average
a four cutter finds a match every 256 nucleotides. For a six cutter,
the average fragment length is 4^6 or 4096. In the case of ambiguity
codes the chances are finding the match are better: an R (A|T) has 1/2
chance of finding a match in a random sequence. Therefore, for \s-1RGCGCY\s0
the probability is one out of (2*4*4*4*4*2) which exactly the same as
for a five cutter! Cutter, although it can have non-integer values
turns out to be a useful and simple measure.
.PP
From bug 2178: \s-1VHDB\s0 are ambiguity symbols that match three different
nucleotides, so they contribute less to the effective recognition sequence
length than e.g. Y which matches only two nucleotides. A symbol which matches n
of the 4 nucleotides has an effective length of 1 \- log(n) / \fIlog\fR\|(4).
.SS "is_palindromic"
.IX Subsection "is_palindromic"
.Vb 8
\& Title     : is_palindromic
\& Alias     : palindromic
\& Usage     : $re\->is_palindromic();
\& Function  : Determines if the recognition sequence is palindromic
\&           : for the current restriction enzyme.
\& Returns   : Boolean
\& Argument  : n/a
\& Throws    : n/a
.Ve
.PP
A palindromic site (EcoRI):
.PP
.Vb 2
\&  5\-GAATTC\-3
\&  3\-CTTAAG\-5
.Ve
.SS "is_symmetric"
.IX Subsection "is_symmetric"
.Vb 6
\& Title     : is_symmetric
\& Alias     : symmetric
\& Usage     : $re\->is_symmetric();
\& Function  : Determines if the enzyme is a symmetric cutter
\& Returns   : Boolean
\& Argument  : none
.Ve
.PP
A symmetric but non-palindromic site (HindI):
       v     
  5\-C A C\-3
  3\-G T G\-5
     ^
.SS "overhang"
.IX Subsection "overhang"
.Vb 6
\& Title     : overhang
\& Usage     : $re\->overhang();
\& Function  : Determines the overhang of the restriction enzyme
\& Returns   : "5\*(Aq", "3\*(Aq", "blunt" of undef
\& Argument  : n/a
\& Throws    : n/a
.Ve
.PP
A blunt site in SmaI returns \f(CW\*(C`blunt\*(C'\fR
.PP
.Vb 2
\&  5\*(Aq C C C^G G G 3\*(Aq
\&  3\*(Aq G G G^C C C 5\*(Aq
.Ve
.PP
A 5' overhang in EcoRI returns \f(CW\*(C`5\*(Aq\*(C'\fR
.PP
.Vb 2
\&  5\*(Aq G^A A T T C 3\*(Aq
\&  3\*(Aq C T T A A^G 5\*(Aq
.Ve
.PP
A 3' overhang in KpnI returns \f(CW\*(C`3\*(Aq\*(C'\fR
.PP
.Vb 2
\&  5\*(Aq G G T A C^C 3\*(Aq
\&  3\*(Aq C^C A T G G 5\*(Aq
.Ve
.SS "overhang_seq"
.IX Subsection "overhang_seq"
.Vb 6
\& Title     : overhang_seq
\& Usage     : $re\->overhang_seq();
\& Function  : Determines the overhang sequence of the restriction enzyme
\& Returns   : a Bio::LocatableSeq
\& Argument  : n/a
\& Throws    : n/a
.Ve
.PP
I do not think it is necessary to create a seq object of these. (Heikki)
.PP
Note: returns empty string for blunt sequences and undef for ones that
we don't know.  Compare these:
.PP
A blunt site in SmaI returns empty string
.PP
.Vb 2
\&  5\*(Aq C C C^G G G 3\*(Aq
\&  3\*(Aq G G G^C C C 5\*(Aq
.Ve
.PP
A 5' overhang in EcoRI returns \f(CW\*(C`AATT\*(C'\fR
.PP
.Vb 2
\&  5\*(Aq G^A A T T C 3\*(Aq
\&  3\*(Aq C T T A A^G 5\*(Aq
.Ve
.PP
A 3' overhang in KpnI returns \f(CW\*(C`GTAC\*(C'\fR
.PP
.Vb 2
\&  5\*(Aq G G T A C^C 3\*(Aq
\&  3\*(Aq C^C A T G G 5\*(Aq
.Ve
.PP
Note that you need to use method overhang to decide
whether it is a 5' or 3' overhang!!!
.PP
Note: The overhang stuff does not work if the site is asymmetric! Rethink!
.SS "compatible_ends"
.IX Subsection "compatible_ends"
.Vb 8
\& Title     : compatible_ends
\& Usage     : $re\->compatible_ends($re2);
\& Function  : Determines if the two restriction enzyme cut sites
\&              have compatible ends.
\& Returns   : 0 if not, 1 if only one pair ends match, 2 if both ends.
\& Argument  : a Bio::Restriction::Enzyme
\& Throws    : unless the argument is a Bio::Resriction::Enzyme and
\&             if there are Ns in the ovarhangs
.Ve
.PP
In case of type \s-1II\s0 enzymes which which cut symmetrically, this
function can be considered to return a boolean value.
.SS "is_ambiguous"
.IX Subsection "is_ambiguous"
.Vb 6
\& Title     : is_ambiguous
\& Usage     : $re\->is_ambiguous();
\& Function  : Determines if the restriction enzyme contains ambiguous sequences
\& Returns   : Boolean
\& Argument  : n/a
\& Throws    : n/a
.Ve
.SS "Additional methods from Rebase"
.IX Subsection "Additional methods from Rebase"
.SS "is_prototype"
.IX Subsection "is_prototype"
.Vb 6
\& Title    : is_prototype
\& Usage    : $re\->is_prototype
\& Function : Get/Set method for finding out if this enzyme is a prototype
\& Example  : $re\->is_prototype(1)
\& Returns  : Boolean
\& Args     : none
.Ve
.PP
Prototype enzymes are the most commonly available and usually first
enzymes discoverd that have the same recognition site. Using only
prototype enzymes in restriction analysis avoids redundancy and
speeds things up.
.SS "is_neoschizomer"
.IX Subsection "is_neoschizomer"
.Vb 6
\& Title    : is_neoschizomer
\& Usage    : $re\->is_neoschizomer
\& Function : Get/Set method for finding out if this enzyme is a neoschizomer
\& Example  : $re\->is_neoschizomer(1)
\& Returns  : Boolean
\& Args     : none
.Ve
.PP
Neoschizomers are distinguishable from the prototype enzyme by having a
different cleavage pattern. Note that not all formats report this
.SS "prototype_name"
.IX Subsection "prototype_name"
.Vb 8
\& Title    : prototype_name
\& Alias    : prototype
\& Usage    : $re\->prototype_name
\& Function : Get/Set method for the name of prototype for
\&            this enzyme\*(Aqs recognition site
\& Example  : $re\->prototype_name(1)
\& Returns  : prototype enzyme name string or an empty string
\& Args     : optional prototype enzyme name string
.Ve
.PP
If the enzyme itself is the prototype, its own name is returned.  Not to
confuse the negative result with an unset value, use method
is_prototype.
.PP
This method is called \fIprototype_name\fR rather than \fIprototype\fR,
because it returns a string rather than on object.
.SS "isoschizomers"
.IX Subsection "isoschizomers"
.Vb 9
\& Title     : isoschizomers
\& Alias     : isos
\& Usage     : $re\->isoschizomers(@list);
\& Function  : Gets/Sets a list of known isoschizomers (enzymes that
\&             recognize the same site, but don\*(Aqt necessarily cut at
\&             the same position).
\& Arguments : A reference to an array that contains the isoschizomers
\& Returns   : A reference to an array of the known isoschizomers or 0
\&             if not defined.
.Ve
.PP
This has to be the hardest name to spell, so now you can use the alias
\&'isos'.  Added for compatibility to \s-1REBASE\s0
.SS "purge_isoschizomers"
.IX Subsection "purge_isoschizomers"
.Vb 6
\& Title     : purge_isoschizomers
\& Alias     : purge_isos
\& Usage     : $re\->purge_isoschizomers();
\& Function  : Purges the set of isoschizomers for this enzyme
\& Arguments : 
\& Returns   : 1
.Ve
.SS "methylation_sites"
.IX Subsection "methylation_sites"
.Vb 7
\& Title     : methylation_sites
\& Usage     : $re\->methylation_sites(\e%sites);
\& Function  : Gets/Sets known methylation sites (positions on the sequence
\&             that get modified to promote or prevent cleavage).
\& Arguments : A reference to a hash that contains the methylation sites
\& Returns   : A reference to a hash of the methylation sites or
\&             an empty string if not defined.
.Ve
.PP
There are three types of methylation sites:
.IP "\(bu" 3
(6) = N6\-methyladenosine
.IP "\(bu" 3
(5) = 5\-methylcytosine
.IP "\(bu" 3
(4) = N4\-methylcytosine
.PP
These are stored as 6, 5, and 4 respectively.  The hash has the
sequence position as the key and the type of methylation as the value.
A negative number in the sequence position indicates that the \s-1DNA\s0 is
methylated on the complementary strand.
.PP
Note that in \s-1REBASE\s0, the methylation positions are given 
Added for compatibility to \s-1REBASE\s0.
.SS "purge_methylation_sites"
.IX Subsection "purge_methylation_sites"
.Vb 5
\& Title     : purge_methylation_sites
\& Usage     : $re\->purge_methylation_sites();
\& Function  : Purges the set of methylation_sites for this enzyme
\& Arguments : 
\& Returns   :
.Ve
.SS "microbe"
.IX Subsection "microbe"
.Vb 5
\& Title     : microbe
\& Usage     : $re\->microbe($microbe);
\& Function  : Gets/Sets microorganism where the restriction enzyme was found
\& Arguments : A scalar containing the microbes name
\& Returns   : A scalar containing the microbes name or 0 if not defined
.Ve
.PP
Added for compatibility to \s-1REBASE\s0
.SS "source"
.IX Subsection "source"
.Vb 5
\& Title     : source
\& Usage     : $re\->source(\*(AqRob Edwards\*(Aq);
\& Function  : Gets/Sets the person who provided the enzyme
\& Arguments : A scalar containing the persons name
\& Returns   : A scalar containing the persons name or 0 if not defined
.Ve
.PP
Added for compatibility to \s-1REBASE\s0
.SS "vendors"
.IX Subsection "vendors"
.Vb 8
\& Title     : vendors
\& Usage     : $re\->vendor(@list_of_companies);
\& Function  : Gets/Sets the a list of companies that you can get the enzyme from.
\&             Also sets the commercially_available boolean
\& Arguments : A reference to an array containing the names of companies
\&             that you can get the enzyme from
\& Returns   : A reference to an array containing the names of companies
\&             that you can get the enzyme from
.Ve
.PP
Added for compatibility to \s-1REBASE\s0
.SS "purge_vendors"
.IX Subsection "purge_vendors"
.Vb 5
\& Title     : purge_vendors
\& Usage     : $re\->purge_references();
\& Function  : Purges the set of references for this enzyme
\& Arguments : 
\& Returns   :
.Ve
.SS "vendor"
.IX Subsection "vendor"
.Vb 8
\& Title     : vendor
\& Usage     : $re\->vendor(@list_of_companies);
\& Function  : Gets/Sets the a list of companies that you can get the enzyme from.
\&             Also sets the commercially_available boolean
\& Arguments : A reference to an array containing the names of companies
\&             that you can get the enzyme from
\& Returns   : A reference to an array containing the names of companies
\&             that you can get the enzyme from
.Ve
.PP
Added for compatibility to \s-1REBASE\s0
.SS "references"
.IX Subsection "references"
.Vb 5
\& Title     : references
\& Usage     : $re\->references(string);
\& Function  : Gets/Sets the references for this enzyme
\& Arguments : an array of string reference(s) (optional)
\& Returns   : an array of references
.Ve
.PP
Use purge_references to reset the list of references
.PP
This should be a Bio::Biblio object, but its not (yet)
.SS "purge_references"
.IX Subsection "purge_references"
.Vb 5
\& Title     : purge_references
\& Usage     : $re\->purge_references();
\& Function  : Purges the set of references for this enzyme
\& Arguments : 
\& Returns   : 1
.Ve
.SS "clone"
.IX Subsection "clone"
.Vb 5
\& Title     : clone
\& Usage     : $re\->clone
\& Function  : Deep copy of the object
\& Arguments : \-
\& Returns   : new Bio::Restriction::EnzymeI object
.Ve
.PP
This works as long as the object is a clean in-memory object using
scalars, arrays and hashes. You have been warned.
.PP
If you have module Storable, it is used, otherwise local code is used.
Todo: local code cuts circular references.
.SS "_expand"
.IX Subsection "_expand"
.Vb 4
\& Title     : _expand
\& Function  : Expand nucleotide ambiguity codes to their representative letters
\& Returns   : The full length string
\& Arguments : The string to be expanded.
.Ve
.PP
Stolen from the original RestrictionEnzyme.pm
