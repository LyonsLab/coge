.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Restriction::EnzymeCollection 3"
.TH Bio::Restriction::EnzymeCollection 3 "2013-05-09" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::Restriction::EnzymeCollection \- Set of restriction endonucleases
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Bio::Restriction::EnzymeCollection;
\&
\&  # Create a collection with the default enzymes.
\&  my $default_collection = Bio::Restriction::EnzymeCollection\->new();
\&
\&  # Or create a collection from a REBASE \*(Aqwithrefm\*(Aq file obtained from
\&  # ftp://ftp.neb.com/pub/rebase/. (See Bio::Restriction::IO for more
\&  # information.)
\&  my $rebase = Bio::Restriction::IO\->new(
\&      \-file   => \*(Aqwithrefm.610\*(Aq,
\&      \-format => \*(Aqwithrefm\*(Aq );
\&  my $rebase_collection = $rebase\->read();
\&
\&  # Or create an empty collection and set the enzymes later. See
\&  # \*(AqCUSTOM COLLECTIONS\*(Aq below for more information.
\&  my $empty_collection =
\&    Bio::Restriction::EnzymeCollection\->new( \-empty => 1 );
\&
\&  # Get an array of Bio::Restriction::Enzyme objects from the collection.
\&  my @enzymes = $default_collection\->each_enzyme();
\&
\&  # Get a Bio::Restriction::Enzyme object for a particular enzyme by name.
\&  my $enz = $default_collection\->get_enzyme( \*(AqEcoRI\*(Aq );
\&
\&  # Get a Bio::Restriction::EnzymeCollection object containing the enzymes
\&  # that have the equivalent of 6\-bp recognition sequences.
\&  my $six_cutters = $default_collection\->cutters( 6 );
\&
\&  # Get a Bio::Restriction::EnzymeCollection object containing the enzymes
\&  # that are rare cutters.
\&  my $rare_cutters = $default_collection\->cutters( \-start => 6, \-end => 8 );
\&
\&  # Get a Bio::Restriction::EnzymeCollection object that contains enzymes
\&  # that generate blunt ends:
\&  my $blunt_cutters = $default_collection\->blunt_enzymes();
\&
\&  # See \*(AqCUSTOM COLLECTIONS\*(Aq below for an example of creating a
\&  # Bio::Restriction::EnzymeCollection object with a specified subset of
\&  # enzymes using methods provided by the Bio::RestrictionEnzyme class.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Bio::Restriction::EnzymeCollection represents a collection of
restriction enzymes.
.PP
If you create a new collection directly rather than from a \s-1REBASE\s0
file using Bio::Restriction::IO, it will be populated by a
default set of enzymes with site and cut information
only.
.PP
Use Bio::Restriction::Analysis to figure out which enzymes are
available and where they cut your sequence.
.SH "CUSTOM COLLECTIONS"
.IX Header "CUSTOM COLLECTIONS"
Note that the underlying Bio::Restriction::Enzyme objects have a rich
variety of methods that allow more complicated selections than the methods
that are defined by Bio::Restriction::EnzymeCollection.
.PP
For example, the way to create a custom collection of Type \s-1II\s0 enzymes
is as follows:
.PP
.Vb 6
\&  my $complete_collection =
\&      Bio::Restriction::EnzymeCollection\->new();
\&  my $type_ii_collection  =
\&      Bio::Restriction::EnzymeCollection\->new( \-empty => 1 );
\&  $type_ii_collection\->enzymes(
\&      grep { $_\->type() eq \*(AqII\*(Aq } $complete_collection\->each_enzyme() );
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Bio::Restriction::IO \- read in enzymes from \s-1REBASE\s0 files
.PP
Bio::Restriction::Analysis \- figure out what enzymes cut a sequence
.PP
Bio::Restriction::Enzyme \- define a single restriction enzyme
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists. Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution. Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  https://redmine.open\-bio.org/projects/bioperl/
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Rob Edwards, redwards@utmem.edu
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Heikki Lehvaslaiho, heikki-at-bioperl-dot-org
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2003 Rob Edwards.
.PP
Some of this work is Copyright (c) 1997\-2002 Steve A. Chervitz. All
Rights Reserved.
.PP
This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
.SH "APPENDIX"
.IX Header "APPENDIX"
Methods beginning with a leading underscore are considered private and
are intended for internal use by this module. They are not considered
part of the public interface and are described here for documentation
purposes only.
.SS "new"
.IX Subsection "new"
.Vb 4
\& Title     : new
\& Function  : Initializes the Restriction::EnzymeCollection object
\& Returns   : The Restriction::EnzymeCollection object
\& Arguments : optional named parameter \-empty
.Ve
.PP
Set parameter \-empty to true if you do \s-1NOT\s0 want the collection be
populated by the default set of prototype type \s-1II\s0 enzymes.
.PP
Alternatively, pass an array of enzymes to \-enzymes parameter.
.SS "Manipulate the enzymes within the collection"
.IX Subsection "Manipulate the enzymes within the collection"
.SS "enzymes"
.IX Subsection "enzymes"
.Vb 5
\& Title     : enzyme
\& Function  : add/get method for enzymes and enzyme collections
\& Returns   : object itself
\& Arguments : array of Bio::Restriction::Enzyme and
\&             Bio::Restriction::EnzymeCollection objects
.Ve
.SS "each_enzyme"
.IX Subsection "each_enzyme"
.Vb 4
\& Title     : each_enzyme
\& Function  : get an array of enzymes
\& Returns   : array of Bio::Restriction::Enzyme objects
\& Arguments : \-
.Ve
.SS "get_enzyme"
.IX Subsection "get_enzyme"
.Vb 4
\& Title     : get_enzyme
\& Function  : Gets a Bio::Restriction::Enzyme object for the enzyme name
\& Returns   : A Bio::Restriction::Enzyme object or undef
\& Arguments : An enzyme name that is in the collection
.Ve
.SS "available_list"
.IX Subsection "available_list"
.Vb 7
\& Title     : available_list
\& Function  : Gets a list of all the enzymes that we know about
\& Returns   : A reference to an array with all the enzyme names
\&             that we have defined or 0 if none are defined
\& Arguments : Nothing
\& Comments  : Note, I maintain this for backwards compatibility,
\&             but I don\*(Aqt like the name as it is very ambiguous
.Ve
.SS "longest_cutter"
.IX Subsection "longest_cutter"
.Vb 6
\& Title     : longest_cutter
\& Function  : Gets the enzyme with the longest recognition site
\& Returns   : A Bio::Restriction::Enzyme object
\& Arguments : Nothing
\& Comments  : Note, this is used by Bio::Restriction::Analysis
\&             to figure out what to do with circular sequences
.Ve
.SS "Filter enzymes"
.IX Subsection "Filter enzymes"
.SS "blunt_enzymes"
.IX Subsection "blunt_enzymes"
.Vb 6
\&  Title     : blunt_enzymes
\&  Function  : Gets a list of all the enzymes that are blunt cutters
\&  Returns   : A reference to an array with all the enzyme names that
\&              are blunt cutters or 0 if none are defined
\&  Arguments : Nothing
\&  Comments  :
.Ve
.PP
This is an example of the kind of filtering better done by the scripts
using the rich collection of methods in Bio::Restriction::Enzyme.
.SS "cutters"
.IX Subsection "cutters"
.Vb 10
\&  Title     : cutters
\&  Function  : Gets a list of all the enzymes that recognize a
\&              certain size, e.g. 6\-cutters
\&  Usage     : $cutters = $collection\->cutters(6);
\&  Returns   : A reference to an array with all the enzyme names
\&              that are x cutters or 0 if none are defined
\&  Arguments : A positive number for the size of cutters to return
\&              OR
\&              A range: (\-start => 6, \-end => 8,
\&                        \-inclusive => 1, \-exclusive = 0 )
.Ve
.PP
The default for a range is 'inclusive'
