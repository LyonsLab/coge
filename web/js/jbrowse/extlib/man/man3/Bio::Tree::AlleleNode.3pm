.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Tree::AlleleNode 3"
.TH Bio::Tree::AlleleNode 3 "2013-05-09" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::Tree::AlleleNode \- A Node with Alleles attached
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Bio::Tree::AlleleNode;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
AlleleNodes are basic Bio::Tree::Nodes with the added ability to
add Genotypes alleles as defined by the Bio::PopGen::IndividualI
interface.  Genotypes are defined by the Bio::PopGen::GenotypeI
interface, you will probably want to use the Bio::PopGen::Genotype
implementation.
.PP
This is implemented via containment to avoid multiple inheritance
problems.  Their is a Bio::PopGen::Individual object which handles
the Bio::PopGen::IndividualI interface, and is accessible via the
Bio::Tree::AlleleNode::individual method.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to
the Bioperl mailing list.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
of the bugs and their resolution. Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  https://redmine.open\-bio.org/projects/bioperl/
.Ve
.SH "AUTHOR \- Jason Stajich"
.IX Header "AUTHOR - Jason Stajich"
Email jason-at-bioperl-dot-org
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _
.SH "HISTORY"
.IX Header "HISTORY"
This module was re-written to be a combination of
Bio::PopGen::Individual and Bio::Tree::Node primarily for use in
Bio::PopGen::Simulation::Coalescent simulations.
.SS "new"
.IX Subsection "new"
.Vb 10
\& Title   : new
\& Usage   : my $obj = Bio::Tree::AlleleNode\->new();
\& Function: Builds a new Bio::Tree::AlleleNode() object 
\& Returns : an instance of Bio::Tree::AlleleNode
\& Args    : \-unique_id     => $id,
\&           \-genotypes     => \e@genotypes
\&           \-left          => pointer to Left descendent (optional)
\&           \-right         => pointer to Right descenent (optional)
\&           \-branch_length => branch length [integer] (optional)
\&           \-bootstrap     => value   bootstrap value (string)
\&           \-description   => description of node
\&           \-id            => human readable (unique) id for node
\&                             Should NOT contain the characters 
\&                             \*(Aq();:\*(Aq
.Ve
.SS "individual"
.IX Subsection "individual"
.Vb 5
\& Title   : individual
\& Usage   : $obj\->individual($newval)
\& Function: Get/Set Access to the underlying individual object
\& Returns : L<Bio::PopGen::Individual> object
\& Args    : on set, new value (L<Bio::PopGen::Individual>)
.Ve
.SS "Bio::PopGen::Individual methods"
.IX Subsection "Bio::PopGen::Individual methods"
Methods required by Bio::PopGen::IndividualI.
.SS "unique_id"
.IX Subsection "unique_id"
.Vb 5
\& Title   : unique_id
\& Usage   : my $id = $individual\->unique_id
\& Function: Unique Identifier
\& Returns : string representing unique identifier
\& Args    : string
.Ve
.SS "num_of_results"
.IX Subsection "num_of_results"
.Vb 5
\& Title   : num_of_results
\& Usage   : my $count = $person\->num_results;
\& Function: returns the count of the number of Results for a person
\& Returns : integer
\& Args    : none
.Ve
.SS "add_Genotype"
.IX Subsection "add_Genotype"
.Vb 7
\& Title   : add_Genotype
\& Usage   : $individual\->add_Genotype
\& Function: add a genotype value, only a single genotype
\&           may be associated 
\& Returns : count of the number of genotypes associated with this individual
\& Args    : @genotypes \- Bio::PopGen::GenotypeI object(s) containing 
\&                        alleles plus a marker name
.Ve
.SS "reset_Genotypes"
.IX Subsection "reset_Genotypes"
.Vb 5
\& Title   : reset_Genotypes
\& Usage   : $individual\->reset_Genotypes;
\& Function: Reset the genotypes stored for this individual
\& Returns : none
\& Args    : none
.Ve
.SS "remove_Genotype"
.IX Subsection "remove_Genotype"
.Vb 5
\& Title   : remove_Genotype
\& Usage   : $individual\->remove_Genotype(@names)
\& Function: Removes the genotypes for the requested markers
\& Returns : none
\& Args    : Names of markers
.Ve
.SS "get_Genotypes"
.IX Subsection "get_Genotypes"
.Vb 6
\& Title   : get_Genotypes
\& Usage   : my @genotypes = $ind\->get_Genotypes(\-marker => $markername);
\& Function: Get the genotypes for an individual, based on a criteria
\& Returns : Array of genotypes
\& Args    : either none (return all genotypes) or 
\&           \-marker => name of marker to return (exact match, case matters)
.Ve
.SS "has_Marker"
.IX Subsection "has_Marker"
.Vb 6
\& Title   : has_Marker
\& Usage   : if( $ind\->has_Marker($name) ) {}
\& Function: Boolean test to see if an Individual has a genotype 
\&           for a specific marker
\& Returns : Boolean (true or false)
\& Args    : String representing a marker name
.Ve
.SS "get_marker_names"
.IX Subsection "get_marker_names"
.Vb 5
\& Title   : get_marker_names
\& Usage   : my @names = $individual\->get_marker_names;
\& Function: Returns the list of known marker names
\& Returns : List of strings
\& Args    : none
.Ve
.SS "Bio::Tree::Node methods"
.IX Subsection "Bio::Tree::Node methods"
Methods inherited from Bio::Tree::Node.
.SS "add_Descendent"
.IX Subsection "add_Descendent"
.Vb 9
\& Title   : add_Descendent
\& Usage   : $node\->add_Descendent($node);
\& Function: Adds a descendent to a node
\& Returns : number of current descendents for this node
\& Args    : Bio::Node::NodeI
\&           boolean flag, true if you want to ignore the fact that you are
\&           adding a second node with the same unique id (typically memory 
\&           location reference in this implementation).  default is false and 
\&           will throw an error if you try and overwrite an existing node.
.Ve
.SS "each_Descendent"
.IX Subsection "each_Descendent"
.Vb 7
\& Title   : each_Descendent($sortby)
\& Usage   : my @nodes = $node\->each_Descendent;
\& Function: all the descendents for this Node (but not their descendents
\&                                              i.e. not a recursive fetchall)
\& Returns : Array of Bio::Tree::NodeI objects
\& Args    : $sortby [optional] "height", "creation" or coderef to be used
\&           to sort the order of children nodes.
.Ve
.SS "remove_Descendent"
.IX Subsection "remove_Descendent"
.Vb 6
\& Title   : remove_Descendent
\& Usage   : $node\->remove_Descedent($node_foo);
\& Function: Removes a specific node from being a Descendent of this node
\& Returns : nothing
\& Args    : An array of Bio::Node::NodeI objects which have be previously
\&           passed to the add_Descendent call of this object.
.Ve
.SS "remove_all_Descendents"
.IX Subsection "remove_all_Descendents"
.Vb 8
\& Title   : remove_all_Descendents
\& Usage   : $node\->remove_All_Descendents()
\& Function: Cleanup the node\*(Aqs reference to descendents and reset
\&           their ancestor pointers to undef, if you don\*(Aqt have a reference
\&           to these objects after this call they will be cleaned up \- so
\&           a get_nodes from the Tree object would be a safe thing to do first
\& Returns : nothing
\& Args    : none
.Ve
.SS "get_all_Descendents"
.IX Subsection "get_all_Descendents"
.Vb 6
\& Title   : get_all_Descendents
\& Usage   : my @nodes = $node\->get_all_Descendents;
\& Function: Recursively fetch all the nodes and their descendents
\&           *NOTE* This is different from each_Descendent
\& Returns : Array or Bio::Tree::NodeI objects
\& Args    : none
.Ve
.SS "ancestor"
.IX Subsection "ancestor"
.Vb 5
\& Title   : ancestor
\& Usage   : $obj\->ancestor($newval)
\& Function: Set the Ancestor
\& Returns : value of ancestor
\& Args    : newvalue (optional)
.Ve
.SS "branch_length"
.IX Subsection "branch_length"
.Vb 5
\& Title   : branch_length
\& Usage   : $obj\->branch_length()
\& Function: Get/Set the branch length
\& Returns : value of branch_length
\& Args    : newvalue (optional)
.Ve
.SS "bootstrap"
.IX Subsection "bootstrap"
.Vb 5
\& Title   : bootstrap
\& Usage   : $obj\->bootstrap($newval)
\& Function: Get/Set the bootstrap value
\& Returns : value of bootstrap
\& Args    : newvalue (optional)
.Ve
.SS "description"
.IX Subsection "description"
.Vb 5
\& Title   : description
\& Usage   : $obj\->description($newval)
\& Function: Get/Set the description string
\& Returns : value of description
\& Args    : newvalue (optional)
.Ve
.SS "id"
.IX Subsection "id"
.Vb 6
\& Title   : id
\& Usage   : $obj\->id($newval)
\& Function: The human readable identifier for the node 
\& Returns : value of human readable id
\& Args    : newvalue (optional)
\& Note    : id cannot contain the chracters \*(Aq();:\*(Aq
.Ve
.PP
\&\*(L"A name can be any string of printable characters except blanks,
colons, semicolons, parentheses, and square brackets. Because you may
want to include a blank in a name, it is assumed that an underscore
character (\*(R"_\*(L") stands for a blank; any of these in a name will be
converted to a blank when it is read in.\*(R"
.PP
from <http://evolution.genetics.washington.edu/phylip/newicktree.html>
.SS "internal_id"
.IX Subsection "internal_id"
.Vb 8
\& Title   : internal_id
\& Usage   : my $internalid = $node\->internal_id
\& Function: Returns the internal unique id for this Node
\&           (a monotonically increasing number for this in\-memory implementation
\&            but could be a database determined unique id in other 
\&            implementations)
\& Returns : unique id
\& Args    : none
.Ve
.SS "Bio::Node::NodeI decorated interface implemented"
.IX Subsection "Bio::Node::NodeI decorated interface implemented"
The following methods are implemented by Bio::Node::NodeI decorated
interface.
.SS "is_Leaf"
.IX Subsection "is_Leaf"
.Vb 5
\& Title   : is_Leaf
\& Usage   : if( $node\->is_Leaf )
\& Function: Get Leaf status
\& Returns : boolean
\& Args    : none
.Ve
.SS "to_string"
.IX Subsection "to_string"
.Vb 5
\& Title   : to_string
\& Usage   : my $str = $node\->to_string()
\& Function: For debugging, provide a node as a string
\& Returns : string
\& Args    : none
.Ve
.SS "height"
.IX Subsection "height"
.Vb 6
\& Title   : height
\& Usage   : my $len = $node\->height
\& Function: Returns the height of the tree starting at this
\&           node.  Height is the maximum branchlength.
\& Returns : The longest length (weighting branches with branch_length) to a leaf
\& Args    : none
.Ve
.SS "invalidate_height"
.IX Subsection "invalidate_height"
.Vb 5
\& Title   : invalidate_height
\& Usage   : private helper method
\& Function: Invalidate our cached value of the node\*(Aqs height in the tree
\& Returns : nothing
\& Args    : none
.Ve
.SS "add_tag_value"
.IX Subsection "add_tag_value"
.Vb 6
\& Title   : add_tag_value
\& Usage   : $node\->add_tag_value($tag,$value)
\& Function: Adds a tag value to a node 
\& Returns : number of values stored for this tag
\& Args    : $tag   \- tag name
\&           $value \- value to store for the tag
.Ve
.SS "remove_tag"
.IX Subsection "remove_tag"
.Vb 5
\& Title   : remove_tag
\& Usage   : $node\->remove_tag($tag)
\& Function: Remove the tag and all values for this tag
\& Returns : boolean representing success (0 if tag does not exist)
\& Args    : $tag \- tagname to remove
.Ve
.SS "remove_all_tags"
.IX Subsection "remove_all_tags"
.Vb 5
\& Title   : remove_all_tags
\& Usage   : $node\->remove_all_tags()
\& Function: Removes all tags 
\& Returns : None
\& Args    : None
.Ve
.SS "get_all_tags"
.IX Subsection "get_all_tags"
.Vb 5
\& Title   : get_all_tags
\& Usage   : my @tags = $node\->get_all_tags()
\& Function: Gets all the tag names for this Node
\& Returns : Array of tagnames
\& Args    : None
.Ve
.SS "get_tag_values"
.IX Subsection "get_tag_values"
.Vb 5
\& Title   : get_tag_values
\& Usage   : my @values = $node\->get_tag_value($tag)
\& Function: Gets the values for given tag ($tag)
\& Returns : Array of values or empty list if tag does not exist
\& Args    : $tag \- tag name
.Ve
.SS "has_tag"
.IX Subsection "has_tag"
.Vb 5
\& Title   : has_tag
\& Usage   : $node\->has_tag($tag)
\& Function: Boolean test if tag exists in the Node
\& Returns : Boolean
\& Args    : $tag \- tagname
.Ve
