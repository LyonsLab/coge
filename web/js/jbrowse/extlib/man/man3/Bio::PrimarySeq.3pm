.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::PrimarySeq 3"
.TH Bio::PrimarySeq 3 "2013-05-09" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::PrimarySeq \- Bioperl lightweight Sequence Object
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  # Bio::SeqIO for file reading, Bio::DB::GenBank for
\&  # database reading
\&
\&  use Bio::Seq;
\&  use Bio::SeqIO;
\&  use Bio::DB::GenBank;
\&
\&  # make from memory
\&
\&  $seqobj = Bio::PrimarySeq\->new ( \-seq => \*(AqATGGGGTGGGCGGTGGGTGGTTTG\*(Aq,
\&                                   \-id  => \*(AqGeneFragment\-12\*(Aq,
\&                                   \-accession_number => \*(AqX78121\*(Aq,
\&                                   \-alphabet => \*(Aqdna\*(Aq,
\&                                   \-is_circular => 1 );
\&  print "Sequence ", $seqobj\->id(), " with accession ",
\&    $seqobj\->accession_number, "\en";
\&
\&  # read from file
\&
\&  $inputstream = Bio::SeqIO\->new(\-file => "myseq.fa",
\&                                 \-format => \*(AqFasta\*(Aq);
\&  $seqobj = $inputstream\->next_seq();
\&  print "Sequence ", $seqobj\->id(), " and desc ", $seqobj\->desc, "\en";
\&
\&  # to get out parts of the sequence.
\&
\&  print "Sequence ", $seqobj\->id(), " with accession ",
\&    $seqobj\->accession_number, " and desc ", $seqobj\->desc, "\en";
\&
\&  $string  = $seqobj\->seq();
\&  $string2 = $seqobj\->subseq(1,40);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
PrimarySeq is a lightweight Sequence object, storing the sequence, its
name, a computer-useful unique name, and other fundamental attributes.
It does not contain sequence features or other information.  To have a
sequence with sequence features you should use the Seq object which uses
this object.
.PP
Although new users will use Bio::PrimarySeq a lot, in general you will
be using it from the Bio::Seq object. For more information on Bio::Seq
see Bio::Seq. For interest you might like to know that
Bio::Seq has-a Bio::PrimarySeq and forwards most of the function calls
to do with sequence to it (the has-a relationship lets us get out of a
otherwise nasty cyclical reference in Perl which would leak memory).
.PP
Sequence objects are defined by the Bio::PrimarySeqI interface, and this
object is a pure Perl implementation of the interface. If that's
gibberish to you, don't worry. The take home message is that this
object is the bioperl default sequence object, but other people can
use their own objects as sequences if they so wish. If you are
interested in wrapping your own objects as compliant Bioperl sequence
objects, then you should read the Bio::PrimarySeqI documentation
.PP
The documentation of this object is a merge of the Bio::PrimarySeq and
Bio::PrimarySeqI documentation.  This allows all the methods which you can
call on sequence objects here.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  https://redmine.open\-bio.org/projects/bioperl/
.Ve
.SH "AUTHOR \- Ewan Birney"
.IX Header "AUTHOR - Ewan Birney"
Email birney@ebi.ac.uk
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object
methods. Internal methods are usually preceded with a _
.SS "new"
.IX Subsection "new"
.Vb 5
\& Title   : new
\& Usage   : $seq    = Bio::PrimarySeq\->new( \-seq => \*(AqATGGGGGTGGTGGTACCCT\*(Aq,
\&                                           \-id  => \*(Aqhuman_id\*(Aq,
\&                                           \-accession_number => \*(AqAL000012\*(Aq,
\&                                           );
\&
\& Function: Returns a new primary seq object from
\&           basic constructors, being a string for the sequence
\&           and strings for id and accession_number.
\&
\&           Note that you can provide an empty sequence string. However, in
\&           this case you MUST specify the type of sequence you wish to
\&           initialize by the parameter \-alphabet. See alphabet() for possible
\&           values.
\& Returns : a new Bio::PrimarySeq object
\& Args    : \-seq         => sequence string
\&           \-display_id  => display id of the sequence (locus name)
\&           \-accession_number => accession number
\&           \-primary_id  => primary id (Genbank id)
\&           \-version     => version number
\&           \-namespace   => the namespace for the accession
\&           \-authority   => the authority for the namespace
\&           \-description => description text
\&           \-desc        => alias for description
\&           \-alphabet    => sequence type (alphabet) (dna|rna|protein)
\&           \-id          => alias for display id
\&           \-is_circular => boolean field for whether or not sequence is circular
\&           \-direct      => boolean field for directly setting sequence (requires alphabet also set)
\&           \-ref_to_seq  => boolean field indicating the sequence is a reference (?!?)
\&           \-nowarnonempty => boolean field for whether or not to warn when sequence is empty
.Ve
.SS "seq"
.IX Subsection "seq"
.Vb 9
\& Title   : seq
\& Usage   : $string    = $obj\->seq()
\& Function: Returns the sequence as a string of letters. The
\&           case of the letters is left up to the implementer.
\&           Suggested cases are upper case for proteins and lower case for
\&           DNA sequence (IUPAC standard), but you should not rely on this.
\& Returns : A scalar
\& Args    : Optionally on set the new value (a string). An optional second
\&           argument presets the alphabet (otherwise it will be guessed).
.Ve
.SS "validate_seq"
.IX Subsection "validate_seq"
.Vb 8
\& Title   : validate_seq
\& Usage   : if(! $seq\->validate_seq($seq_str) ) {
\&                print "sequence $seq_str is not valid for an object of
\&                alphabet ",$seq\->alphabet, "\en";
\&           }
\& Function: Validates a given sequence string. A validating sequence string
\&           must be accepted by seq(). A string that does not validate will
\&           lead to an exception if passed to seq().
\&
\&           The implementation provided here does not take alphabet() into
\&           account. Allowed are all letters (A\-Z) and \*(Aq\-\*(Aq,\*(Aq.\*(Aq,\*(Aq*\*(Aq,\*(Aq?\*(Aq,\*(Aq=\*(Aq,
\&           and \*(Aq~\*(Aq.
\&
\& Example :
\& Returns : 1 if the supplied sequence string is valid for the object, and
\&           0 otherwise.
\& Args    : The sequence string to be validated.
.Ve
.SS "subseq"
.IX Subsection "subseq"
.Vb 10
\& Title   : subseq
\& Usage   : $substring = $obj\->subseq(10,40);
\&           $substring = $obj\->subseq(10,40,NOGAP)
\&           $substring = $obj\->subseq(\-START=>10,\-END=>40,\-REPLACE_WITH=>\*(Aqtga\*(Aq)
\& Function: returns the subseq from start to end, where the first sequence
\&           character has coordinate 1 number is inclusive, ie 1\-2 are the 
\&           first two characters of the sequence
\& Returns : a string
\& Args    : integer for start position
\&           integer for end position
\&                 OR
\&           Bio::LocationI location for subseq (strand honored)
\&           Specify \-NOGAP=>1 to return subseq with gap characters removed
\&           Specify \-REPLACE_WITH=>$new_subseq to replace the subseq returned
\&           with $new_subseq in the sequence object
.Ve
.SS "length"
.IX Subsection "length"
.Vb 4
\& Title   : length
\& Usage   : $len = $seq\->length();
\& Function: Get the length of the sequence in number of symbols (bases
\&           or amino acids).
\&
\&           You can also set this attribute, even to a number that does
\&           not match the length of the sequence string. This is useful
\&           if you don\*(Aq\*(Aqt want to set the sequence too, or if you want
\&           to free up memory by unsetting the sequence. In the latter
\&           case you could do e.g.
\&
\&               $seq\->length($seq\->length);
\&               $seq\->seq(undef);
\&
\&           Note that if you set the sequence to a value other than
\&           undef at any time, the length attribute will be
\&           invalidated, and the length of the sequence string will be
\&           reported again. Also, we won\*(Aq\*(Aqt let you lie about the length.
\&
\& Example :
\& Returns : integer representing the length of the sequence.
\& Args    : Optionally, the value on set
.Ve
.SS "display_id"
.IX Subsection "display_id"
.Vb 3
\& Title   : display_id or display_name
\& Usage   : $id_string = $obj\->display_id();
\& Function: returns the display id, aka the common name of the Sequence object.
\&
\&           The semantics of this is that it is the most likely string to
\&           be used as an identifier of the sequence, and likely to have
\&           "human" readability.  The id is equivalent to the ID field of
\&           the GenBank/EMBL databanks and the id field of the
\&           Swissprot/sptrembl database. In fasta format, the >(\eS+) is
\&           presumed to be the id, though some people overload the id to
\&           embed other information. Bioperl does not use any embedded
\&           information in the ID field, and people are encouraged to use
\&           other mechanisms (accession field for example, or extending
\&           the sequence object) to solve this.
\&
\&           With the new Bio::DescribeableI interface, display_name aliases
\&           to this method.
\&
\& Returns : A string
\& Args    : None
.Ve
.SS "accession_number"
.IX Subsection "accession_number"
.Vb 8
\& Title   : accession_number or object_id
\& Usage   : $unique_key = $obj\->accession_number;
\& Function: Returns the unique biological id for a sequence, commonly
\&           called the accession_number. For sequences from established
\&           databases, the implementors should try to use the correct
\&           accession number. Notice that primary_id() provides the
\&           unique id for the implemetation, allowing multiple objects
\&           to have the same accession number in a particular implementation.
\&
\&           For sequences with no accession number, this method should
\&           return "unknown".
\&
\&           [Note this method name is likely to change in 1.3]
\&
\&           With the new Bio::IdentifiableI interface, this is aliased
\&           to object_id
\&
\& Returns : A string
\& Args    : A string (optional) for setting
.Ve
.SS "primary_id"
.IX Subsection "primary_id"
.Vb 6
\& Title   : primary_id
\& Usage   : $unique_key = $obj\->primary_id;
\& Function: Returns the unique id for this object in this
\&           implementation. This allows implementations to manage their
\&           own object ids in a way the implementaiton can control
\&           clients can expect one id to map to one object.
\&
\&           For sequences with no natural primary id, this method
\&           should return a stringified memory location.
\&
\& Returns : A string
\& Args    : A string (optional, for setting)
.Ve
.SS "alphabet"
.IX Subsection "alphabet"
.Vb 4
\& Title   : alphabet
\& Usage   : if( $obj\->alphabet eq \*(Aqdna\*(Aq ) { /Do Something/ }
\& Function: Get/Set the alphabet of sequence, one of
\&           \*(Aqdna\*(Aq, \*(Aqrna\*(Aq or \*(Aqprotein\*(Aq. This is case sensitive.
\&
\&           This is not called <type> because this would cause
\&           upgrade problems from the 0.5 and earlier Seq objects.
\&
\& Returns : a string either \*(Aqdna\*(Aq,\*(Aqrna\*(Aq,\*(Aqprotein\*(Aq. NB \- the object must
\&           make a call of the type \- if there is no alphabet specified it
\&           has to guess.
\& Args    : optional string to set : \*(Aqdna\*(Aq | \*(Aqrna\*(Aq | \*(Aqprotein\*(Aq
.Ve
.SS "desc"
.IX Subsection "desc"
.Vb 3
\& Title   : desc or description
\& Usage   : $obj\->desc($newval)
\& Function: Get/set description of the sequence.
\&
\&           \*(Aqdescription\*(Aq is an alias for this for compliance with the
\&           Bio::DescribeableI interface.
\&
\& Example :
\& Returns : value of desc (a string)
\& Args    : newvalue (a string or undef, optional)
.Ve
.SS "can_call_new"
.IX Subsection "can_call_new"
.Vb 6
\& Title   : can_call_new
\& Usage   :
\& Function:
\& Example :
\& Returns : true
\& Args    :
.Ve
.SS "id"
.IX Subsection "id"
.Vb 6
\& Title   : id
\& Usage   : $id = $seq\->id()
\& Function: This is mapped on display_id
\& Example :
\& Returns :
\& Args    :
.Ve
.SS "is_circular"
.IX Subsection "is_circular"
.Vb 5
\& Title   : is_circular
\& Usage   : if( $obj\->is_circular) { /Do Something/ }
\& Function: Returns true if the molecule is circular
\& Returns : Boolean value
\& Args    : none
.Ve
.SH "Methods for Bio::IdentifiableI compliance"
.IX Header "Methods for Bio::IdentifiableI compliance"
.SS "object_id"
.IX Subsection "object_id"
.Vb 5
\& Title   : object_id
\& Usage   : $string    = $obj\->object_id()
\& Function: A string which represents the stable primary identifier
\&           in this namespace of this object. For DNA sequences this
\&           is its accession_number, similarly for protein sequences.
\&
\&           This is aliased to accession_number().
\& Returns : A scalar
.Ve
.SS "version"
.IX Subsection "version"
.Vb 6
\& Title   : version
\& Usage   : $version    = $obj\->version()
\& Function: A number which differentiates between versions of
\&           the same object. Higher numbers are considered to be
\&           later and more relevant, but a single object described
\&           the same identifier should represent the same concept.
\&
\& Returns : A number
.Ve
.SS "authority"
.IX Subsection "authority"
.Vb 5
\& Title   : authority
\& Usage   : $authority    = $obj\->authority()
\& Function: A string which represents the organisation which
\&           granted the namespace, written as the DNS name for
\&           organisation (eg, wormbase.org).
\&
\& Returns : A scalar
.Ve
.SS "namespace"
.IX Subsection "namespace"
.Vb 5
\& Title   : namespace
\& Usage   : $string    = $obj\->namespace()
\& Function: A string representing the name space this identifier
\&           is valid in, often the database name or the name
\&           describing the collection.
\&
\& Returns : A scalar
.Ve
.SH "Methods for Bio::DescribableI compliance"
.IX Header "Methods for Bio::DescribableI compliance"
This comprises of display_name and description.
.SS "display_name"
.IX Subsection "display_name"
.Vb 7
\& Title   : display_name
\& Usage   : $string    = $obj\->display_name()
\& Function: A string which is what should be displayed to the user.
\&           The string should have no spaces (ideally, though a cautious
\&           user of this interface would not assumme this) and should be
\&           less than thirty characters (though again, double checking
\&           this is a good idea).
\&
\&           This is aliased to display_id().
\& Returns : A scalar
.Ve
.SS "description"
.IX Subsection "description"
.Vb 8
\& Title   : description
\& Usage   : $string    = $obj\->description()
\& Function: A text string suitable for displaying to the user a
\&           description. This string is likely to have spaces, but
\&           should not have any newlines or formatting \- just plain
\&           text. The string should not be greater than 255 characters
\&           and clients can feel justified at truncating strings at 255
\&           characters for the purposes of display.
\&
\&           This is aliased to desc().
\& Returns : A scalar
.Ve
.SH "Methods Inherited from Bio::PrimarySeqI"
.IX Header "Methods Inherited from Bio::PrimarySeqI"
These methods are available on Bio::PrimarySeq, although they are
actually implemented on Bio::PrimarySeqI
.SS "revcom"
.IX Subsection "revcom"
.Vb 6
\& Title   : revcom
\& Usage   : $rev = $seq\->revcom()
\& Function: Produces a new Bio::SeqI implementing object which
\&           is the reversed complement of the sequence. For protein
\&           sequences this throws an exception of
\&           "Sequence is a protein. Cannot revcom".
\&
\&           The id is the same id as the orginal sequence, and the
\&           accession number is also indentical. If someone wants to
\&           track that this sequence has be reversed, it needs to
\&           define its own extensions.
\&
\&           To do an inplace edit of an object you can go:
\&
\&           $seqobj = $seqobj\->revcom();
\&
\&           This of course, causes Perl to handle the garbage
\&           collection of the old object, but it is roughly speaking as
\&           efficient as an inplace edit.
\&
\& Returns : A new (fresh) Bio::SeqI object
\& Args    : none
.Ve
.SS "trunc"
.IX Subsection "trunc"
.Vb 3
\& Title   : trunc
\& Usage   : $subseq = $myseq\->trunc(10,100);
\& Function: Provides a truncation of a sequence,
\&
\& Example :
\& Returns : A fresh Bio::SeqI implementing object.
\& Args    :
.Ve
.SH "Internal methods"
.IX Header "Internal methods"
These are internal methods to PrimarySeq
.SS "_guess_alphabet"
.IX Subsection "_guess_alphabet"
.Vb 6
\& Title   : _guess_alphabet
\& Usage   :
\& Function: Automatically guess and set the type of sequence: dna, rna or protein
\& Example :
\& Returns : one of strings \*(Aqdna\*(Aq, \*(Aqrna\*(Aq or \*(Aqprotein\*(Aq.
\& Args    : none
.Ve
