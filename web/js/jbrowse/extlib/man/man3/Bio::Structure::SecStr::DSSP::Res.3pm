.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Structure::SecStr::DSSP::Res 3"
.TH Bio::Structure::SecStr::DSSP::Res 3 "2013-05-09" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::Structure::SecStr::DSSP::Res \- Module for parsing/accessing dssp output
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  my $dssp_obj = Bio::Structure::SecStr::DSSP::Res\->new(\*(Aq\-file\*(Aq=>\*(Aqfilename.dssp\*(Aq);
\&
\&  # or
\&
\&  my $dssp_obj = Bio::Structure::SecStr::DSSP::Res\->new(\*(Aq\-fh\*(Aq=>\e*STDOUT);
\&
\&  # get DSSP defined Secondary Structure for residue 20
\&  $sec_str = $dssp_obj\->resSecStr( 20 );
\&
\&  # get dssp defined sec. structure summary for PDB residue  # 10 of chain A
\&
\&  $sec_str = $dssp_obj\->resSecStrSum( \*(Aq10:A\*(Aq );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
DSSP::Res is a module for objectifying \s-1DSSP\s0 output.  Methods are then
available for extracting all the information within the output file
and convenient subsets of it.
The principal purpose of \s-1DSSP\s0 is to determine secondary structural
elements of a given structure.
.PP
.Vb 3
\&    ( Dictionary of protein secondary structure: pattern recognition
\&      of hydrogen\-bonded and geometrical features.
\&      Biopolymers. 1983 Dec;22(12):2577\-637. )
.Ve
.PP
The \s-1DSSP\s0 program is available from:
  http://www.cmbi.kun.nl/swift/dssp
.PP
This information is available on a per residue basis ( see resSecStr
and resSecStrSum methods ) or on a per chain basis ( see secBounds
method ).
.PP
\&\fIresSecStr()\fR & \fIsecBounds()\fR return one of the following:
    'H' = alpha helix
    'B' = residue in isolated beta-bridge
    'E' = extended strand, participates in beta ladder
    'G' = 3\-helix (3/10 helix)
    'I' = 5 helix (pi helix)
    'T' = hydrogen bonded turn
    'S' = bend
    ''  = no assignment
.PP
A more general classification is returned using the \fIresSecStrSum()\fR
method.  The purpose of this is to have a method for \s-1DSSP\s0 and \s-1STRIDE\s0
derived output whose range is the same.
Its output is one of the following:
.PP
.Vb 4
\&    \*(AqH\*(Aq = helix         ( => \*(AqH\*(Aq, \*(AqG\*(Aq, or \*(AqI\*(Aq from above )
\&    \*(AqB\*(Aq = beta          ( => \*(AqB\*(Aq or \*(AqE\*(Aq from above )
\&    \*(AqT\*(Aq = turn          ( => \*(AqT\*(Aq or \*(AqS\*(Aq from above )
\&    \*(Aq \*(Aq = no assignment ( => \*(Aq \*(Aq from above )
.Ve
.PP
The methods are roughly divided into 3 sections:
1.  Global features of this structure (\s-1PDB\s0 \s-1ID\s0, total surface area,
    etc.).  These methods do not require an argument.
2.  Residue specific features ( amino acid, secondary structure,
    solvent exposed surface area, etc. ).  These methods do require an
    argument.  The argument is supposed to uniquely identify a
    residue described within the structure.  It can be of any of the
    following forms:
    ('#A:B') or ( #, 'A', 'B' )
      || |
      || \- Chain \s-1ID\s0 (blank for single chain)
      |\-\-\- Insertion code for this residue.  Blank for most residues.
      |\-\-\- Numeric portion of residue \s-1ID\s0.
.PP
.Vb 5
\&    (#)
\&     |
\&     \-\-\- Numeric portion of residue ID.  If there is only one chain and
\&         it has no ID AND there is no residue with an insertion code at this
\&         number, then this can uniquely specify a residue.
\&
\&    (\*(Aq#:C\*(Aq) or ( #, \*(AqC\*(Aq )
\&      | |
\&      | \-Chain ID
\&      \-\-\-Numeric portion of residue ID.
\&
\&  If a residue is incompletely specified then the first residue that
\&  fits the arguments is returned.  For example, if 19 is the argument
\&  and there are three chains, A, B, and C with a residue whose number
\&  is 19, then 19:A will be returned (assuming its listed first).
\&
\&  Since neither DSSP nor STRIDE correctly handle alt\-loc codes, they
\&  are not supported by these modules.
.Ve
.PP
3.  Value-added methods.  Return values are not verbatem strings
    parsed from \s-1DSSP\s0 or \s-1STRIDE\s0 output.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  https://redmine.open\-bio.org/projects/bioperl/
.Ve
.SH "AUTHOR \- Ed Green"
.IX Header "AUTHOR - Ed Green"
Email ed@compbio.berkeley.edu
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each method.
Internal methods are preceded with a _
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.SS "new"
.IX Subsection "new"
.Vb 6
\& Title         : new
\& Usage         : makes new object of this class
\& Function      : Constructor
\& Example       : $dssp_obj = Bio::DSSP:Res\->new( filename or FILEHANDLE )
\& Returns       : object (ref)
\& Args          : filename ( must be proper DSSP output file )
.Ve
.SH "ACCESSORS"
.IX Header "ACCESSORS"
.SS "totSurfArea"
.IX Subsection "totSurfArea"
.Vb 6
\& Title         : totSurfArea
\& Usage         : returns total accessible surface area in square And.
\& Function      :
\& Example       : $surArea = $dssp_obj\->totSurfArea();
\& Returns       : scalar
\& Args          : none
.Ve
.SS "numResidues"
.IX Subsection "numResidues"
.Vb 7
\& Title         : numResidues
\& Usage         : returns the total number of residues in all chains or
\&                 just the specified chain if a chain is specified
\& Function      :
\& Example       : $num_res = $dssp_obj\->numResidues();
\& Returns       : scalar int
\& Args          : none
.Ve
.SS "pdbID"
.IX Subsection "pdbID"
.Vb 6
\& Title         : pdbID
\& Usage         : returns pdb identifier ( 1FJM, e.g.)
\& Function      :
\& Example       : $pdb_id = $dssp_obj\->pdbID();
\& Returns       : scalar string
\& Args          : none
.Ve
.SS "pdbAuthor"
.IX Subsection "pdbAuthor"
.Vb 6
\& Title         : pdbAuthor
\& Usage         : returns author field
\& Function      :
\& Example       : $auth = $dssp_obj\->pdbAuthor()
\& Returns       : scalar string
\& Args          : none
.Ve
.SS "pdbCompound"
.IX Subsection "pdbCompound"
.Vb 6
\& Title         : pdbCompound
\& Usage         : returns pdbCompound given in PDB file
\& Function      :
\& Example       : $cmpd = $dssp_obj\->pdbCompound();
\& Returns       : scalar string
\& Args          : none
.Ve
.SS "pdbDate"
.IX Subsection "pdbDate"
.Vb 6
\& Title         : pdbDate
\& Usage         : returns date given in PDB file
\& Function      :
\& Example       : $pdb_date = $dssp_obj\->pdbDate();
\& Returns       : scalar
\& Args          : none
.Ve
.SS "pdbHeader"
.IX Subsection "pdbHeader"
.Vb 6
\& Title         : pdbHeader
\& Usage         : returns header info from PDB file
\& Function      :
\& Example       : $header = $dssp_obj\->pdbHeader();
\& Returns       : scalar
\& Args          : none
.Ve
.SS "pdbSource"
.IX Subsection "pdbSource"
.Vb 6
\& Title         : pdbSource
\& Usage         : returns pdbSource information from PDBSOURCE line
\& Function      :
\& Example       : $pdbSource = $dssp_obj\->pdbSource();
\& Returns       : scalar
\& Args          : none
.Ve
.SS "resAA"
.IX Subsection "resAA"
.Vb 6
\& Title         : resAA
\& Usage         : fetches the 1 char amino acid code, given an id
\& Function      :
\& Example       : $aa = $dssp_obj\->resAA( \*(Aq20:A\*(Aq ); # pdb id as arg
\& Returns       : 1 character scalar string
\& Args          : RESIDUE_ID
.Ve
.SS "resPhi"
.IX Subsection "resPhi"
.Vb 6
\& Title         : resPhi
\& Usage         : returns phi angle of a single residue
\& Function      : accessor
\& Example       : $phi = $dssp_obj\->resPhi( RESIDUE_ID )
\& Returns       : scalar
\& Args          : RESIDUE_ID
.Ve
.SS "resPsi"
.IX Subsection "resPsi"
.Vb 6
\& Title         : resPsi
\& Usage         : returns psi angle of a single residue
\& Function      : accessor
\& Example       : $psi = $dssp_obj\->resPsi( RESIDUE_ID )
\& Returns       : scalar
\& Args          : RESIDUE_ID
.Ve
.SS "resSolvAcc"
.IX Subsection "resSolvAcc"
.Vb 7
\& Title         : resSolvAcc
\& Usage         : returns solvent exposed area of this residue in
\&                 square Andstroms
\& Function      :
\& Example       : $solv_acc = $dssp_obj\->resSolvAcc( RESIDUE_ID );
\& Returns       : scalar
\& Args          : RESIDUE_ID
.Ve
.SS "resSurfArea"
.IX Subsection "resSurfArea"
.Vb 7
\& Title         : resSurfArea
\& Usage         : returns solvent exposed area of this residue in
\&                 square Andstroms
\& Function      :
\& Example       : $solv_acc = $dssp_obj\->resSurfArea( RESIDUE_ID );
\& Returns       : scalar
\& Args          : RESIDUE_ID
.Ve
.SS "resSecStr"
.IX Subsection "resSecStr"
.Vb 10
\& Title         : resSecStr
\& Usage         : $ss = $dssp_obj\->resSecStr( RESIDUE_ID );
\& Function      : returns the DSSP secondary structural designation of this residue
\& Example       :
\& Returns       : a character ( \*(AqB\*(Aq, \*(AqE\*(Aq, \*(AqG\*(Aq, \*(AqH\*(Aq, \*(AqI\*(Aq, \*(AqS\*(Aq, \*(AqT\*(Aq, or \*(Aq \*(Aq )
\& Args          : RESIDUE_ID
\& NOTE          : The range of this method differs from that of the
\&    resSecStr method in the STRIDE SecStr parser.  That is because of the
\&    slightly different format for STRIDE and DSSP output.  The resSecStrSum
\&    method exists to map these different ranges onto an identical range.
.Ve
.SS "resSecStrSum"
.IX Subsection "resSecStrSum"
.Vb 12
\& Title         : resSecStrSum
\& Usage         : $ss = $dssp_obj\->resSecStrSum( $id );
\& Function      : returns what secondary structure group this residue belongs
\&                 to.  One of:  \*(AqH\*(Aq: helix ( H, G, or I )
\&                               \*(AqB\*(Aq: beta  ( B or E )
\&                               \*(AqT\*(Aq: turn  ( T or S )
\&                               \*(Aq \*(Aq: none  ( \*(Aq \*(Aq )
\&                 This method is similar to resSecStr, but the information
\&                 it returns is less specific.
\& Example       :
\& Returns       : a character ( \*(AqH\*(Aq, \*(AqB\*(Aq, \*(AqT\*(Aq, or \*(Aq \*(Aq )
\& Args          : dssp residue number of pdb residue identifier
.Ve
.SS "hBonds"
.IX Subsection "hBonds"
.Vb 10
\& Title         : hBonds
\& Usage         : returns number of 14 different types of H Bonds
\& Function      :
\& Example       : $hb = $dssp_obj\->hBonds
\& Returns       : pointer to 14 element array of ints
\& Args          : none
\& NOTE          : The different type of H\-Bonds reported are, in order:
\&    TYPE O(I)\-\->H\-N(J)
\&    IN PARALLEL BRIDGES
\&    IN ANTIPARALLEL BRIDGES
\&    TYPE O(I)\-\->H\-N(I\-5)
\&    TYPE O(I)\-\->H\-N(I\-4)
\&    TYPE O(I)\-\->H\-N(I\-3)
\&    TYPE O(I)\-\->H\-N(I\-2)
\&    TYPE O(I)\-\->H\-N(I\-1)
\&    TYPE O(I)\-\->H\-N(I+0)
\&    TYPE O(I)\-\->H\-N(I+1)
\&    TYPE O(I)\-\->H\-N(I+2)
\&    TYPE O(I)\-\->H\-N(I+3)
\&    TYPE O(I)\-\->H\-N(I+4)
\&    TYPE O(I)\-\->H\-N(I+5)
.Ve
.SS "numSSBr"
.IX Subsection "numSSBr"
.Vb 6
\& Title         : numSSBr
\& Usage         : returns info about number of SS\-bridges
\& Function      :
\& Example       : @SS_br = $dssp_obj\->numSSbr();
\& Returns       : 3 element scalar int array
\& Args          : none
.Ve
.SS "resHB_O_HN"
.IX Subsection "resHB_O_HN"
.Vb 12
\& Title         : resHB_O_HN
\& Usage         : returns pointer to a 4 element array
\&                 consisting of: relative position of binding
\&                 partner #1, energy of that bond (kcal/mol),
\&                 relative positionof binding partner #2,
\&                 energy of that bond (kcal/mol).  If the bond
\&                 is not bifurcated, the second bond is reported
\&                 as 0, 0.0
\& Function      : accessor
\& Example       : $oBonds_ptr = $dssp_obj\->resHB_O_HN( RESIDUE_ID )
\& Returns       : pointer to 4 element array
\& Args          : RESIDUE_ID
.Ve
.SS "resHB_NH_O"
.IX Subsection "resHB_NH_O"
.Vb 12
\& Title         : resHB_NH_O
\& Usage         : returns pointer to a 4 element array
\&                 consisting of: relative position of binding
\&                 partner #1, energy of that bond (kcal/mol),
\&                 relative positionof binding partner #2,
\&                 energy of that bond (kcal/mol).  If the bond
\&                 is not bifurcated, the second bond is reported
\&                 as 0, 0.0
\& Function      : accessor
\& Example       : $nhBonds_ptr = $dssp_obj\->resHB_NH_O( RESIDUE_ID )
\& Returns       : pointer to 4 element array
\& Args          : RESIDUE_ID
.Ve
.SS "resTco"
.IX Subsection "resTco"
.Vb 6
\& Title         : resTco
\& Usage         : returns tco angle around this residue
\& Function      : accessor
\& Example       : resTco = $dssp_obj\->resTco( RESIDUE_ID )
\& Returns       : scalar
\& Args          : RESIDUE_ID
.Ve
.SS "resKappa"
.IX Subsection "resKappa"
.Vb 6
\& Title         : resKappa
\& Usage         : returns kappa angle around this residue
\& Function      : accessor
\& Example       : $kappa = $dssp_obj\->resKappa( RESIDUE_ID )
\& Returns       : scalar
\& Args          : RESIDUE_ID ( dssp or PDB )
.Ve
.SS "resAlpha"
.IX Subsection "resAlpha"
.Vb 6
\& Title         : resAlpha
\& Usage         : returns alpha angle around this residue
\& Function      : accessor
\& Example       : $alpha = $dssp_obj\->resAlpha( RESIDUE_ID )
\& Returns       : scalar
\& Args          : RESIDUE_ID ( dssp or PDB )
.Ve
.SS "secBounds"
.IX Subsection "secBounds"
.Vb 12
\& Title         : secBounds
\& Usage         : gets residue ids of boundary residues in each
\&                 contiguous secondary structural element of specified
\&                 chain
\& Function      : returns pointer to array of 3 element arrays.  First
\&                 two elements are the PDB IDs of the start and end points,
\&                 respectively and inclusively.  The last element is the
\&                 DSSP secondary structural assignment code,
\&                 i.e. one of : (\*(AqB\*(Aq, \*(AqE\*(Aq, \*(AqG\*(Aq, \*(AqH\*(Aq, \*(AqI\*(Aq, \*(AqS\*(Aq, \*(AqT\*(Aq, or \*(Aq \*(Aq)
\& Example       : $ss_elements_pts = $dssp_obj\->secBounds( \*(AqA\*(Aq );
\& Returns       : pointer to array of arrays
\& Args          : chain id ( \*(AqA\*(Aq, for example ).  No arg => no chain id
.Ve
.SS "chains"
.IX Subsection "chains"
.Vb 6
\& Title         : chains
\& Usage         : returns pointer to array of chain I.D.s (characters)
\& Function      :
\& Example       : $chains_pnt = $dssp_obj\->chains();
\& Returns       : array of characters, one of which may be \*(Aq \*(Aq
\& Args          : none
.Ve
.SS "residues"
.IX Subsection "residues"
.Vb 9
\&    Title : residues
\&    Usage : returns array of residue identifiers for all residues in
\&    the output file, or in a specific chain
\&    Function :
\&    Example : @residues_ids = $dssp_obj\->residues()
\&    Returns : array of residue identifiers
\&    Args : if none => returns residue ids of all residues of all
\&    chains (in order); if chain id is given, returns just the residue
\&    ids of residues in that chain
.Ve
.SS "getSeq"
.IX Subsection "getSeq"
.Vb 12
\& Title         : getSeq
\& Usage         : returns a Bio::PrimarySeq object which represents a good
\&                 guess at the sequence of the given chain
\& Function      : For most chains of most entries, the sequence returned by
\&                 this method will be very good.  However, it is inherently
\&                 unsafe to rely on DSSP to extract sequence information about
\&                 a PDB entry.  More reliable information can be obtained from
\&                 the PDB entry itself.
\& Example       : $pso = $dssp_obj\->getSeq( \*(AqA\*(Aq );
\& Returns       : (pointer to) a PrimarySeq object
\& Args          : Chain identifier.  If none given, \*(Aq \*(Aq is assumed.  If no \*(Aq \*(Aq
\&                 chain, the first chain is used.
.Ve
.SH "INTERNAL METHODS"
.IX Header "INTERNAL METHODS"
.SS "_pdbChain"
.IX Subsection "_pdbChain"
.Vb 6
\& Title         : _pdbChain
\& Usage         : returns the pdb chain id of given residue
\& Function      :
\& Example       : $chain_id = $dssp_obj\->pdbChain( DSSP_KEY );
\& Returns       : scalar
\& Args          : DSSP_KEY ( dssp or pdb )
.Ve
.SS "_resAA"
.IX Subsection "_resAA"
.Vb 6
\& Title         : _resAA
\& Usage         : fetches the 1 char amino acid code, given a dssp id
\& Function      :
\& Example       : $aa = $dssp_obj\->_resAA( dssp_id );
\& Returns       : 1 character scalar string
\& Args          : dssp_id
.Ve
.SS "_pdbNum"
.IX Subsection "_pdbNum"
.Vb 9
\& Title        : _pdbNum
\& Usage        : fetches the numeric portion of the identifier for a given
\&                residue as reported by the pdb entry.  Note, this DOES NOT
\&                uniquely specify a residue.  There may be an insertion code
\&                and/or chain identifier differences.
\& Function     :
\& Example      : $pdbNum = $self\->_pdbNum( DSSP_ID );
\& Returns      : a scalar
\& Args         : DSSP_ID
.Ve
.SS "_pdbInsCo"
.IX Subsection "_pdbInsCo"
.Vb 6
\& Title        : _pdbInsCo
\& Usage        : fetches the Insertion Code for this residue, if it has one.
\& Function     :
\& Example      : $pdbNum = $self\->_pdbInsCo( DSSP_ID );
\& Returns      : a scalar
\& Args         : DSSP_ID
.Ve
.SS "_toPdbId"
.IX Subsection "_toPdbId"
.Vb 7
\& Title        : _toPdbId
\& Usage        : Takes a dssp key and builds the corresponding
\&                PDB identifier string
\& Function     :
\& Example      : $pdbId = $self\->_toPdbId( DSSP_ID );
\& Returns      : scalar
\& Args         : DSSP_ID
.Ve
.SS "_contSegs"
.IX Subsection "_contSegs"
.Vb 12
\& Title         : _contSegs
\& Usage         : find the endpoints of continuous regions of this structure
\& Function      : returns pointer to array of 3 element array.
\&                 Elements are the dssp keys of the start and end points of each
\&                 continuous element and its PDB chain id (may be blank).
\&                 Note that it is common to have several
\&                 continuous elements with the same chain id.  This occurs
\&                 when an internal region is disordered and no structural
\&                 information is available.
\& Example       : $cont_seg_ptr = $dssp_obj\->_contSegs();
\& Returns       : pointer to array of arrays
\& Args          : none
.Ve
.SS "_numResLines"
.IX Subsection "_numResLines"
.Vb 10
\& Title         : _numResLines
\& Usage         : returns the total number of residue lines in this
\&                 dssp file.
\&                 This number is DIFFERENT than the number of residues in
\&                 the pdb file because dssp has chain termination and chain
\&                 discontinuity \*(Aqresidues\*(Aq.
\& Function      :
\& Example       : $num_res = $dssp_obj\->_numResLines();
\& Returns       : scalar int
\& Args          : none
.Ve
.SS "_toDsspKey"
.IX Subsection "_toDsspKey"
.Vb 10
\& Title         : _toDsspKey
\& Usage         : returns the unique dssp integer key given a pdb residue id.
\&                 All accessor methods require (internally)
\&                 the dssp key.   This method is very useful in converting
\&                 pdb keys to dssp keys so the accessors can accept pdb keys
\&                 as argument.  PDB Residue IDs are inherently
\&                 problematic since they have multiple parts of
\&                 overlapping function and ill\-defined or observed
\&                 convention in form.  Input can be in any of the formats
\&                 described in the DESCRIPTION section above.
\& Function      :
\& Example       : $dssp_id = $dssp_obj\->_pdbKeyToDsspKey( \*(Aq10B:A\*(Aq )
\& Returns       : scalar int
\& Args          : pdb residue identifier: num[insertion code]:[chain]
.Ve
.SS "_parse"
.IX Subsection "_parse"
.Vb 6
\& Title         : _parse
\& Usage         : parses dssp output
\& Function      :
\& Example       : used by the constructor
\& Returns       :
\& Args          : input source ( handled by Bio::Root:IO )
.Ve
.SS "_parseResLine"
.IX Subsection "_parseResLine"
.Vb 6
\& Title         : _parseResLine
\& Usage         : parses a single residue line
\& Function      :
\& Example       : used internally
\& Returns       :
\& Args          : residue line ( string )
.Ve
