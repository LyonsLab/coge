.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Data::Stag::BaseHandler 3"
.TH Data::Stag::BaseHandler 3 "2008-06-03" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
.Vb 1
\&  Data::Stag::BaseHandler     \- Base class for writing tag stream handlers
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  # EXAMPLE 1
\&  package MyPersonHandler;
\&  use base qw(Data::Stag::BaseHandler);
\&
\&  # handler that prints <person> nodes as they are parsed;
\&  # after each <person> node is intercepted, it is discarded
\&  # (it does not go to form the final tree)
\&  sub e_person {
\&      my $self = shift;
\&      my $node = shift;
\&      printf "Person name:%s address:%s\en",
\&        $node\->sget(\*(Aqname\*(Aq), $node\->sget(\*(Aqaddress\*(Aq);
\&      return;               # prune this from tree
\&  }
\&  1;
\&  
\&  # EXAMPLE 2
\&  package MyStatsHandler;
\&  use base qw(Data::Stag::BaseHandler);
\&
\&  # handler that modifies tree as it goes
\&  # changes <measurement><unit>inch</unit><quantity>10</quantity></measurement>
\&  # to      <measurement><unit>cm</unit><quantity>25</quantity></measurement>
\&  sub e_measurement {
\&      my $self = shift;
\&      my $node = shift;
\&      if ($node\->sget(\*(Aqunit\*(Aq) eq \*(Aqinch\*(Aq) {
\&          $node\->set(\*(Aqunit\*(Aq, \*(Aqcm\*(Aq);
\&          $node\->set(\*(Aqquantity\*(Aq, $node\->get(\*(Aqquantity\*(Aq) * 2.5);
\&      }
\&      return $node;     # replace <measurement> with new data in result tree
\&  }
\&  1;
\&  
\&  # Using the handlers
\&  my $handler = MyHandler\->new;
\&  my $stag = Data::Stag\->parse(\-fh=>$fh, \-handler=>$handler);
\&
\&  # Using a handler from the command line:
\&  unix> stag\-handle.pl \-m MyHandler input.xml > post\-processed.xml
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Default Simple Event Handler, other handlers inherit from this class
.PP
See also Data::Stag and Data::Stag::BaseGenerator
.PP
Stag has an event-handling architecture; parsers or generators
\&\fBgenerate\fR or \fBfire\fR events. Events can be hierarchical/nested, just
like stag nodes. These events are caught by handlers. By default,
uncaught events stack to form stag trees.
.PP
Stag has built in parsers for parsing xml, sxpr and itext data. You
can construct your own parsers for dealing with your own formats
specific to your own data; these should inherit from
Data::Stag::BaseGenerator
.PP
Stag also has built in handlers for these formats. You can construct
your own \- either as modules that inherit from this one, or as hashes
of anonymous subroutines.
.PP
If you wish to write your own handler that writes out to another
format, you may wish to inherit from Data::Stag::Writer
.SS "\s-1CATCHING\s0 \s-1EVENTS\s0"
.IX Subsection "CATCHING EVENTS"
This class catches Data::Stag node events  (start, end and body) and allows the
subclassing module to intercept these. Unintercepted events get pushed
into a tree. The final tree is returned at the end of a \fIparse()\fR call
.PP
This class can take \s-1SAX\s0 events and turn them into simple
Data::Stag events
.PP
the events recognised are
.PP
.Vb 3
\&  start_event(node\-name)
\&  evbody(node\-data)
\&  end_event(node\-name)
.Ve
.PP
and also
.PP
.Vb 1
\&  event(node\-name, node\-data|[nodes])
.Ve
.PP
which is just a wrapper for the other events
.PP
you can either intercept these methods; or you can define methods
.PP
.Vb 2
\&  s_<element_name>
\&  e_<element_name>
.Ve
.PP
that get called on the start/end of an event; you can dynamically
change the structure of the tree by returning nodes from these methods.
.PP
.Vb 10
\&  # the follow handler prunes <foo> nodes from the tree, and writes
\&  # out data from the <person> node
\&  # when parsing large datasets, it can be a good idea to prune nodes
\&  # from the tree, so the result tree of the parse is not too big
\&  my $h = Data::Stag\->makehandler( foo => 0,
\&                                   person => sub {
\&                                       my $self = shift;
\&                                       my $node = shift;
\&                                       printf "Person name:%s address:%s\en",
\&                                         $node\->sget(\*(Aqname\*(Aq), $node\->sget(\*(Aqaddress\*(Aq);
\&                                       return;
\&                                   });
\&  my $parser = MyParser\->new;
\&  $parser\->handler($h);
\&  $parser\->parse(\-fh=>$fh);
\&  my $result_tree = $h\->stag;
.Ve
.SH "PUBLIC METHODS \-"
.IX Header "PUBLIC METHODS -"
\fInew\fR
.IX Subsection "new"
.PP
.Vb 1
\&       Title: new
\&
\&        Args: 
\&      Return: L<Data::Stag::BaseHandler>
\&     Example:
.Ve
.PP
returns the tree that was built from all uncaught events
.PP
\fItree (stag)\fR
.IX Subsection "tree (stag)"
.PP
.Vb 2
\&       Title: tree
\&     Synonym: stag
\&
\&        Args: 
\&      Return: L<Data::Stag>
\&     Example: print $parser\->handler\->tree\->xml;
.Ve
.PP
returns the tree that was built from all uncaught events
.SH "CAUGHT EVENTS"
.IX Header "CAUGHT EVENTS"
A Data::Stag::BaseGenerator class will generate events by calling the following methods on this class:
.IP "start_event \s-1NODENAME\s0" 4
.IX Item "start_event NODENAME"
.PD 0
.IP "evbody \s-1DATA\s0" 4
.IX Item "evbody DATA"
.IP "end_event \s-1NODENAME\s0 {optional}" 4
.IX Item "end_event NODENAME {optional}"
.IP "event \s-1NODENAME\s0 \s-1DATA\s0" 4
.IX Item "event NODENAME DATA"
.PD
.PP
These events can be nested/hierarchical
.PP
If uncaught, these events are stacked into a stag tree, which can be
written as xml or one of the other stag formats
.SH "PROTECTED METHODS \-"
.IX Header "PROTECTED METHODS -"
\fIs_*\fR
.IX Subsection "s_*"
.PP
.Vb 3
\&        Args: handler L<Data::Stag::BaseHandler>
\&      Return: 
\&     Example:
.Ve
.PP
autogenerated method \- called by the parser when ever it starts a
node; * matches the node name
.PP
override this class providing the name of the node you wish to intercept
.PP
\fIe_*\fR
.IX Subsection "e_*"
.PP
.Vb 3
\&        Args: handler L<Data::Stag::BaseHandler>, node L<Data::Stag>
\&      Return: node L<Data::Stag>
\&     Example:
.Ve
.PP
autogenerated method \- called by the parser when ever it ends a
node; * matches the node name
.PP
override this class providing the name of the node you wish to intercept
.PP
\fI\s-1CONSUMES\s0\fR
.IX Subsection "CONSUMES"
.PP
define this in your handler class to make explicit the list of node
names that your parser consumes; this is then used if your handler is
placed in a chain
.PP
.Vb 5
\&  package MyHandler;
\&  use base qw(Data::Stag::BaseHandler);
\&  sub CONSUMES {qw(person city)}
\&  sub e_person {....}
\&  sub e_city   {....}
.Ve
.PP
\fIdepth\fR
.IX Subsection "depth"
.PP
.Vb 1
\&       Title: depth
\&
\&        Args: 
\&      Return: depth int
\&     Example:
.Ve
.PP
depth of the nested event tree
.PP
\fIup\fR
.IX Subsection "up"
.PP
.Vb 1
\&       Title: up
\&
\&        Args: dist int
\&      Return: node stag
\&     Example: $stag\->up(\-2);
.Ve
.PP
when called when intercepting a node <foo>, this will look \fBdist\fR up
the tree to find the container node
.PP
For example, if our data contains the node <blah> below:
.PP
.Vb 8
\&  <blah>
\&    <foo>
\&      <a>1</b>
\&    </foo>
\&    <foo>
\&      <a>2</b>
\&    </foo>
\&  </blah>
\&
\&    # and we have the following code:
\&    $h = Data::Stag\->makehandler(foo=>sub {
\&                                           my ($self, $foo) = @_;
\&                                           print $foo\->up(1)\->xml;
\&                                           return});
.Ve
.PP
The <foo> handler will be called twice; it will print the structure of
the containing <blah> node, but the first time round, the <blah> node
will not be complete
.PP
\fIup_to\fR
.IX Subsection "up_to"
.PP
.Vb 1
\&       Title: up_to
\&
\&        Args: nodename str
\&      Return: node stag
\&     Example: $stag\->up_to(\*(Aqblah\*(Aq);
.Ve
.PP
Similar to \fIup()\fR, but it will go up the container event nodes until it
finds one with the matching name
