.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Seq::Meta 3"
.TH Bio::Seq::Meta 3 "2013-05-09" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::Seq::Meta \- Generic superclass for sequence objects with
residue\-based meta information
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  use Bio::LocatableSeq;
\&  use Bio::Seq::Meta;
\&  use Bio::Tools::OddCodes;
\&  use Bio::SeqIO;
\&
\&  my $seq = Bio::Seq::Meta\->new(\-id=>\*(Aqtest\*(Aq,
\&                                   \-seq=>\*(AqACTGCTAGCT\*(Aq,
\&                                   \-start=>2434,
\&                                   \-end=>2443,
\&                                   \-strand=>1,
\&                                   \-verbose=>1, # to see warnings
\&                                  );
\&
\&  # the existing sequence object can be a Bio::PrimarySeq, too
\&
\&  # to test this is a meta seq object
\&  $seq\->isa("Bio::Seq::Meta")
\&      || $seq\->throw("$seq is not a Bio::Seq::Meta");
\&
\&
\&  $seq\->meta(\*(Aq1234567890\*(Aq);
\&  $seq = Bio::Seq::Meta\->new(\-id=>\*(Aqtest\*(Aq,
\&                             \-seq=>\*(AqHACILMIFGT\*(Aq,
\&                             \-start=>2434,
\&                             \-end=>2443,
\&                             \-strand=>1,
\&                             \-meta=>\*(Aq1234567890\*(Aq,
\&                             \-verbose=>1, # to see warnings
\&                            );
\&
\&  # accessors
\&  $string     = $seq\->meta_text();
\&  $substring  = $seq\->submeta_text(2,5);
\&  $unique_key = $seq\->accession_number();
\&
\&  # storing output from Bio::Tools::OddCodes as meta data
\&  my $protcodes = Bio::Tools::OddCodes\->new(\-seq => $seq);
\&  my @codes = qw(structural chemical functional charge hydrophobic);
\&  map { $seq\->named_meta($_, ${$protcodes\->$_($seq) } )} @codes;
\&
\&  my $out = Bio::SeqIO\->new(\-format=>\*(Aqmetafasta\*(Aq);
\&  $out\->write_seq($seq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class implements generic methods for sequences with residue-based
meta information. Meta sequences with meta data are Bio::LocatableSeq
objects with additional methods to store that meta information. See
Bio::LocatableSeq and Bio::Seq::MetaI.
.PP
The meta information in this class is always one character per residue
long and blank values are space characters (\s-1ASCII\s0 32).
.PP
After the latest rewrite, the meta information no longer covers all
the residues automatically. Methods to check the length of meta
information (meta_length)and to see if the ends are flushed to the
sequence have been added (is_flush). To force the old
functionality, set force_flush to true.
.PP
It is assumed that meta data values do not depend on the nucleotide
sequence strand value.
.PP
Application specific implementations should inherit from this class to
override and add to these methods.
.PP
Bio::Seq::Meta::Array allows for more complex meta values (scalars
or objects) to be used.
.SS "Method naming"
.IX Subsection "Method naming"
Character based meta data is read and set by method \fImeta()\fR and its
variants. These are the suffixes and prefixes used in the variants:
.PP
.Vb 1
\&    [named_] [sub] meta [_text]
.Ve
.IP "_text" 3
.IX Item "_text"
Suffix \fB_text\fR guaranties that output is a string. Note that it does
not limit the input.
.Sp
In this implementation, the output is always text, so these methods
are redundant.
.IP "sub" 3
.IX Item "sub"
Prefix \fBsub\fR, like in \fIsubseq()\fR, means that the method applies to sub
region of the sequence range and takes start and end as arguments.
Unlike \fIsubseq()\fR, these methods are able to set values.  If the range
is not defined, it defaults to the complete sequence.
.IP "named" 3
.IX Item "named"
Prefix \fBnamed_\fR in method names allows the used to attach multiple
meta strings to one sequence by explicitly naming them. The name is
always the first argument to the method. The \*(L"unnamed\*(R" methods use the
class wide default name for the meta data and are thus special cases
\&\*(L"named\*(R" methods.
.Sp
Note that internally names are keys in a hash and any misspelling of a
name will silently store the data under a wrong name. The used names
(keys) can be retrieved using method \fImeta_names()\fR. See meta_names.
.SH "NOTE"
.IX Header "NOTE"
This Bio::Seq::MetaI implementation inherits from Bio::LocatableSeq, which
itself inherits from Bio::PrimarySeq. It is not a Bio::SeqI, so bless-ing
objects of this class into a Bio::SeqI or vice versa and will not work as
expected (see bug 2262). This may be addressed in a future refactor of
Bio::LocatableSeq.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Bio::LocatableSeq, 
Bio::Seq::MetaI, 
Bio::Seq::Meta::Array
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  https://redmine.open\-bio.org/projects/bioperl/
.Ve
.SH "AUTHOR \- Heikki Lehvaslaiho"
.IX Header "AUTHOR - Heikki Lehvaslaiho"
Email heikki-at-bioperl-dot-org
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Chad Matsalla, bioinformatics@dieselwurks.com
.PP
Aaron Mackey, amackey@virginia.edu
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _
.SS "new"
.IX Subsection "new"
.Vb 10
\& Title   : new
\& Usage   : $metaseq = Bio::Seq::Meta\->new
\&                ( \-meta => \*(Aqaaaaaaaabbbbbbbb\*(Aq,
\&                  \-seq =>  \*(AqTKLMILVSHIVILSRM\*(Aq
\&                  \-id  => \*(Aqhuman_id\*(Aq,
\&                  \-accession_number => \*(AqS000012\*(Aq,
\&                );
\& Function: Constructor for Bio::Seq::Meta class, meta data being in a
\&           string. Note that you can provide an empty quality string.
\& Returns : a new Bio::Seq::Meta object
.Ve
.SS "meta"
.IX Subsection "meta"
.Vb 3
\& Title   : meta
\& Usage   : $meta_values  = $obj\->meta($values_string);
\& Function:
\&
\&           Get and set method for the meta data starting from residue
\&           position one. Since it is dependent on the length of the
\&           sequence, it needs to be manipulated after the sequence.
\&
\&           The length of the returned value always matches the length
\&           of the sequence, if force_flush() is set. See L<force_flush>.
\&
\& Returns : meta data in a string
\& Args    : new value, string, optional
.Ve
.SS "meta_text"
.IX Subsection "meta_text"
.Vb 6
\& Title   : meta_text
\& Usage   : $meta_values  = $obj\->meta_text($values_arrayref);
\& Function: Variant of meta() guarantied to return a textual
\&           representation  of meta data. For details, see L<meta>.
\& Returns : a string
\& Args    : new value, optional
.Ve
.SS "named_meta"
.IX Subsection "named_meta"
.Vb 7
\& Title   : named_meta()
\& Usage   : $meta_values  = $obj\->named_meta($name, $values_arrayref);
\& Function: A more general version of meta(). Each meta data set needs
\&           to be named. See also L<meta_names>.
\& Returns : a string
\& Args    : scalar, name of the meta data set
\&           new value, optional
.Ve
.SS "_test_gap_positions"
.IX Subsection "_test_gap_positions"
.Vb 4
\& Title   : _test_gap_positions
\& Usage   : $meta_values  = $obj\->_test_gap_positions($name);
\& Function: Internal test for correct position of gap characters.
\&           Gap being only \*(Aq\-\*(Aq this time.
\&
\&           This method is called from named_meta() when setting meta
\&           data but only if verbose is positive as this can be an
\&           expensive process on very long sequences. Set verbose(1) to
\&           see warnings when gaps do not align in sequence and meta
\&           data and turn them into errors by setting verbose(2).
\&
\& Returns : true on success, prints warnings
\& Args    : none
.Ve
.SS "named_meta_text"
.IX Subsection "named_meta_text"
.Vb 8
\& Title   : named_meta_text()
\& Usage   : $meta_values  = $obj\->named_meta_text($name, $values_arrayref);
\& Function: Variant of named_meta() guarantied to return a textual
\&           representation  of the named meta data.
\&           For details, see L<meta>.
\& Returns : a string
\& Args    : scalar, name of the meta data set
\&           new value, optional
.Ve
.SS "submeta"
.IX Subsection "submeta"
.Vb 4
\& Title   : submeta
\& Usage   : $subset_of_meta_values = $obj\->submeta(10, 20, $value_string);
\&           $subset_of_meta_values = $obj\->submeta(10, undef, $value_string);
\& Function:
\&
\&           Get and set method for meta data for subsequences.
\&
\&           Numbering starts from 1 and the number is inclusive, ie 1\-2
\&           are the first two residue of the sequence. Start cannot be
\&           larger than end but can be equal.
\&
\&           If the second argument is missing the returned values
\&           should extend to the end of the sequence.
\&
\&           The return value may be a string or an array reference,
\&           depending on the implementation. If in doubt, use
\&           submeta_text() which is a variant guarantied to return a
\&           string.  See L<submeta_text>.
\&
\& Returns : A reference to an array or a string
\& Args    : integer, start position
\&           integer, end position, optional when a third argument present
\&           new value, optional
.Ve
.SS "submeta_text"
.IX Subsection "submeta_text"
.Vb 6
\& Title   : submeta_text
\& Usage   : $meta_values  = $obj\->submeta_text(20, $value_string);
\& Function: Variant of submeta() guarantied to return a textual 
\&           representation  of meta data. For details, see L<meta>.
\& Returns : a string
\& Args    : new value, optional
.Ve
.SS "named_submeta"
.IX Subsection "named_submeta"
.Vb 10
\& Title   : named_submeta
\& Usage   : $subset_of_meta_values = $obj\->named_submeta($name, 10, 20, $value_string);
\&           $subset_of_meta_values = $obj\->named_submeta($name, 10);
\& Function: Variant of submeta() guarantied to return a textual
\&           representation  of meta data. For details, see L<meta>.
\& Returns : A reference to an array or a string
\& Args    : scalar, name of the meta data set
\&           integer, start position
\&           integer, end position, optional when a third argument present
\&           new value, optional
.Ve
.SS "named_submeta_text"
.IX Subsection "named_submeta_text"
.Vb 9
\& Title   : named_submeta_text
\& Usage   : $meta_values  = $obj\->named_submeta_text($name, 20, $value_string);
\& Function: Variant of submeta() guarantied to return a textual
\&           representation  of meta data. For details, see L<meta>.
\& Returns : a string
\& Args    : scalar, name of the meta data
\& Args    : integer, start position, optional
\&           integer, end position, optional
\&           new value, optional
.Ve
.SS "meta_names"
.IX Subsection "meta_names"
.Vb 6
\& Title   : meta_names
\& Usage   : @meta_names  = $obj\->meta_names()
\& Function: Retrieves an array of meta data set names. The default
\&           (unnamed) set name is guarantied to be the first name.
\& Returns : an array of names
\& Args    : none
.Ve
.SS "meta_length"
.IX Subsection "meta_length"
.Vb 5
\& Title   : meta_length()
\& Usage   : $meeta_len  = $obj\->meta_length();
\& Function: return the number of elements in the meta set
\& Returns : integer
\& Args    : \-
.Ve
.SS "named_meta_length"
.IX Subsection "named_meta_length"
.Vb 5
\& Title   : named_meta_length()
\& Usage   : $meta_len  = $obj\->named_meta_length($name);
\& Function: return the number of elements in the named meta set
\& Returns : integer
\& Args    : \-
.Ve
.SS "force_flush"
.IX Subsection "force_flush"
.Vb 6
\& Title   : force_flush()
\& Usage   : $force_flush = $obj\->force_flush(1);
\& Function: Automatically pad with empty values or truncate meta values
\&           to sequence length. Not done by default.
\& Returns : boolean 1 or 0
\& Args    : optional boolean value
.Ve
.PP
Note that if you turn this forced padding off, the previously padded
values are not changed.
.SS "_do_flush"
.IX Subsection "_do_flush"
.Vb 6
\& Title   : _do_flush
\& Usage   : 
\& Function: internal method to do the force that meta values are same 
\&           length as the sequence . Called from L<force_flush>
\& Returns : 
\& Args    :
.Ve
.SS "is_flush"
.IX Subsection "is_flush"
.Vb 9
\& Title   : is_flush
\& Usage   : $is_flush  = $obj\->is_flush()
\&           or  $is_flush = $obj\->is_flush($my_meta_name)
\& Function: Boolean to tell if all meta values are in
\&           flush with the sequence length.
\&           Returns true if force_flush() is set
\&           Set verbosity to a positive value to see failed meta sets
\& Returns : boolean 1 or 0
\& Args    : optional name of the meta set
.Ve
.SH "Bio::PrimarySeqI methods"
.IX Header "Bio::PrimarySeqI methods"
.SS "revcom"
.IX Subsection "revcom"
.Vb 7
\& Title   : revcom
\& Usage   : $newseq = $seq\->revcom();
\& Function: Produces a new Bio::Seq::MetaI implementing object where
\&           the order of residues and their meta information is reversed.
\& Returns : A new (fresh) Bio::Seq::Meta object
\& Args    : none
\& Throws  : if the object returns false on is_flush()
.Ve
.PP
Note: The method does nothing to meta values, it reorders them, only.
.SS "trunc"
.IX Subsection "trunc"
.Vb 5
\& Title   : trunc
\& Usage   : $subseq = $seq\->trunc(10,100);
\& Function: Provides a truncation of a sequence together with meta data
\& Returns : a fresh Bio::Seq::Meta implementing object
\& Args    : Two integers denoting first and last residue of the sub\-sequence.
.Ve
