.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::PhyloNetwork 3"
.TH Bio::PhyloNetwork 3 "2013-05-09" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::PhyloNetwork \- Module to compute with Phylogenetic Networks
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Bio::PhyloNetwork;
\&
\& # Create a PhyloNetwork object from a eNewick string
\& my $net1=Bio::PhyloNetwork\->new(
\&   \-eNewick=>\*(Aqt0:((H1,(H2,l2)),H2); H1:((H3,l1)); H2:((H3,(l3,H1))); H3:(l4);\*(Aq
\& );
\&
\& # Print all available data
\& print $net1;
\&
\& # Rebuild $net1 from its mu_data
\& my %mudata=$net1\->mudata();
\& my $net2=Bio::PhyloNetwork\->new(\-mudata=>\e%mudata,\-numleaves=>4);
\& print $net2;
\& print "d=".$net1\->mu_distance($net2)."\en";
\&
\& # Get another one and compute distance
\& my $net3=Bio::PhyloNetwork\->new(
\&   \-eNewick=>\*(Aq(l2,((l1,(H1,l4)),H1))r; (l3)H1;\*(Aq
\& );
\& print "d=".$net1\->mu_distance($net3)."\en";
\&
\& # ...and find an optimal alignment w.r.t. the Manhattan distance (default)
\& my ($weight,%alignment)=$net1\->optimal_alignment($net3);
\& print "weight:$weight\en";
\& foreach my $node1 (keys %alignment) {
\&   print "$node1 => ".$alignment{$node1}."\en";
\& }
\& # ...or the Hamming distance
\&
\& my ($weightH,%alignmentH)=$net1\->optimal_alignment($net3,\-metric=>\*(AqHamming\*(Aq);
\& print "weight:$weightH\en";
\& foreach my $node1 (keys %alignmentH) {
\&   print "$node1 => ".$alignmentH{$node1}."\en";
\& }
\&
\& # Test for time consistency of $net1
\& if ($net1\->is_time_consistent) {
\&   print "net1 is time consistent\en"
\& }
\& else {
\&   print "net1 is not time consistent\en"
\& }
\&
\& # create a network from the list of edges
\& my $net4=Bio::PhyloNetwork\->new(\-edges=>
\&   [qw(r s r t s u s c t c t v u b u l3 u b v b v l4 b l2 c l1)]);
\&
\& # Test for time consistency of $net3
\& if ($net4\->is_time_consistent) {
\&   print "net4 is time consistent\en"
\& }
\& else {
\&   print "net4 is not time consistent\en"
\& }
\&
\& # And print all information on net4
\& print $net4;
\&
\& # Compute some tripartitions
\& my %triparts=$net1\->tripartitions();
\&
\& # Now these are stored
\& print $net1;
\&
\& # And can compute the tripartition error
\& print "dtr=".$net1\->tripartition_error($net3)."\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "Phylogenetic Networks"
.IX Subsection "Phylogenetic Networks"
This is a module to work with phylogenetic networks. Phylogenetic networks
have been studied over the last years as a richer model of the evolutionary
history of sets of organisms than phylogenetic trees, because they take not
only mutation events but also recombination and horizontal gene transfer
events into account.
.PP
The natural model for describing the evolutionary
history of a set of sequences under recombination events is a \s-1DAG\s0, hence
this package relies on the package Graph::Directed to represent the
underlying graph of a phylogenetic network. We refer the reader to [\s-1CRV1\s0,CRV2]
for formal definitions related to phylogenetic networks.
.SS "eNewick description"
.IX Subsection "eNewick description"
With this package, phylogenetic networks can be given by its eNewick
string. This description appeared in other packages related to
phylogenetic networks (see [PhyloNet] and [NetGen]); in fact, these two
packages use different descriptions. The Bio::PhyloNetwork
package allows both of them, but uses the second one in its output.
.PP
The first approach [PhyloNet] goes as follows: For each hybrid node H, say with
parents u_1,u_2,...,u_k and children v_1,v_2,...v_l: split H in k+1 different
nodes; let each of the first k copies be a child of one of the u_1,...,u_k
(one for each) and have no children (hence we will have k extra leaves);
as for the last copy, let it have no parents and have v_1,...,v_l be its
children. This way we get a forest; each of the trees will be rooted at either
one root of the phylogenetic network or a hybrid node of it; the set of leaves
(of the whole forest) will be the set of leaves of the original network
together with the set of hybrid nodes (each of them repeated as many times
as its in-degree). Then, the eNewick representation of the phylogenetic network
will be the Newick representation of all the trees in the obtained forest,
each of them with its root labeled.
.PP
The second approach [NetGen] goes as follows: For each hybrid node H, say with
parents u_1,u_2,...,u_k and children v_1,v_2,...v_l: split H in k different
nodes; let the first copy be a child of u_1 and have all v_1,v_2,...v_l as
its children; let the other copies be child of u_2,...,u_k (one for each)
and have no children. This way, we get a tree whose set of leaves is the
set of leaves of the original network together with the set of hybrid nodes
(possibly repeated). Then the Newick string of the obtained tree (note that
some internal nodes will be labeled and some leaves will be repeated) is
the eNewick string of the phylogenetic network.
.PP
For example, consider the network depicted below:
.PP
.Vb 9
\&       r
\&      / \e
\&     /   \e
\&    U     V
\&   / \e   / \e
\&  1   \e /   3
\&       H
\&       |
\&       2
.Ve
.PP
If the first approach is taken, we get the forest:
.PP
.Vb 10
\&       r
\&      / \e
\&     /   \e
\&    U     V
\&   / \e   / \e
\&  1   H H   3
\&       |
\&       H
\&       |
\&       2
.Ve
.PP
Hence, the eNewick string is '((1,H),(H,3))r; (2)H;'.
.PP
As for the second one, one gets the tree:
.PP
.Vb 9
\&       r
\&      / \e
\&     /   \e
\&    U     V
\&   / \e   / \e
\&  1   H |   3
\&        H
\&        |
\&        2
.Ve
.PP
Hence, the eNewick string is '((1,H),((2)H,3))r;'.
.PP
Note: when rooting a tree, this package allows the notations
\&'(subtree,subtree,...)root' as well as 'root:(subtree,subtree,...)', but
the first one is used when writing eNewick strings.
.SS "Tree-child phylogenetic networks"
.IX Subsection "Tree-child phylogenetic networks"
Tree-child (\s-1TC\s0) phylogenetic networks are a special class of phylogenetic
networks for which a distance, called mu-distance, is defined [\s-1CRV2\s0]
based on certain data (mu-data) associated to every node.
Moreover, this distance extends the
Robinson-Foulds on phylogenetic trees. This package allows testing for a
phylogenetic network if it is \s-1TC\s0 and computes mu-distances between networks
over the same set of leaves.
.PP
Moreover, the mu-data allows one to define the optimal
(in some precise sense) alignment between networks
over the same set of leaves. This package also computes this optimal alignment.
.SS "Tripartitions"
.IX Subsection "Tripartitions"
Although tripartitions (see [\s-1CRV1\s0] and the references therein) do not allow
to define distances, this package outputs tripartitions and computes a weak
form of the tripartition error.
.SS "Time-consistency"
.IX Subsection "Time-consistency"
Another useful property of Phylogenetic Networks that appears in the literature
is that of time-consistency or real-time hybrids [\s-1BSS\s0]. Roughly speaking, a
network admits a temporal representation if it can be drawn in such a way
that tree arcs (those whose end is a tree node) are inclined downwards, while
hybridization arcs (those whose end is a hybrid node) are horizontal.
This package checks for time-consistency and, if so, a temporal representation
is provided.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 2
\& Gabriel Cardona, gabriel(dot)cardona(at)uib(dot)es
\& Gabriel Valiente, valiente(at)lsi(dot)upc(dot)edu
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "[\s-1CRV1\s0]" 4
.IX Item "[CRV1]"
G. Cardona, F. Rossello, G. Valiente. Tripartitions do not always
discriminate phylogenetic networks. arXiv:0707.2376v1 [q\-bio.PE]
.IP "[\s-1CRV2\s0]" 4
.IX Item "[CRV2]"
G. Cardona, F. Rossello, G. Valiente. A Distance Measure for
Tree-Child Phylogenetic Networks. Preprint.
.IP "[NetGen]" 4
.IX Item "[NetGen]"
M.M. Morin, and B.M.E. Moret. NetGen: generating phylogenetic networks
with diploid hybrids. Bioinformatics 22 (2006), 1921\-1923
.IP "[PhyloNet]" 4
.IX Item "[PhyloNet]"
PhyloNet: \*(L"Phylogenetic Networks Toolkit\*(R".
http://bioinfo.cs.rice.edu/phylonet
.IP "[\s-1BSS\s0]" 4
.IX Item "[BSS]"
M. Baroni, C. Semple, and M. Steel. Hybrids in Real
Time. Syst. Biol. 55(1):46\-56, 2006
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods.
.SS "new"
.IX Subsection "new"
.Vb 10
\& Title   : new
\& Usage   : my $obj = new Bio::PhyloNetwork();
\& Function: Creates a new Bio::PhyloNetwork object
\& Returns : Bio::PhyloNetwork
\& Args    : none
\&            OR
\&           \-eNewick => string
\&            OR
\&           \-graph => Graph::Directed object
\&            OR
\&           \-edges => reference to an array
\&            OR
\&           \-tree => Bio::Tree::Tree object
\&            OR
\&           \-mudata => reference to a hash,
\&           \-leaves => reference to an array
\&            OR
\&           \-mudata => reference to a hash,
\&           \-numleaves => integer
.Ve
.PP
Returns a Bio::PhyloNetwork object, created according to the data given:
.IP "\fInew()\fR" 3
.IX Item "new()"
creates an empty network.
.ie n .IP "new(\-eNewick => $str)" 3
.el .IP "new(\-eNewick => \f(CW$str\fR)" 3
.IX Item "new(-eNewick => $str)"
creates the network whose
Extended Newick representation (see description above) is the string \f(CW$str\fR.
.ie n .IP "new(\-graph => $graph)" 3
.el .IP "new(\-graph => \f(CW$graph\fR)" 3
.IX Item "new(-graph => $graph)"
creates the network with underlying
graph given by the Graph::Directed object \f(CW$graph\fR
.ie n .IP "new(\-tree => $tree)" 3
.el .IP "new(\-tree => \f(CW$tree\fR)" 3
.IX Item "new(-tree => $tree)"
creates a network as a copy of the
Bio::Tree::Tree object in \f(CW$tree\fR
.IP "new(\-mudata => \e%mudata, \-leaves => \e@leaves)" 3
.IX Item "new(-mudata => %mudata, -leaves => @leaves)"
creates the network by reconstructing it from its mu-data stored in
\&\e%mudata and with set of leaves in \e@leaves.
.ie n .IP "new(\-mudata => \e%mudata, \-numleaves => $numleaves)" 3
.el .IP "new(\-mudata => \e%mudata, \-numleaves => \f(CW$numleaves\fR)" 3
.IX Item "new(-mudata => %mudata, -numleaves => $numleaves)"
creates the network by reconstructing it from its mu-data stored in
\&\e%mudata and with set of leaves in (\*(L"l1\*(R"..\*(L"l$numleaves\*(R").
.SS "is_leaf"
.IX Subsection "is_leaf"
.Vb 5
\& Title   : is_leaf
\& Usage   : my $b=$net\->is_leaf($u)
\& Function: tests if $u is a leaf in $net
\& Returns : boolean
\& Args    : scalar
.Ve
.SS "is_root"
.IX Subsection "is_root"
.Vb 5
\& Title   : is_root
\& Usage   : my $b=$net\->is_root($u)
\& Function: tests if $u is the root of $net
\& Returns : boolean
\& Args    : scalar
.Ve
.SS "is_tree_node"
.IX Subsection "is_tree_node"
.Vb 5
\& Title   : is_tree_node
\& Usage   : my $b=$net\->is_tree_node($u)
\& Function: tests if $u is a tree node in $net
\& Returns : boolean
\& Args    : scalar
.Ve
.SS "is_hybrid_node"
.IX Subsection "is_hybrid_node"
.Vb 5
\& Title   : is_hybrid_node
\& Usage   : my $b=$net\->is_hybrid_node($u)
\& Function: tests if $u is a hybrid node in $net
\& Returns : boolean
\& Args    : scalar
.Ve
.SS "is_tree_child"
.IX Subsection "is_tree_child"
.Vb 5
\& Title   : is_tree_child
\& Usage   : my $b=$net\->is_tree_child()
\& Function: tests if $net is a Tree\-Child phylogenetic network
\& Returns : boolean
\& Args    : Bio::PhyloNetwork
.Ve
.SS "nodes"
.IX Subsection "nodes"
.Vb 5
\& Title   : nodes
\& Usage   : my @nodes=$net\->nodes()
\& Function: returns the set of nodes of $net
\& Returns : array
\& Args    : none
.Ve
.SS "leaves"
.IX Subsection "leaves"
.Vb 5
\& Title   : leaves
\& Usage   : my @leaves=$net\->leaves()
\& Function: returns the set of leaves of $net
\& Returns : array
\& Args    : none
.Ve
.SS "roots"
.IX Subsection "roots"
.Vb 5
\& Title   : roots
\& Usage   : my @roots=$net\->roots()
\& Function: returns the set of roots of $net
\& Returns : array
\& Args    : none
.Ve
.SS "internal_nodes"
.IX Subsection "internal_nodes"
.Vb 5
\& Title   : internal_nodes
\& Usage   : my @internal_nodes=$net\->internal_nodes()
\& Function: returns the set of internal nodes of $net
\& Returns : array
\& Args    : none
.Ve
.SS "tree_nodes"
.IX Subsection "tree_nodes"
.Vb 5
\& Title   : tree_nodes
\& Usage   : my @tree_nodes=$net\->tree_nodes()
\& Function: returns the set of tree nodes of $net
\& Returns : array
\& Args    : none
.Ve
.SS "hybrid_nodes"
.IX Subsection "hybrid_nodes"
.Vb 5
\& Title   : hybrid_nodes
\& Usage   : my @hybrid_nodes=$net\->hybrid_nodes()
\& Function: returns the set of hybrid nodes of $net
\& Returns : array
\& Args    : none
.Ve
.SS "graph"
.IX Subsection "graph"
.Vb 5
\& Title   : graph
\& Usage   : my $graph=$net\->graph()
\& Function: returns the underlying graph of $net
\& Returns : Graph::Directed
\& Args    : none
.Ve
.SS "edges"
.IX Subsection "edges"
.Vb 5
\& Title   : edges
\& Usage   : my @edges=$net\->edges()
\& Function: returns the set of edges of $net
\& Returns : array
\& Args    : none
.Ve
.PP
Each element in the array is an anonimous array whose first element is the
head of the edge and the second one is the tail.
.SS "tree_edges"
.IX Subsection "tree_edges"
.Vb 6
\& Title   : tree_edges
\& Usage   : my @tree_edges=$net\->tree_edges()
\& Function: returns the set of tree edges of $net
\&           (those whose tail is a tree node)
\& Returns : array
\& Args    : none
.Ve
.SS "hybrid_edges"
.IX Subsection "hybrid_edges"
.Vb 6
\& Title   : hybrid_edges
\& Usage   : my @hybrid_edges=$net\->hybrid_edges()
\& Function: returns the set of hybrid edges of $net
\&           (those whose tail is a hybrid node)
\& Returns : array
\& Args    : none
.Ve
.SS "explode"
.IX Subsection "explode"
.Vb 6
\& Title   : explode
\& Usage   : my @trees=$net\->explode()
\& Function: returns the representation of $net by a set of
\&           Bio::Tree:Tree objects
\& Returns : array
\& Args    : none
.Ve
.SS "mudata"
.IX Subsection "mudata"
.Vb 5
\& Title   : mudata
\& Usage   : my %mudata=$net\->mudata()
\& Function: returns the representation of $net by its mu\-data
\& Returns : hash
\& Args    : none
.Ve
.PP
\&\f(CW$net\fR\->\fImudata()\fR returns a hash with keys the nodes of \f(CW$net\fR and each value is a
muVector object holding its mu-vector.
.SS "heights"
.IX Subsection "heights"
.Vb 5
\& Title   : heights
\& Usage   : my %heights=$net\->heights()
\& Function: returns the heights of the nodes of $net
\& Returns : hash
\& Args    : none
.Ve
.PP
\&\f(CW$net\fR\->\fIheights()\fR returns a hash with keys the nodes of \f(CW$net\fR and each value
is its height.
.SS "mu_distance"
.IX Subsection "mu_distance"
.Vb 6
\& Title   : mu_distance
\& Usage   : my $dist=$net1\->mu_distance($net2)
\& Function: Computes the mu\-distance between the networks $net1 and $net2 on
\&           the same set of leaves
\& Returns : scalar
\& Args    : Bio::PhyloNetwork
.Ve
.SS "mu_distance_generalized"
.IX Subsection "mu_distance_generalized"
.Vb 6
\& Title   : mu_distance_generalized
\& Usage   : my $dist=$net1\->mu_distance($net2)
\& Function: Computes the mu\-distance between the topological restrictions of
\&           networks $net1 and $net2 on its common set of leaves
\& Returns : scalar
\& Args    : Bio::PhyloNetwork
.Ve
.SS "tripartitions"
.IX Subsection "tripartitions"
.Vb 5
\& Title   : tripartitions
\& Usage   : my %tripartitions=$net\->tripartitions()
\& Function: returns the set of tripartitions of $net
\& Returns : hash
\& Args    : none
.Ve
.PP
\&\f(CW$net\fR\->\fItripartitions()\fR returns a hash with keys the nodes of \f(CW$net\fR and each value
is a string representing the tripartition of the leaves induced by the node.
A string \*(L"\s-1BCA\s0...\*(R" associated with a node u (e.g.) means, the first leaf is in
the set B(u), the second one in C(u), the third one in A(u), and so on.
.SS "is_time_consistent"
.IX Subsection "is_time_consistent"
.Vb 5
\& Title   : is_time_consistent
\& Usage   : my $b=$net\->is_time_consistent()
\& Function: tests if $net is (strong) time\-consistent
\& Returns : boolean
\& Args    : none
.Ve
.SS "temporal_representation"
.IX Subsection "temporal_representation"
.Vb 6
\& Title   : temporal_representation
\& Usage   : my %time=$net\->temporal_representation()
\& Function: returns a hash containing a temporal representation of $net, or 0
\&           if $net is not time\-consistent
\& Returns : hash
\& Args    : none
.Ve
.SS "contract_elementary"
.IX Subsection "contract_elementary"
.Vb 8
\& Title   : contract_elementary
\& Usage   : my ($contracted,$blocks)=$net\->contract_elementary();
\& Function: Returns the network $contracted, obtained by contracting elementary
\&           paths of $net into edges. The reference $blocks points to a hash
\&           where, for each node of $contracted, gives the corresponding nodes
\&           of $net that have been deleted.
\& Returns : Bio::PhyloNetwork,reference to hash
\& Args    : none
.Ve
.SS "optimal_alignment"
.IX Subsection "optimal_alignment"
.Vb 10
\& Title   : optimal_alignment
\& Usage   : my ($weight,$alignment,$wgts)=$net\->optimal_alignment($net2)
\& Function: returns the total weight of an optimal alignment,
\&           the alignment itself, and partial weights
\&           between the networks $net1 and $net2 on the same set of leaves.
\&           An optional argument allows one to use the Manhattan (default) or the
\&           Hamming distance between mu\-vectors.
\& Returns : scalar,reference to hash,reference to hash
\& Args    : Bio::PhyloNetwork,
\&           \-metric => string (optional)
.Ve
.PP
Supported strings for the \-metric parameter are 'Manhattan' or 'Hamming'.
.SS "optimal_alignment_generalized"
.IX Subsection "optimal_alignment_generalized"
.Vb 10
\& Title   : optimal_alignment_generalized
\& Usage   : my ($weight,%alignment)=$net\->optimal_alignment_generalized($net2)
\& Function: returns the wieght of an optimal alignment, and the alignment itself,
\&           between the topological restriction of the networks $net1 and $net2
\&           on the set of common leaves.
\&           An optional argument allows one to use the Manhattan (default) or the
\&           Hamming distance between mu\-vectors.
\& Returns : scalar,hash
\& Args    : Bio::PhyloNetwork,
\&           \-metric => string (optional)
.Ve
.PP
Supported strings for the \-metric parameter are 'Manhattan' or 'Hamming'.
.SS "topological_restriction"
.IX Subsection "topological_restriction"
.Vb 6
\& Title   : topological_restriction
\& Usage   : my ($netr1,$netr2)=$net1\->topological_restriction($net2)
\& Function: returns the topological restriction of $net1 and $net2 on its
\&           common set of leaves
\& Returns : Bio::PhyloNetwork, Bio::PhyloNetwork
\& Args    : Bio::PhyloNetwork
.Ve
.SS "eNewick"
.IX Subsection "eNewick"
.Vb 6
\& Title   : eNewick
\& Usage   : my $str=$net\->eNewick()
\& Function: returns the eNewick representation of $net without labeling
\&           internal tree nodes
\& Returns : string
\& Args    : none
.Ve
.SS "eNewick_full"
.IX Subsection "eNewick_full"
.Vb 6
\& Title   : eNewick_full
\& Usage   : my $str=$net\->eNewick_full()
\& Function: returns the eNewick representation of $net labeling
\&           internal tree nodes
\& Returns : string
\& Args    : none
.Ve
.SS "display"
.IX Subsection "display"
.Vb 5
\& Title   : display
\& Usage   : my $str=$net\->display()
\& Function: returns a string containing all the available information on $net
\& Returns : string
\& Args    : none
.Ve
