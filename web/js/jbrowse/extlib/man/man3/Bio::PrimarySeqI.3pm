.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::PrimarySeqI 3"
.TH Bio::PrimarySeqI 3 "2013-05-09" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::PrimarySeqI \- Interface definition for a Bio::PrimarySeq
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    # Bio::PrimarySeqI is the interface class for sequences.
\&    # If you are a newcomer to bioperl, you might want to start with
\&    # Bio::Seq documentation.
\&
\&    # Test if this is a seq object
\&    $obj\->isa("Bio::PrimarySeqI") ||
\&      $obj\->throw("$obj does not implement the Bio::PrimarySeqI interface");
\&
\&    # Accessors
\&    $string    = $obj\->seq();
\&    $substring = $obj\->subseq(12,50);
\&    $display   = $obj\->display_id();       # for human display
\&    $id        = $obj\->primary_id();       # unique id for this object,
\&                                           # implementation defined
\&    $unique_key= $obj\->accession_number(); # unique biological id
\&
\&
\&    # Object manipulation
\&    eval {
\&           $rev = $obj\->revcom();
\&    };
\&    if( $@ ) {
\&           $obj\->throw("Could not reverse complement. ".
\&                    "Probably not DNA. Actual exception\en$@\en");
\&    }
\&
\&    $trunc = $obj\->trunc(12,50);
\&    # $rev and $trunc are Bio::PrimarySeqI compliant objects
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This object defines an abstract interface to basic sequence
information \- for most users of the package the documentation (and
methods) in this class are not useful \- this is a developers-only
class which defines what methods have to be implmented by other Perl
objects to comply to the Bio::PrimarySeqI interface. Go \*(L"perldoc
Bio::Seq\*(R" or \*(L"man Bio::Seq\*(R" for more information on the main class for
sequences.
.PP
PrimarySeq is an object just for the sequence and its name(s), nothing
more. Seq is the larger object complete with features. There is a pure
perl implementation of this in Bio::PrimarySeq. If you just want to
use Bio::PrimarySeq objects, then please read that module first. This
module defines the interface, and is of more interest to people who
want to wrap their own Perl Objects/RDBs/FileSystems etc in way that
they \*(L"are\*(R" bioperl sequence objects, even though it is not using Perl
to store the sequence etc.
.PP
This interface defines what bioperl considers necessary to \*(L"be\*(R" a
sequence, without providing an implementation of this, an
implementation is provided in Bio::PrimarySeq. If you want to provide
a Bio::PrimarySeq\-compliant object which in fact wraps another
object/database/out\-of\-perl experience, then this is the correct thing
to wrap, generally by providing a wrapper class which would inherit
from your object and this Bio::PrimarySeqI interface. The wrapper class
then would have methods lists in the \*(L"Implementation Specific
Functions\*(R" which would provide these methods for your object.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and
reponsive experts will be able look at the problem and quickly
address it. Please include a thorough description of the problem
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  https://redmine.open\-bio.org/projects/bioperl/
.Ve
.SH "AUTHOR \- Ewan Birney"
.IX Header "AUTHOR - Ewan Birney"
Email birney@ebi.ac.uk
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object
methods. Internal methods are usually preceded with a _
.SH "Implementation Specific Functions"
.IX Header "Implementation Specific Functions"
These functions are the ones that a specific implementation must
define.
.SS "seq"
.IX Subsection "seq"
.Vb 9
\& Title   : seq
\& Usage   : $string = $obj\->seq()
\& Function: Returns the sequence as a string of letters. The
\&           case of the letters is left up to the implementer.
\&           Suggested cases are upper case for proteins and lower case for
\&           DNA sequence (IUPAC standard), but implementations are suggested to
\&           keep an open mind about case (some users... want mixed case!)
\& Returns : A scalar
\& Status  : Virtual
.Ve
.SS "subseq"
.IX Subsection "subseq"
.Vb 5
\& Title   : subseq
\& Usage   : $substring = $obj\->subseq(10,40);
\& Function: Returns the subseq from start to end, where the first base
\&           is 1 and the number is inclusive, i.e. 1\-2 are the first two
\&           bases of the sequence.
\&
\&           Start cannot be larger than end but can be equal.
\&
\& Returns : A string
\& Args    :
\& Status  : Virtual
.Ve
.SS "display_id"
.IX Subsection "display_id"
.Vb 4
\& Title   : display_id
\& Usage   : $id_string = $obj\->display_id();
\& Function: Returns the display id, also known as the common name of the Sequence
\&           object.
\&
\&           The semantics of this is that it is the most likely string
\&           to be used as an identifier of the sequence, and likely to
\&           have "human" readability.  The id is equivalent to the ID
\&           field of the GenBank/EMBL databanks and the id field of the
\&           Swissprot/sptrembl database. In fasta format, the >(\eS+) is
\&           presumed to be the id, though some people overload the id
\&           to embed other information. Bioperl does not use any
\&           embedded information in the ID field, and people are
\&           encouraged to use other mechanisms (accession field for
\&           example, or extending the sequence object) to solve this.
\&
\&           Notice that $seq\->id() maps to this function, mainly for
\&           legacy/convenience reasons.
\& Returns : A string
\& Args    : None
\& Status  : Virtual
.Ve
.SS "accession_number"
.IX Subsection "accession_number"
.Vb 8
\& Title   : accession_number
\& Usage   : $unique_biological_key = $obj\->accession_number;
\& Function: Returns the unique biological id for a sequence, commonly
\&           called the accession_number. For sequences from established
\&           databases, the implementors should try to use the correct
\&           accession number. Notice that primary_id() provides the
\&           unique id for the implemetation, allowing multiple objects
\&           to have the same accession number in a particular implementation.
\&
\&           For sequences with no accession number, this method should return
\&           "unknown".
\& Returns : A string
\& Args    : None
\& Status  : Virtual
.Ve
.SS "primary_id"
.IX Subsection "primary_id"
.Vb 6
\& Title   : primary_id
\& Usage   : $unique_implementation_key = $obj\->primary_id;
\& Function: Returns the unique id for this object in this
\&           implementation. This allows implementations to manage their
\&           own object ids in a way the implementaiton can control
\&           clients can expect one id to map to one object.
\&
\&           For sequences with no accession number, this method should
\&           return a stringified memory location.
\&
\& Returns : A string
\& Args    : None
\& Status  : Virtual
.Ve
.SS "can_call_new"
.IX Subsection "can_call_new"
.Vb 9
\& Title   : can_call_new
\& Usage   : if( $obj\->can_call_new ) {
\&             $newobj = $obj\->new( %param );
\&         }
\& Function: Can_call_new returns 1 or 0 depending
\&           on whether an implementation allows new
\&           constructor to be called. If a new constructor
\&           is allowed, then it should take the followed hashed
\&           constructor list.
\&
\&           $myobject\->new( \-seq => $sequence_as_string,
\&                           \-display_id  => $id
\&                           \-accession_number => $accession
\&                           \-alphabet => \*(Aqdna\*(Aq,
\&                           );
\& Returns : 1 or 0
\& Args    :
.Ve
.SS "alphabet"
.IX Subsection "alphabet"
.Vb 4
\& Title   : alphabet
\& Usage   : if( $obj\->alphabet eq \*(Aqdna\*(Aq ) { /Do Something/ }
\& Function: Returns the type of sequence being one of
\&           \*(Aqdna\*(Aq, \*(Aqrna\*(Aq or \*(Aqprotein\*(Aq. This is case sensitive.
\&
\&           This is not called "type" because this would cause
\&           upgrade problems from the 0.5 and earlier Seq objects.
\&
\& Returns : A string either \*(Aqdna\*(Aq,\*(Aqrna\*(Aq,\*(Aqprotein\*(Aq. NB \- the object must
\&           make a call of the alphabet, if there is no alphabet specified it
\&           has to guess.
\& Args    : None
\& Status  : Virtual
.Ve
.SS "moltype"
.IX Subsection "moltype"
.Vb 2
\& Title   : moltype
\& Usage   : Deprecated. Use alphabet() instead.
.Ve
.SH "Optional Implementation Functions"
.IX Header "Optional Implementation Functions"
The following functions rely on the above functions. An
implementing class does not need to provide these functions, as they
will be provided by this class, but is free to override these
functions.
.PP
The \fIrevcom()\fR, \fItrunc()\fR, and \fItranslate()\fR methods create new sequence
objects. They will call \fInew()\fR on the class of the sequence object
instance passed as argument, unless \fIcan_call_new()\fR returns \s-1FALSE\s0. In
the latter case a Bio::PrimarySeq object will be created. Implementors
which really want to control how objects are created (eg, for object
persistence over a database, or objects in a \s-1CORBA\s0 framework), they
are encouraged to override these methods
.SS "revcom"
.IX Subsection "revcom"
.Vb 6
\& Title   : revcom
\& Usage   : $rev = $seq\->revcom()
\& Function: Produces a new Bio::PrimarySeqI implementing object which
\&           is the reversed complement of the sequence. For protein
\&           sequences this throws an exception of "Sequence is a
\&           protein. Cannot revcom".
\&
\&           The id is the same id as the original sequence, and the
\&           accession number is also indentical. If someone wants to
\&           track that this sequence has be reversed, it needs to
\&           define its own extensionsj.
\&
\&           To do an inplace edit of an object you can go:
\&
\&           $seq = $seq\->revcom();
\&
\&           This of course, causes Perl to handle the garbage
\&           collection of the old object, but it is roughly speaking as
\&           efficient as an inplace edit.
\&
\& Returns : A new (fresh) Bio::PrimarySeqI object
\& Args    : None
.Ve
.SS "trunc"
.IX Subsection "trunc"
.Vb 5
\& Title   : trunc
\& Usage   : $subseq = $myseq\->trunc(10,100);
\& Function: Provides a truncation of a sequence.
\& Returns : A fresh Bio::PrimarySeqI implementing object.
\& Args    : Two integers denoting first and last base of the sub\-sequence.
.Ve
.SS "translate"
.IX Subsection "translate"
.Vb 2
\& Title   : translate
\& Usage   : $protein_seq_obj = $dna_seq_obj\->translate
\&
\&           Or if you expect a complete coding sequence (CDS) translation,
\&           with initiator at the beginning and terminator at the end:
\&
\&           $protein_seq_obj = $cds_seq_obj\->translate(\-complete => 1);
\&
\&           Or if you want translate() to find the first initiation
\&           codon and return the corresponding protein:
\&
\&           $protein_seq_obj = $cds_seq_obj\->translate(\-orf => 1);
\&
\& Function: Provides the translation of the DNA sequence using full
\&           IUPAC ambiguities in DNA/RNA and amino acid codes.
\&
\&           The complete CDS translation is identical to EMBL/TREMBL
\&           database translation. Note that the trailing terminator
\&           character is removed before returning the translated protein
\&           object.
\&
\&           Note: if you set $dna_seq_obj\->verbose(1) you will get a
\&           warning if the first codon is not a valid initiator.
\&
\& Returns : A Bio::PrimarySeqI implementing object
\& Args    : \-terminator
\&               character for terminator, default \*(Aq*\*(Aq
\&           \-unknown
\&               character for unknown, default \*(AqX\*(Aq
\&           \-frame
\&               positive integer frame shift (in bases), default 0
\&           \-codontable_id
\&               integer codon table id, default 1
\&           \-complete
\&               boolean, if true, complete CDS is expected. default false
\&           \-complete_codons
\&               boolean, if true, codons which are incomplete are translated if a
\&               suitable amino acid is found. For instance, if the incomplete
\&               codon is \*(AqGG\*(Aq, the completed codon is \*(AqGGN\*(Aq, which is glycine
\&               (G). Defaults to \*(Aqfalse\*(Aq; setting \*(Aq\-complete\*(Aq also makes this
\&               true.
\&           \-throw
\&               boolean, throw exception if ORF not complete, default false
\&           \-orf
\&               if \*(Aqlongest\*(Aq, find longest ORF.  other true value, find
\&               first ORF.  default 0
\&           \-codontable
\&               optional L<Bio::Tools::CodonTable> object to use for
\&               translation
\&           \-start
\&               optional three\-character string to force as initiation
\&               codon (e.g. \*(Aqatg\*(Aq). If unset, start codons are
\&               determined by the CodonTable.  Case insensitive.
\&           \-offset
\&               optional positive integer offset for fuzzy locations.
\&               if set, must be either 1, 2, or 3
.Ve
.PP
\fINotes\fR
.IX Subsection "Notes"
.PP
The \-start argument only applies when \-orf is set to 1. By default all
initiation codons found in the given codon table are used but when
\&\*(L"start\*(R" is set to some codon this codon will be used exclusively as
the initiation codon. Note that the default codon table (\s-1NCBI\s0
\&\*(L"Standard\*(R") has 3 initiation codons!
.PP
By default \fItranslate()\fR translates termination codons to the some
character (default is *), both internal and trailing codons. Setting
\&\*(L"\-complete\*(R" to 1 tells \fItranslate()\fR to remove the trailing character.
.PP
\&\-offset is used for seqfeatures which contain the the \ecodon_start tag
and can be set to 1, 2, or 3.  This is the offset by which the
sequence translation starts relative to the first base of the feature
.PP
For details on codon tables used by \fItranslate()\fR see Bio::Tools::CodonTable.
.PP
Deprecated argument set (v. 1.5.1 and prior versions) where each argument is an
element in an array:
.PP
.Vb 8
\&  1: character for terminator (optional), defaults to \*(Aq*\*(Aq.
\&  2: character for unknown amino acid (optional), defaults to \*(AqX\*(Aq.
\&  3: frame (optional), valid values are 0, 1, 2, defaults to 0.
\&  4: codon table id (optional), defaults to 1.
\&  5: complete coding sequence expected, defaults to 0 (false).
\&  6: boolean, throw exception if not complete coding sequence
\&     (true), defaults to warning (false)
\&  7: codontable, a custom Bio::Tools::CodonTable object (optional).
.Ve
.SS "\fItranscribe()\fP"
.IX Subsection "transcribe()"
.Vb 6
\& Title   : transcribe
\& Usage   : $xseq = $seq\->transcribe
\& Function: Convert base T to base U
\& Returns : PrimarySeqI object of alphabet \*(Aqrna\*(Aq or
\&           undef if $seq\->alphabet ne \*(Aqdna\*(Aq
\& Args    :
.Ve
.SS "\fIrev_transcribe()\fP"
.IX Subsection "rev_transcribe()"
.Vb 6
\& Title   : rev_transcribe
\& Usage   : $rtseq = $seq\->rev_transcribe
\& Function: Convert base U to base T
\& Returns : PrimarySeqI object of alphabet \*(Aqdna\*(Aq or
\&           undef if $seq\->alphabet ne \*(Aqrna\*(Aq
\& Args    :
.Ve
.SS "id"
.IX Subsection "id"
.Vb 6
\& Title   : id
\& Usage   : $id = $seq\->id()
\& Function: ID of the sequence. This should normally be (and actually is in
\&           the implementation provided here) just a synonym for display_id().
\& Returns : A string.
\& Args    :
.Ve
.SS "length"
.IX Subsection "length"
.Vb 5
\& Title   : length
\& Usage   : $len = $seq\->length()
\& Function:
\& Returns : Integer representing the length of the sequence.
\& Args    :
.Ve
.SS "desc"
.IX Subsection "desc"
.Vb 6
\& Title   : desc
\& Usage   : $seq\->desc($newval);
\&           $description = $seq\->desc();
\& Function: Get/set description text for a seq object
\& Returns : Value of desc
\& Args    : newvalue (optional)
.Ve
.SS "is_circular"
.IX Subsection "is_circular"
.Vb 5
\& Title   : is_circular
\& Usage   : if( $obj\->is_circular) { /Do Something/ }
\& Function: Returns true if the molecule is circular
\& Returns : Boolean value
\& Args    : none
.Ve
.SH "Private functions"
.IX Header "Private functions"
These are some private functions for the PrimarySeqI interface. You do not
need to implement these functions
.SS "_find_orfs_nucleotide"
.IX Subsection "_find_orfs_nucleotide"
.Vb 10
\& Title   : _find_orfs_nucleotide
\& Usage   :
\& Function: Finds ORF starting at 1st initiation codon in nucleotide sequence.
\&           The ORF is not required to have a termination codon.
\& Example :
\& Returns : a list of string coordinates of ORF locations (0\-based half\-open),
\&           sorted descending by length (so that the longest is first)
\&           as: [ start, end, frame, length ], [ start, end, frame, length ], ...
\& Args    : Nucleotide sequence,
\&           CodonTable object,
\&           (optional) alternative initiation codon (e.g. \*(AqATA\*(Aq),
\&           (optional) boolean that, if true, stops after finding the
\&                      first available ORF
.Ve
.SS "_attempt_to_load_Seq"
.IX Subsection "_attempt_to_load_Seq"
.Vb 6
\& Title   : _attempt_to_load_Seq
\& Usage   :
\& Function:
\& Example :
\& Returns :
\& Args    :
.Ve
