.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::SimpleAlign 3"
.TH Bio::SimpleAlign 3 "2013-05-09" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::SimpleAlign \- Multiple alignments held as a set of sequences
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  # Use Bio::AlignIO to read in the alignment
\&  $str = Bio::AlignIO\->new(\-file => \*(Aqt/data/testaln.pfam\*(Aq);
\&  $aln = $str\->next_aln();
\&
\&  # Describe
\&  print $aln\->length;
\&  print $aln\->num_residues;
\&  print $aln\->is_flush;
\&  print $aln\->num_sequences;
\&  print $aln\->score;
\&  print $aln\->percentage_identity;
\&  print $aln\->consensus_string(50);
\&
\&  # Find the position in the alignment for a sequence location
\&  $pos = $aln\->column_from_residue_number(\*(Aq1433_LYCES\*(Aq, 14); # = 6;
\&
\&  # Extract sequences and check values for the alignment column $pos
\&  foreach $seq ($aln\->each_seq) {
\&      $res = $seq\->subseq($pos, $pos);
\&      $count{$res}++;
\&  }
\&  foreach $res (keys %count) {
\&      printf "Res: %s  Count: %2d\en", $res, $count{$res};
\&  }
\&
\&  # Manipulate
\&  $aln\->remove_seq($seq);
\&  $mini_aln = $aln\->slice(20,30);  # get a block of columns
\&  $mini_aln = $aln\->select_noncont(1,3,5,7,11); # select certain sequences
\&  $new_aln = $aln\->remove_columns([20,30]); # remove by position
\&  $new_aln = $aln\->remove_columns([\*(Aqmismatch\*(Aq]); # remove by property
\&
\&  # Analyze
\&  $str = $aln\->consensus_string($threshold_percent);
\&  $str = $aln\->match_line();
\&  $str = $aln\->cigar_line();
\&  $id = $aln\->percentage_identity;
\&
\&  # See the module documentation for details and more methods.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
SimpleAlign is an object that handles a multiple sequence alignment
(\s-1MSA\s0). It is very permissive of types (it does not insist on sequences
being all same length, for example). Think of it as a set of sequences
with a whole series of built-in manipulations and methods for reading and
writing alignments.
.PP
SimpleAlign uses Bio::LocatableSeq, a subclass of Bio::PrimarySeq,
to store its sequences. These are subsequences with a start and end
positions in the parent reference sequence. Each sequence in the
SimpleAlign object is a Bio::LocatableSeq.
.PP
SimpleAlign expects the combination of name, start, and end for a
given sequence to be unique in the alignment, and this is the key for the
internal hashes (name, start, end are abbreviated \f(CW\*(C`nse\*(C'\fR in the code).
However, in some cases people do not want the name/start\-end to be displayed:
either multiple names in an alignment or names specific to the alignment
(\s-1ROA1_HUMAN_1\s0, \s-1ROA1_HUMAN_2\s0 etc). These names are called
\&\f(CW\*(C`displayname\*(C'\fR, and generally is what is used to print out the
alignment. They default to name/start\-end.
.PP
The SimpleAlign Module is derived from the Align module by Ewan Birney.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules.  Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution. Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  https://redmine.open\-bio.org/projects/bioperl/
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Ewan Birney, birney@ebi.ac.uk
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Allen Day, allenday\-at\-ucla.edu,
Richard Adams, Richard.Adams\-at\-ed.ac.uk,
David J. Evans, David.Evans\-at\-vir.gla.ac.uk,
Heikki Lehvaslaiho, heikki-at-bioperl-dot-org,
Allen Smith, allens\-at\-cpan.org,
Jason Stajich, jason\-at\-bioperl.org,
Anthony Underwood, aunderwood\-at\-phls.org.uk,
Xintao Wei & Giri Narasimhan, giri\-at\-cs.fiu.edu
Brian Osborne, bosborne at alum.mit.edu
Weigang Qiu, Weigang at GENECTR-HUNTER-CUNY-EDU
Hongyu Zhang, forward at hongyu.org
Jay Hannah, jay at jays.net
Alexandr Bezginov, albezg at gmail.com
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Bio::LocatableSeq
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object
methods. Internal methods are usually preceded with a _
.SS "new"
.IX Subsection "new"
.Vb 11
\& Title     : new
\& Usage     : my $aln = Bio::SimpleAlign\->new();
\& Function  : Creates a new simple align object
\& Returns   : Bio::SimpleAlign
\& Args      : \-source     => string representing the source program
\&                            where this alignment came from
\&             \-annotation => Bio::AnnotationCollectionI
\&             \-seq_annotation => Bio::AnnotationCollectionI for sequences (requires \-annotation also be set)
\&             \-seqs       => array ref containing Bio::LocatableSeq or Bio::Seq::Meta
\&             \-consensus  => consensus string
\&             \-consensus_meta  => Bio::Seq::Meta object containing consensus met information (kludge)
.Ve
.SH "Modifier methods"
.IX Header "Modifier methods"
These methods modify the \s-1MSA\s0 by adding, removing or shuffling complete
sequences.
.SS "add_seq"
.IX Subsection "add_seq"
.Vb 11
\& Title     : add_seq
\& Usage     : $myalign\->add_seq($newseq);
\&             $myalign\->add_seq(\-SEQ=>$newseq, \-ORDER=>5);
\& Function  : Adds another sequence to the alignment. *Does not* align
\&             it \- just adds it to the hashes.
\&             If \-ORDER is specified, the sequence is inserted at the
\&             the position spec\*(Aqd by \-ORDER, and existing sequences
\&             are pushed down the storage array.
\& Returns   : nothing
\& Args      : A Bio::LocatableSeq object
\&             Positive integer for the sequence position (optional)
.Ve
.PP
See Bio::LocatableSeq for more information
.SS "remove_seq"
.IX Subsection "remove_seq"
.Vb 5
\& Title     : remove_seq
\& Usage     : $aln\->remove_seq($seq);
\& Function  : Removes a single sequence from an alignment
\& Returns   :
\& Argument  : a Bio::LocatableSeq object
.Ve
.SS "purge"
.IX Subsection "purge"
.Vb 7
\& Title   : purge
\& Usage   : $aln\->purge(0.7);
\& Function: Removes sequences above given sequence similarity
\&           This function will grind on large alignments. Beware!
\& Example :
\& Returns : An array of the removed sequences
\& Args    : float, threshold for similarity
.Ve
.SS "sort_alphabetically"
.IX Subsection "sort_alphabetically"
.Vb 6
\& Title     : sort_alphabetically
\& Usage     : $ali\->sort_alphabetically
\& Function  : Changes the order of the alignment to alphabetical on name
\&             followed by numerical by number.
\& Returns   :
\& Argument  :
.Ve
.SS "sort_by_list"
.IX Subsection "sort_by_list"
.Vb 5
\& Title     : sort_by_list
\& Usage     : $aln_ordered=$aln\->sort_by_list($list_file)
\& Function  : Arbitrarily order sequences in an alignment
\& Returns   : A new Bio::SimpleAlign object
\& Argument  : a file listing sequence names in intended order (one name per line)
.Ve
.SS "set_new_reference"
.IX Subsection "set_new_reference"
.Vb 9
\& Title     : set_new_reference
\& Usage     : $aln\->set_new_reference(3 or \*(AqB31\*(Aq):  Select the 3rd sequence, or
\&             the sequence whoes name is "B31" (full, exact, and case\-sensitive),
\&             as the reference (1st) sequence
\& Function  : Change/Set a new reference (i.e., the first) sequence
\& Returns   : a new Bio::SimpleAlign object.
\&             Throws an exception if designated sequence not found
\& Argument  : a positive integer of sequence order, or a sequence name
\&             in the original alignment
.Ve
.SS "uniq_seq"
.IX Subsection "uniq_seq"
.Vb 10
\& Title     : uniq_seq
\& Usage     : $aln\->uniq_seq():  Remove identical sequences in
\&             in the alignment.  Ambiguous base ("N", "n") and
\&             leading and ending gaps ("\-") are NOT counted as
\&             differences.
\& Function  : Make a new alignment of unique sequence types (STs)
\& Returns   : 1a. if called in a scalar context, 
\&                a new Bio::SimpleAlign object (all sequences renamed as "ST")
\&             1b. if called in an array context, 
\&                a new Bio::SimpleAlign object, and a hashref whose keys
\&                are sequence types, and whose values are arrayrefs to 
\&                lists of sequence ids within the corresponding sequence type
\&             2. if $aln\->verbose > 0, ST of each sequence is sent to 
\&                STDERR (in a tabular format)
\& Argument  : None
.Ve
.SH "Sequence selection methods"
.IX Header "Sequence selection methods"
Methods returning one or more sequences objects.
.SS "each_seq"
.IX Subsection "each_seq"
.Vb 5
\& Title     : each_seq
\& Usage     : foreach $seq ( $align\->each_seq() )
\& Function  : Gets a Seq object from the alignment
\& Returns   : Seq object
\& Argument  :
.Ve
.SS "each_alphabetically"
.IX Subsection "each_alphabetically"
.Vb 7
\& Title     : each_alphabetically
\& Usage     : foreach $seq ( $ali\->each_alphabetically() )
\& Function  : Returns a sequence object, but the objects are returned
\&             in alphabetically sorted order.
\&             Does not change the order of the alignment.
\& Returns   : Seq object
\& Argument  :
.Ve
.SS "each_seq_with_id"
.IX Subsection "each_seq_with_id"
.Vb 7
\& Title     : each_seq_with_id
\& Usage     : foreach $seq ( $align\->each_seq_with_id() )
\& Function  : Gets a Seq objects from the alignment, the contents
\&             being those sequences with the given name (there may be
\&             more than one)
\& Returns   : Seq object
\& Argument  : a seq name
.Ve
.SS "get_seq_by_pos"
.IX Subsection "get_seq_by_pos"
.Vb 7
\& Title     : get_seq_by_pos
\& Usage     : $seq = $aln\->get_seq_by_pos(3) # third sequence from the alignment
\& Function  : Gets a sequence based on its position in the alignment.
\&             Numbering starts from 1.  Sequence positions larger than
\&             num_sequences() will thow an error.
\& Returns   : a Bio::LocatableSeq object
\& Args      : positive integer for the sequence position
.Ve
.SS "get_seq_by_id"
.IX Subsection "get_seq_by_id"
.Vb 6
\& Title     : get_seq_by_id
\& Usage     : $seq = $aln\->get_seq_by_id($name) # seq named $name
\& Function  : Gets a sequence based on its name.
\&             Sequences that do not exist will warn and return undef
\& Returns   : a Bio::LocatableSeq object
\& Args      : string for sequence name
.Ve
.SS "seq_with_features"
.IX Subsection "seq_with_features"
.Vb 5
\& Title   : seq_with_features
\& Usage   : $seq = $aln\->seq_with_features(\-pos => 1,
\&                                          \-consensus => 60
\&                                          \-mask =>
\&           sub { my $consensus = shift;
\&
\&                 for my $i (1..5){
\&                    my $n = \*(AqN\*(Aq x $i;
\&                    my $q = \*(Aq\e?\*(Aq x $i;
\&                    while($consensus =~ /[^?]$q[^?]/){
\&                       $consensus =~ s/([^?])$q([^?])/$1$n$2/;
\&                    }
\&                  }
\&                 return $consensus;
\&               }
\&                                         );
\& Function: produces a Bio::Seq object by first splicing gaps from \-pos
\&           (by means of a splice_by_seq_pos() call), then creating
\&           features using non\-? chars (by means of a consensus_string()
\&           call with stringency \-consensus).
\& Returns : a Bio::Seq object
\& Args    : \-pos : required. sequence from which to build the Bio::Seq
\&             object
\&           \-consensus : optional, defaults to consensus_string()\*(Aqs
\&             default cutoff value
\&           \-mask : optional, a coderef to apply to consensus_string()\*(Aqs
\&             output before building features.  this may be useful for
\&             closing gaps of 1 bp by masking over them with N, for
\&             instance
.Ve
.SH "Create new alignments"
.IX Header "Create new alignments"
The result of these methods are horizontal or vertical subsets of the
current \s-1MSA\s0.
.SS "select"
.IX Subsection "select"
.Vb 8
\& Title     : select
\& Usage     : $aln2 = $aln\->select(1, 3) # three first sequences
\& Function  : Creates a new alignment from a continuous subset of
\&             sequences.  Numbering starts from 1.  Sequence positions
\&             larger than num_sequences() will thow an error.
\& Returns   : a Bio::SimpleAlign object
\& Args      : positive integer for the first sequence
\&             positive integer for the last sequence to include (optional)
.Ve
.SS "select_noncont"
.IX Subsection "select_noncont"
.Vb 3
\& Title     : select_noncont
\& Usage     : # 1st and 3rd sequences, sorted
\&             $aln2 = $aln\->select_noncont(1, 3)
\&
\&             # 1st and 3rd sequences, sorted (same as first)
\&             $aln2 = $aln\->select_noncont(3, 1)
\&
\&             # 1st and 3rd sequences, unsorted
\&             $aln2 = $aln\->select_noncont(\*(Aqnosort\*(Aq,3, 1)
\&
\& Function  : Creates a new alignment from a subset of sequences.  Numbering
\&             starts from 1.  Sequence positions larger than num_sequences() will
\&             throw an error.  Sorts the order added to new alignment by default,
\&             to prevent sorting pass \*(Aqnosort\*(Aq as the first argument in the list.
\& Returns   : a Bio::SimpleAlign object
\& Args      : array of integers for the sequences.  If the string \*(Aqnosort\*(Aq is
\&             passed as the first argument, the sequences will not be sorted
\&             in the new alignment but will appear in the order listed.
.Ve
.SS "slice"
.IX Subsection "slice"
.Vb 11
\& Title     : slice
\& Usage     : $aln2 = $aln\->slice(20,30)
\& Function  : Creates a slice from the alignment inclusive of start and
\&             end columns, and the first column in the alignment is denoted 1.
\&             Sequences with no residues in the slice are excluded from the
\&             new alignment and a warning is printed. Slice beyond the length of
\&             the sequence does not do padding.
\& Returns   : A Bio::SimpleAlign object
\& Args      : Positive integer for start column, positive integer for end column,
\&             optional boolean which if true will keep gap\-only columns in the newly
\&             created slice. Example:
\&
\&             $aln2 = $aln\->slice(20,30,1)
.Ve
.SS "remove_columns"
.IX Subsection "remove_columns"
.Vb 10
\& Title     : remove_columns
\& Usage     : $aln2 = $aln\->remove_columns([\*(Aqmismatch\*(Aq,\*(Aqweak\*(Aq]) or
\&             $aln2 = $aln\->remove_columns([0,0],[6,8])
\& Function  : Creates an aligment with columns removed corresponding to
\&             the specified type or by specifying the columns by number.
\& Returns   : Bio::SimpleAlign object
\& Args      : Array ref of types (\*(Aqmatch\*(Aq|\*(Aqweak\*(Aq|\*(Aqstrong\*(Aq|\*(Aqmismatch\*(Aq|\*(Aqgaps\*(Aq|
\&             \*(Aqall_gaps_columns\*(Aq) or array ref where the referenced array
\&             contains a pair of integers that specify a range.
\&             The first column is 0
.Ve
.SS "remove_gaps"
.IX Subsection "remove_gaps"
.Vb 8
\& Title     : remove_gaps
\& Usage     : $aln2 = $aln\->remove_gaps
\& Function  : Creates an aligment with gaps removed
\& Returns   : a Bio::SimpleAlign object
\& Args      : a gap character(optional) if none specified taken
\&                from $self\->gap_char,
\&             [optional] $all_gaps_columns flag (1 or 0, default is 0)
\&                        indicates that only all\-gaps columns should be deleted
.Ve
.PP
Used from method remove_columns in most cases. Set gap character
using \fIgap_char()\fR.
.SH "Change sequences within the MSA"
.IX Header "Change sequences within the MSA"
These methods affect characters in all sequences without changing the
alignment.
.SS "splice_by_seq_pos"
.IX Subsection "splice_by_seq_pos"
.Vb 7
\& Title   : splice_by_seq_pos
\& Usage   : $status = splice_by_seq_pos(1);
\& Function: splices all aligned sequences where the specified sequence
\&           has gaps.
\& Example :
\& Returns : 1 on success
\& Args    : position of sequence to splice by
.Ve
.SS "map_chars"
.IX Subsection "map_chars"
.Vb 4
\& Title     : map_chars
\& Usage     : $ali\->map_chars(\*(Aq\e.\*(Aq,\*(Aq\-\*(Aq)
\& Function  : Does a s/$arg1/$arg2/ on the sequences. Useful for gap
\&             characters
\&
\&             Notice that the from (arg1) is interpretted as a regex,
\&             so be careful about quoting meta characters (eg
\&             $ali\->map_chars(\*(Aq.\*(Aq,\*(Aq\-\*(Aq) wont do what you want)
\& Returns   :
\& Argument  : \*(Aqfrom\*(Aq rexexp
\&             \*(Aqto\*(Aq string
.Ve
.SS "uppercase"
.IX Subsection "uppercase"
.Vb 5
\& Title     : uppercase()
\& Usage     : $ali\->uppercase()
\& Function  : Sets all the sequences to uppercase
\& Returns   :
\& Argument  :
.Ve
.SS "cigar_line"
.IX Subsection "cigar_line"
.Vb 9
\& Title    : cigar_line()
\& Usage    : %cigars = $align\->cigar_line()
\& Function : Generates a "cigar" (Compact Idiosyncratic Gapped Alignment
\&            Report) line for each sequence in the alignment. Examples are
\&            "1,60" or "5,10:12,58", where the numbers refer to conserved
\&            positions within the alignment. The keys of the hash are the
\&            NSEs (name/start/end) assigned to each sequence.
\& Args     : threshold (optional, defaults to 100)
\& Returns  : Hash of strings (cigar lines)
.Ve
.SS "match_line"
.IX Subsection "match_line"
.Vb 8
\& Title    : match_line()
\& Usage    : $line = $align\->match_line()
\& Function : Generates a match line \- much like consensus string
\&            except that a line indicating the \*(Aq*\*(Aq for a match.
\& Args     : (optional) Match line characters (\*(Aq*\*(Aq by default)
\&            (optional) Strong match char (\*(Aq:\*(Aq by default)
\&            (optional) Weak match char (\*(Aq.\*(Aq by default)
\& Returns  : String
.Ve
.SS "gap_line"
.IX Subsection "gap_line"
.Vb 6
\& Title    : gap_line()
\& Usage    : $line = $align\->gap_line()
\& Function : Generates a gap line \- much like consensus string
\&            except that a line where \*(Aq\-\*(Aq represents gap
\& Args     : (optional) gap line characters (\*(Aq\-\*(Aq by default)
\& Returns  : string
.Ve
.SS "all_gap_line"
.IX Subsection "all_gap_line"
.Vb 6
\& Title    : all_gap_line()
\& Usage    : $line = $align\->all_gap_line()
\& Function : Generates a gap line \- much like consensus string
\&            except that a line where \*(Aq\-\*(Aq represents all\-gap column
\& Args     : (optional) gap line characters (\*(Aq\-\*(Aq by default)
\& Returns  : string
.Ve
.SS "gap_col_matrix"
.IX Subsection "gap_col_matrix"
.Vb 7
\& Title    : gap_col_matrix()
\& Usage    : my $cols = $align\->gap_col_matrix()
\& Function : Generates an array of hashes where
\&            each entry in the array is a hash reference
\&            with keys of all the sequence names and
\&            and value of 1 or 0 if the sequence has a gap at that column
\& Args     : (optional) gap line characters ($aln\->gap_char or \*(Aq\-\*(Aq by default)
.Ve
.SS "match"
.IX Subsection "match"
.Vb 5
\& Title     : match()
\& Usage     : $ali\->match()
\& Function  : Goes through all columns and changes residues that are
\&             identical to residue in first sequence to match \*(Aq.\*(Aq
\&             character. Sets match_char.
\&
\&             USE WITH CARE: Most MSA formats do not support match
\&             characters in sequences, so this is mostly for output
\&             only. NEXUS format (Bio::AlignIO::nexus) can handle
\&             it.
\& Returns   : 1
\& Argument  : a match character, optional, defaults to \*(Aq.\*(Aq
.Ve
.SS "unmatch"
.IX Subsection "unmatch"
.Vb 5
\& Title     : unmatch()
\& Usage     : $ali\->unmatch()
\& Function  : Undoes the effect of method match. Unsets match_char.
\& Returns   : 1
\& Argument  : a match character, optional, defaults to \*(Aq.\*(Aq
.Ve
.PP
See match and match_char
.SH "MSA attributes"
.IX Header "MSA attributes"
Methods for setting and reading the \s-1MSA\s0 attributes.
.PP
Note that the methods defining character semantics depend on the user
to set them sensibly.  They are needed only by certain input/output
methods. Unset them by setting to an empty string ('').
.SS "id"
.IX Subsection "id"
.Vb 5
\& Title     : id
\& Usage     : $myalign\->id("Ig")
\& Function  : Gets/sets the id field of the alignment
\& Returns   : An id string
\& Argument  : An id string (optional)
.Ve
.SS "accession"
.IX Subsection "accession"
.Vb 5
\& Title     : accession
\& Usage     : $myalign\->accession("PF00244")
\& Function  : Gets/sets the accession field of the alignment
\& Returns   : An acc string
\& Argument  : An acc string (optional)
.Ve
.SS "description"
.IX Subsection "description"
.Vb 5
\& Title     : description
\& Usage     : $myalign\->description("14\-3\-3 proteins")
\& Function  : Gets/sets the description field of the alignment
\& Returns   : An description string
\& Argument  : An description string (optional)
.Ve
.SS "missing_char"
.IX Subsection "missing_char"
.Vb 7
\& Title     : missing_char
\& Usage     : $myalign\->missing_char("?")
\& Function  : Gets/sets the missing_char attribute of the alignment
\&             It is generally recommended to set it to \*(Aqn\*(Aq or \*(AqN\*(Aq
\&             for nucleotides and to \*(AqX\*(Aq for protein.
\& Returns   : An missing_char string,
\& Argument  : An missing_char string (optional)
.Ve
.SS "match_char"
.IX Subsection "match_char"
.Vb 5
\& Title     : match_char
\& Usage     : $myalign\->match_char(\*(Aq.\*(Aq)
\& Function  : Gets/sets the match_char attribute of the alignment
\& Returns   : An match_char string,
\& Argument  : An match_char string (optional)
.Ve
.SS "gap_char"
.IX Subsection "gap_char"
.Vb 5
\& Title     : gap_char
\& Usage     : $myalign\->gap_char(\*(Aq\-\*(Aq)
\& Function  : Gets/sets the gap_char attribute of the alignment
\& Returns   : An gap_char string, defaults to \*(Aq\-\*(Aq
\& Argument  : An gap_char string (optional)
.Ve
.SS "symbol_chars"
.IX Subsection "symbol_chars"
.Vb 5
\& Title   : symbol_chars
\& Usage   : my @symbolchars = $aln\->symbol_chars;
\& Function: Returns all the seen symbols (other than gaps)
\& Returns : array of characters that are the seen symbols
\& Args    : boolean to include the gap/missing/match characters
.Ve
.SH "Alignment descriptors"
.IX Header "Alignment descriptors"
These read only methods describe the \s-1MSA\s0 in various ways.
.SS "score"
.IX Subsection "score"
.Vb 5
\& Title     : score
\& Usage     : $str = $ali\->score()
\& Function  : get/set a score of the alignment
\& Returns   : a score for the alignment
\& Argument  : an optional score to set
.Ve
.SS "consensus_string"
.IX Subsection "consensus_string"
.Vb 9
\& Title     : consensus_string
\& Usage     : $str = $ali\->consensus_string($threshold_percent)
\& Function  : Makes a strict consensus
\& Returns   : Consensus string
\& Argument  : Optional threshold ranging from 0 to 100.
\&             The consensus residue has to appear at least threshold %
\&             of the sequences at a given location, otherwise a \*(Aq?\*(Aq
\&             character will be placed at that location.
\&             (Default value = 0%)
.Ve
.SS "consensus_iupac"
.IX Subsection "consensus_iupac"
.Vb 5
\& Title     : consensus_iupac
\& Usage     : $str = $ali\->consensus_iupac()
\& Function  : Makes a consensus using IUPAC ambiguity codes from DNA
\&             and RNA. The output is in upper case except when gaps in
\&             a column force output to be in lower case.
\&
\&             Note that if your alignment sequences contain a lot of
\&             IUPAC ambiquity codes you often have to manually set
\&             alphabet.  Bio::PrimarySeq::_guess_type thinks they
\&             indicate a protein sequence.
\& Returns   : consensus string
\& Argument  : none
\& Throws    : on protein sequences
.Ve
.SS "consensus_meta"
.IX Subsection "consensus_meta"
.Vb 7
\& Title     : consensus_meta
\& Usage     : $seqmeta = $ali\->consensus_meta()
\& Function  : Returns a Bio::Seq::Meta object containing the consensus
\&             strings derived from meta data analysis.
\& Returns   : Bio::Seq::Meta 
\& Argument  : Bio::Seq::Meta 
\& Throws    : non\-MetaI object
.Ve
.SS "is_flush"
.IX Subsection "is_flush"
.Vb 6
\& Title     : is_flush
\& Usage     : if ( $ali\->is_flush() )
\& Function  : Tells you whether the alignment
\&           : is flush, i.e. all of the same length
\& Returns   : 1 or 0
\& Argument  :
.Ve
.SS "length"
.IX Subsection "length"
.Vb 6
\& Title     : length()
\& Usage     : $len = $ali\->length()
\& Function  : Returns the maximum length of the alignment.
\&             To be sure the alignment is a block, use is_flush
\& Returns   : Integer
\& Argument  :
.Ve
.SS "maxdisplayname_length"
.IX Subsection "maxdisplayname_length"
.Vb 6
\& Title     : maxdisplayname_length
\& Usage     : $ali\->maxdisplayname_length()
\& Function  : Gets the maximum length of the displayname in the
\&             alignment. Used in writing out various MSA formats.
\& Returns   : integer
\& Argument  :
.Ve
.SS "max_metaname_length"
.IX Subsection "max_metaname_length"
.Vb 7
\& Title     : max_metaname_length
\& Usage     : $ali\->max_metaname_length()
\& Function  : Gets the maximum length of the meta name tags in the
\&             alignment for the sequences and for the alignment.
\&             Used in writing out various MSA formats.
\& Returns   : integer
\& Argument  : None
.Ve
.SS "num_residues"
.IX Subsection "num_residues"
.Vb 6
\& Title     : num_residues
\& Usage     : $no = $ali\->num_residues
\& Function  : number of residues in total in the alignment
\& Returns   : integer
\& Argument  :
\& Note      : replaces no_residues()
.Ve
.SS "num_sequences"
.IX Subsection "num_sequences"
.Vb 6
\& Title     : num_sequences
\& Usage     : $depth = $ali\->num_sequences
\& Function  : number of sequence in the sequence alignment
\& Returns   : integer
\& Argument  : none
\& Note      : replaces no_sequences()
.Ve
.SS "average_percentage_identity"
.IX Subsection "average_percentage_identity"
.Vb 11
\& Title   : average_percentage_identity
\& Usage   : $id = $align\->average_percentage_identity
\& Function: The function uses a fast method to calculate the average
\&           percentage identity of the alignment
\& Returns : The average percentage identity of the alignment
\& Args    : None
\& Notes   : This method implemented by Kevin Howe calculates a figure that is
\&           designed to be similar to the average pairwise identity of the
\&           alignment (identical in the absence of gaps), without having to
\&           explicitly calculate pairwise identities proposed by Richard Durbin.
\&           Validated by Ewan Birney ad Alex Bateman.
.Ve
.SS "percentage_identity"
.IX Subsection "percentage_identity"
.Vb 6
\& Title   : percentage_identity
\& Usage   : $id = $align\->percentage_identity
\& Function: The function calculates the average percentage identity
\&           (aliased to average_percentage_identity)
\& Returns : The average percentage identity
\& Args    : None
.Ve
.SS "overall_percentage_identity"
.IX Subsection "overall_percentage_identity"
.Vb 8
\& Title   : overall_percentage_identity
\& Usage   : $id = $align\->overall_percentage_identity
\&           $id = $align\->overall_percentage_identity(\*(Aqshort\*(Aq)
\& Function: The function calculates the percentage identity of
\&           the conserved columns
\& Returns : The percentage identity of the conserved columns
\& Args    : length value to use, optional defaults to alignment length
\&                 possible values: \*(Aqalign\*(Aq, \*(Aqshort\*(Aq, \*(Aqlong\*(Aq
.Ve
.PP
The argument values 'short' and 'long' refer to shortest and longest
sequence in the alignment. Method modification code by Hongyu Zhang.
.SH "Alignment positions"
.IX Header "Alignment positions"
Methods to map a sequence position into an alignment column and back.
\&\fIcolumn_from_residue_number()\fR does the former. The latter is really a
property of the sequence object and can done using
Bio::LocatableSeq::location_from_column:
.PP
.Vb 4
\&    # select somehow a sequence from the alignment, e.g.
\&    my $seq = $aln\->get_seq_by_pos(1);
\&    #$loc is undef or Bio::LocationI object
\&    my $loc = $seq\->location_from_column(5);
.Ve
.SS "column_from_residue_number"
.IX Subsection "column_from_residue_number"
.Vb 6
\& Title   : column_from_residue_number
\& Usage   : $col = $ali\->column_from_residue_number( $seqname, $resnumber)
\& Function: This function gives the position in the alignment
\&           (i.e. column number) of the given residue number in the
\&           sequence with the given name. For example, for the
\&           alignment
\&
\&             Seq1/91\-97 AC..DEF.GH.
\&             Seq2/24\-30 ACGG.RTY...
\&                Seq3/43\-51 AC.DDEF.GHI
\&
\&           column_from_residue_number( "Seq1", 94 ) returns 6.
\&           column_from_residue_number( "Seq2", 25 ) returns 2.
\&           column_from_residue_number( "Seq3", 50 ) returns 10.
\&
\&           An exception is thrown if the residue number would lie
\&           outside the length of the aligment
\&           (e.g. column_from_residue_number( "Seq2", 22 )
\&
\&          Note: If the the parent sequence is represented by more than
\&                one alignment sequence and the residue number is present in
\&                them, this method finds only the first one.
\&
\& Returns : A column number for the position in the alignment of the
\&           given residue in the given sequence (1 = first column)
\& Args    : A sequence id/name (not a name/start\-end)
\&           A residue number in the whole sequence (not just that
\&           segment of it in the alignment)
.Ve
.SH "Sequence names"
.IX Header "Sequence names"
Methods to manipulate the display name. The default name based on the
sequence id and subsequence positions can be overridden in various
ways.
.SS "displayname"
.IX Subsection "displayname"
.Vb 6
\& Title     : displayname
\& Usage     : $myalign\->displayname("Ig", "IgA")
\& Function  : Gets/sets the display name of a sequence in the alignment
\& Returns   : A display name string
\& Argument  : name of the sequence
\&             displayname of the sequence (optional)
.Ve
.SS "set_displayname_count"
.IX Subsection "set_displayname_count"
.Vb 6
\& Title     : set_displayname_count
\& Usage     : $ali\->set_displayname_count
\& Function  : Sets the names to be name_# where # is the number of
\&             times this name has been used.
\& Returns   : 1, on success
\& Argument  :
.Ve
.SS "set_displayname_flat"
.IX Subsection "set_displayname_flat"
.Vb 6
\& Title     : set_displayname_flat
\& Usage     : $ali\->set_displayname_flat()
\& Function  : Makes all the sequences be displayed as just their name,
\&             not name/start\-end
\& Returns   : 1
\& Argument  :
.Ve
.SS "set_displayname_normal"
.IX Subsection "set_displayname_normal"
.Vb 5
\& Title     : set_displayname_normal
\& Usage     : $ali\->set_displayname_normal()
\& Function  : Makes all the sequences be displayed as name/start\-end
\& Returns   : 1, on success
\& Argument  :
.Ve
.SS "source"
.IX Subsection "source"
.Vb 6
\& Title   : source
\& Usage   : $obj\->source($newval)
\& Function: sets the Alignment source program
\& Example :
\& Returns : value of source
\& Args    : newvalue (optional)
.Ve
.SS "set_displayname_safe"
.IX Subsection "set_displayname_safe"
.Vb 9
\& Title     : set_displayname_safe
\& Usage     : ($new_aln, $ref_name)=$ali\->set_displayname_safe(4)
\& Function  : Assign machine\-generated serial names to sequences in input order.
\&             Designed to protect names during PHYLIP runs. Assign 10\-char string
\&             in the form of "S000000001" to "S999999999". Restore the original
\&             names using "restore_displayname".
\& Returns   : 1. a new $aln with system names;
\&             2. a hash ref for restoring names
\& Argument  : Number for id length (default 10)
.Ve
.SS "restore_displayname"
.IX Subsection "restore_displayname"
.Vb 6
\& Title     : restore_displayname
\& Usage     : $aln_name_restored=$ali\->restore_displayname($hash_ref)
\& Function  : Restore original sequence names (after running
\&             $ali\->set_displayname_safe)
\& Returns   : a new $aln with names restored.
\& Argument  : a hash reference of names from "set_displayname_safe".
.Ve
.SS "sort_by_start"
.IX Subsection "sort_by_start"
.Vb 6
\& Title     : sort_by_start
\& Usage     : $ali\->sort_by_start
\& Function  : Changes the order of the alignment to the start position of each
\&             subalignment    
\& Returns   :
\& Argument  :
.Ve
.SS "bracket_string"
.IX Subsection "bracket_string"
.Vb 7
\& Title     : bracket_string
\& Usage     : my @params = (\-refseq     => \*(Aqtestseq\*(Aq,
\&                           \-allele1    => \*(Aqallele1\*(Aq,
\&                           \-allele2    => \*(Aqallele2\*(Aq,
\&                           \-delimiters => \*(Aq{}\*(Aq,
\&                           \-separator  => \*(Aq/\*(Aq);
\&             $str = $aln\->bracket_string(@params)
\&
\& Function :  When supplied with a list of parameters (see below), returns a
\&             string in BIC format. This is used for allelic comparisons.
\&             Briefly, if either allele contains a base change when compared to
\&             the refseq, the base or gap for each allele is represented in
\&             brackets in the order present in the \*(Aqalleles\*(Aq parameter.
\&
\&             For the following data:
\&
\&             >testseq
\&             GGATCCATTGCTACT
\&             >allele1
\&             GGATCCATTCCTACT
\&             >allele2
\&             GGAT\-\-ATTCCTCCT
\&
\&             the returned string with parameters \*(Aqrefseq => testseq\*(Aq and
\&             \*(Aqalleles => [qw(allele1 allele2)]\*(Aq would be:
\&
\&             GGAT[C/\-][C/\-]ATT[C/C]CT[A/C]CT
\& Returns   : BIC\-formatted string
\& Argument  : Required args
\&                refseq    : string (ID) of the reference sequence used
\&                            as basis for comparison
\&                allele1   : string (ID) of the first allele
\&                allele2   : string (ID) of the second allele
\&             Optional args
\&                delimiters: two symbol string of left and right delimiters.
\&                            Only the first two symbols are used
\&                            default = \*(Aq[]\*(Aq
\&                separator : string used as a separator.  Only the first
\&                            symbol is used
\&                            default = \*(Aq/\*(Aq
\& Throws    : On no refseq/alleles, or invalid refseq/alleles.
.Ve
.SS "methods implementing Bio::FeatureHolderI"
.IX Subsection "methods implementing Bio::FeatureHolderI"
FeatureHolderI implementation to support labeled character sets like one
would get from \s-1NEXUS\s0 represented data.
.SS "get_SeqFeatures"
.IX Subsection "get_SeqFeatures"
.Vb 7
\& Usage   : @features = $aln\->get_SeqFeatures
\& Function: Get the feature objects held by this feature holder.
\& Example :
\& Returns : an array of Bio::SeqFeatureI implementing objects
\& Args    : optional filter coderef, taking a Bio::SeqFeatureI 
\&         : as argument, returning TRUE if wanted, FALSE if 
\&         : unwanted
.Ve
.SS "add_SeqFeature"
.IX Subsection "add_SeqFeature"
.Vb 7
\& Usage   : $aln\->add_SeqFeature($subfeat);
\& Function: adds a SeqFeature into the SeqFeature array.
\& Example :
\& Returns : true on success
\& Args    : a Bio::SeqFeatureI object
\& Note    : This implementation is not compliant
\&           with Bio::FeatureHolderI
.Ve
.SS "remove_SeqFeatures"
.IX Subsection "remove_SeqFeatures"
.Vb 6
\& Usage   : $obj\->remove_SeqFeatures
\& Function: Removes all SeqFeatures.  If you want to remove only a subset,
\&           remove that subset from the returned array, and add back the rest.
\& Returns : The array of Bio::SeqFeatureI features that was
\&           deleted from this alignment.
\& Args    : none
.Ve
.SS "feature_count"
.IX Subsection "feature_count"
.Vb 5
\& Title   : feature_count
\& Usage   : $obj\->feature_count()
\& Function: Return the number of SeqFeatures attached to the alignment
\& Returns : integer representing the number of SeqFeatures
\& Args    : None
.Ve
.SS "get_all_SeqFeatures"
.IX Subsection "get_all_SeqFeatures"
.Vb 7
\& Title   : get_all_SeqFeatures
\& Usage   : 
\& Function: Get all SeqFeatures.
\& Example :
\& Returns : an array of Bio::SeqFeatureI implementing objects
\& Args    : none
\& Note    : Falls through to Bio::FeatureHolderI implementation.
.Ve
.SS "methods for Bio::AnnotatableI"
.IX Subsection "methods for Bio::AnnotatableI"
AnnotatableI implementation to support sequence alignments which
contain annotation (\s-1NEXUS\s0, Stockholm).
.SS "annotation"
.IX Subsection "annotation"
.Vb 6
\& Title   : annotation
\& Usage   : $ann = $aln\->annotation or 
\&           $aln\->annotation($ann)
\& Function: Gets or sets the annotation
\& Returns : Bio::AnnotationCollectionI object
\& Args    : None or Bio::AnnotationCollectionI object
.Ve
.PP
See Bio::AnnotationCollectionI and Bio::Annotation::Collection
for more information
.SH "Deprecated methods"
.IX Header "Deprecated methods"
.SS "no_residues"
.IX Subsection "no_residues"
.Vb 6
\& Title     : no_residues
\& Usage     : $no = $ali\->no_residues
\& Function  : number of residues in total in the alignment
\& Returns   : integer
\& Argument  :
\& Note      : deprecated in favor of num_residues()
.Ve
.SS "no_sequences"
.IX Subsection "no_sequences"
.Vb 6
\& Title     : no_sequences
\& Usage     : $depth = $ali\->no_sequences
\& Function  : number of sequence in the sequence alignment
\& Returns   : integer
\& Argument  :
\& Note      : deprecated in favor of num_sequences()
.Ve
.SS "mask_columns"
.IX Subsection "mask_columns"
.Vb 8
\& Title     : mask_columns
\& Usage     : $aln2 = $aln\->mask_columns(20,30)
\& Function  : Masks a slice of the alignment inclusive of start and
\&             end columns, and the first column in the alignment is denoted 1.
\&             Mask beyond the length of the sequence does not do padding.
\& Returns   : A Bio::SimpleAlign object
\& Args      : Positive integer for start column, positive integer for end column,
\&             optional string value use for the mask. Example:
\&
\&             $aln2 = $aln\->mask_columns(20,30,\*(Aq?\*(Aq)
\& Note      : Masking must use a character that is not used for gaps or
\&             frameshifts.  These can be adjusted using the relevant global
\&             variables, but be aware these may be (uncontrollably) modified
\&             elsewhere within BioPerl (see bug 2715)
.Ve
