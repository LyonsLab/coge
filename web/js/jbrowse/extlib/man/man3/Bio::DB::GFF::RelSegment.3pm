.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::DB::GFF::RelSegment 3"
.TH Bio::DB::GFF::RelSegment 3 "2013-05-09" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::DB::GFF::RelSegment \-\- Sequence segment with relative coordinate support
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
See Bio::DB::GFF.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Bio::DB::GFF::RelSegment is a stretch of sequence that can handle
relative coordinate addressing.  It inherits from
Bio::DB::GFF::Segment, and is the base class for
Bio::DB::GFF::Feature.
.PP
In addition to the source sequence, a relative segment has a
\&\*(L"reference sequence\*(R", which is used as the basis for its coordinate
system.  The reference sequence can be changed at will, allowing you
freedom to change the \*(L"frame of reference\*(R" for features contained
within the segment.  For example, by setting a segment's reference
sequence to the beginning of a gene, you can view all other features
in gene-relative coordinates.
.PP
The reference sequence and the source sequence must be on the same
physical stretch of \s-1DNA\s0, naturally.  However, they do not have to be
on the same strand.  The strandedness of the reference sequence
determines whether coordinates increase to the right or the left.
.PP
Generally, you will not create or manipulate Bio::DB::GFF::RelSeg0ment
objects directly, but use those that are returned by the Bio::DB::GFF
module.
.SS "An Example"
.IX Subsection "An Example"
To understand how relative coordinates work, consider the following
example from the C. elegans database.  First we create the appropriate
\&\s-1GFF\s0 accessor object (the factory):
.PP
.Vb 2
\&   my $db = Bio::DB::GFF\->new(\-dsn => \*(Aqdbi:mysql:elegans\*(Aq,
\&                              \-adaptor=>\*(Aqdbi:mysqlopt\*(Aq);
.Ve
.PP
Now we fetch out a segment based on cosmid clone \s-1ZK909:\s0
.PP
.Vb 1
\&  my $seg = $db\->segment(\*(AqZK909\*(Aq);
.Ve
.PP
If we call the segment's \fIrefseq()\fR method, we see that the base of the
coordinate system is the sequence \*(L"\s-1ZK154\s0\*(R", and that its start and
stop positions are 1 and the length of the cosmid:
.PP
.Vb 2
\&  print $seg\->refseq;
\&  => ZK909
\&
\&  print $seg\->start,\*(Aq \- \*(Aq,$seg\->stop;
\&  => 1 \- 33782
.Ve
.PP
As a convenience, the "" operator is overloaded in this class, to give
the reference sequence, and start and stop positions:
.PP
.Vb 2
\&  print $seg;
\&  => ZK909:1,33782
.Ve
.PP
Internally, Bio::DB::GFF::RelSegment has looked up the absolute
coordinates of this segment and maintains the source sequence and the
absolute coordinates relative to the source sequence.  We can see this 
information using \fIsourceseq()\fR (inherited from Bio::DB::GFF::Segment)
and the \fIabs_start()\fR and \fIabs_end()\fR methods:
.PP
.Vb 2
\&  print $seg\->sourceseq;
\&  => CHROMOSOME_I
\&
\&  print $seg\->abs_start,\*(Aq \- \*(Aq,$seg\->abs_end;
\&  => 14839545 \- 14873326
.Ve
.PP
We can also put the segment into absolute mode, so that it behaves
like Bio::DB::Segment, and always represents coordinates on the source
sequence.  This is done by passing a true value to the \fIabsolute()\fR
method:
.PP
.Vb 3
\&  $seq\->absolute(1);
\&  print $seg;
\&  => CHROMOSOME_I:14839545,14873326
.Ve
.PP
We can change the reference sequence at any time.  One way is to call
the segment's \fIref()\fR method, giving it the \s-1ID\s0 (and optionally the
class) of another landmark on the genome.  For example, if we know
that cosmid \s-1ZK337\s0 is adjacent to \s-1ZK909\s0, then we can view \s-1ZK909\s0 in
ZK337\-relative coordinates:
.PP
.Vb 3
\&  $seg\->refseq(\*(AqZK337\*(Aq);
\&  print $seg;
\&  => ZK337:\-33670,111
.Ve
.PP
We can call the segment's \fIfeatures()\fR method in order to get the list
of contigs that overlap this segment (in the C. elegans database,
contigs have feature type \*(L"Sequence:Link\*(R"):
.PP
.Vb 1
\&  @links = $seg\->features(\*(AqSequence:Link\*(Aq);
.Ve
.PP
We can now set the reference sequence to the first of these contigs like so:
.PP
.Vb 3
\&  $seg\->refseq($links[0]);
\&  print $seg;
\&  => Sequence:Link(LINK_Y95D11A):3997326,4031107
.Ve
.SH "API"
.IX Header "API"
The remainder of this document describes the \s-1API\s0 for
Bio::DB::GFF::Segment.
.SS "new"
.IX Subsection "new"
.Vb 6
\& Title   : new
\& Usage   : $s = Bio::DB::GFF::RelSegment\->new(@args)
\& Function: create a new relative segment
\& Returns : a new Bio::DB::GFF::RelSegment object
\& Args    : see below
\& Status  : Public
.Ve
.PP
This method creates a new Bio::DB::GFF::RelSegment object.  Generally
this is called automatically by the Bio::DB::GFF module and
derivatives.
.PP
This function uses a named-argument style:
.PP
.Vb 12
\& \-factory      a Bio::DB::GFF::Adaptor to use for database access
\& \-seq          ID of the source sequence
\& \-class        class of the source sequence
\& \-start        start of the desired segment relative to source sequence
\& \-stop         stop of the desired segment relative to source sequence
\& \-ref          ID of the reference sequence
\& \-refclass     class of the reference sequence
\& \-offset       0\-based offset from source sequence to start of segment
\& \-length       length of desired segment
\& \-absolute, \-force_absolute
\&               use absolute coordinates, rather than coordinates relative
\&               to the start of self or the reference sequence
.Ve
.PP
The \-seq argument accepts the \s-1ID\s0 of any landmark in the database.  The
stored source sequence becomes whatever the \s-1GFF\s0 file indicates is the
proper sequence for this landmark.  A class of \*(L"Sequence\*(R" is assumed
unless otherwise specified in the \-class argument.
.PP
If the argument to \-seq is a Bio::GFF::Featname object (such as
returned by the \fIgroup()\fR method), then the class is taken from that.
.PP
The optional \-start and \-stop arguments specify the end points for the
retrieved segment.  For those who do not like 1\-based indexing,
\&\-offset and \-length are provided.  If both \-start/\-stop and
\&\-offset/\-length are provided, the latter overrides the former.
Generally it is not a good idea to mix metaphors.
.PP
\&\-ref and \-refclass together indicate a sequence to be used for
relative coordinates.  If not provided, the source sequence indicated
by \-seq is used as the reference sequence.  If the argument to \-ref is
a Bio::GFF::Featname object (such as returned by the \fIgroup()\fR method),
then the class is taken from that.
.PP
\&\-force_absolute should be used if you wish to skip the lookup of the
absolute position of the source sequence that ordinarily occurs when
you create a relative segment.  In this case, the source sequence must
be a sequence that has been specified as the \*(L"source\*(R" in the \s-1GFF\s0 file.
.SS "refseq"
.IX Subsection "refseq"
.Vb 6
\& Title   : refseq
\& Usage   : $ref = $s\->refseq([$newseq] [,$newseqclass])
\& Function: get/set reference sequence
\& Returns : current reference sequence
\& Args    : new reference sequence and class (optional)
\& Status  : Public
.Ve
.PP
This method will get or set the reference sequence.  Called with no
arguments, it returns the current reference sequence.  Called with
either a sequence \s-1ID\s0 and class, a Bio::DB::GFF::Segment object (or
subclass) or a Bio::DB::GFF::Featname object, it will set the current
reference sequence and return the previous one.
.PP
The method will generate an exception if you attempt to set the
reference sequence to a sequence that isn't contained in the database,
or one that has a different source sequence from the segment.
.SS "abs_low"
.IX Subsection "abs_low"
.Vb 6
\& Title   : abs_low
\& Usage   : $s\->abs_low
\& Function: the absolute lowest coordinate of the segment
\& Returns : an integer
\& Args    : none
\& Status  : Public
.Ve
.PP
This is for GadFly compatibility, and returns the low coordinate in
absolute coordinates;
.SS "abs_high"
.IX Subsection "abs_high"
.Vb 6
\& Title   : abs_high
\& Usage   : $s\->abs_high
\& Function: the absolute highest coordinate of the segment
\& Returns : an integer
\& Args    : none
\& Status  : Public
.Ve
.PP
This is for GadFly compatibility, and returns the high coordinate in
absolute coordinates;
.SS "asString"
.IX Subsection "asString"
.Vb 6
\& Title   : asString
\& Usage   : $s\->asString
\& Function: human\-readable representation of the segment
\& Returns : a string
\& Args    : none
\& Status  : Public
.Ve
.PP
This method will return a human-readable representation of the
segment.  It is the overloaded method call for the "" operator.
.PP
Currently the format is:
.PP
.Vb 1
\&  refseq:start,stop
.Ve
.SS "name"
.IX Subsection "name"
.Vb 2
\& Title   : name
\& Usage   : Alias for asString()
.Ve
.SS "absolute"
.IX Subsection "absolute"
.Vb 6
\& Title   : absolute
\& Usage   : $abs = $s\->absolute([$abs])
\& Function: get/set absolute coordinates
\& Returns : a boolean flag
\& Args    : new setting for flag (optional)
\& Status  : Public
.Ve
.PP
Called with a boolean flag, this method controls whether to display
relative coordinates (relative to the reference sequence) or absolute
coordinates (relative to the source sequence).  It will return the
previous value of the setting.
.SS "features"
.IX Subsection "features"
.Vb 6
\& Title   : features
\& Usage   : @features = $s\->features(@args)
\& Function: get features that overlap this segment
\& Returns : a list of Bio::DB::GFF::Feature objects
\& Args    : see below
\& Status  : Public
.Ve
.PP
This method will find all features that overlap the segment and return
a list of Bio::DB::GFF::Feature objects.  The features will use
coordinates relative to the reference sequence in effect at the time
that \fIfeatures()\fR was called.
.PP
The returned list can be limited to certain types of feature by
filtering on their method and/or source.  In addition, it is possible
to obtain an iterator that will step through a large number of
features sequentially.
.PP
Arguments can be provided positionally or using the named arguments
format.  In the former case, the arguments are a list of feature types
in the format \*(L"method:source\*(R".  Either method or source can be
omitted, in which case the missing component is treated as a wildcard.
If no colon is present, then the type is treated as a method name.
Multiple arguments are ORed together.
.PP
Examples:
.PP
.Vb 5
\& @f = $s\->features(\*(Aqexon:curated\*(Aq);           # all curated exons
\& @f = $s\->features(\*(Aqexon:curated\*(Aq,\*(Aqintron\*(Aq);  # curated exons and all introns
\& @f = $s\->features(\*(Aqsimilarity:.*EST.*\*(Aq);     # all similarities
\&                                              # having something to do
\&                                              # with ESTs
.Ve
.PP
The named parameter form gives you control over a few options:
.PP
.Vb 2
\&  \-types      an array reference to type names in the format
\&              "method:source"
\&
\&  \-merge     Whether to apply aggregators to the generated features (default yes)
\&
\&  \-rare      Turn on an optimization suitable for a relatively rare feature type,
\&             where it will be faster to filter by feature type first
\&             and then by position, rather than vice versa.
\&
\&  \-attributes a hashref containing a set of attributes to match
\&
\&  \-range_type One of \*(Aqoverlapping\*(Aq, \*(Aqcontains\*(Aq, or \*(Aqcontained_in\*(Aq
\&
\&  \-iterator  Whether to return an iterator across the features.
\&
\&  \-binsize   A true value will create a set of artificial features whose
\&             start and stop positions indicate bins of the given size, and
\&             whose scores are the number of features in the bin.  The
\&             class and method of the feature will be set to "bin",
\&             its source to "method:source", and its group to "bin:method:source".
\&             This is a handy way of generating histograms of feature density.
.Ve
.PP
\&\-merge is a boolean flag that controls whether the adaptor's
aggregators wll be applied to the features returned by this method.
.PP
If \-iterator is true, then the method returns a single scalar value
consisting of a Bio::SeqIO object.  You can call \fInext_seq()\fR repeatedly
on this object to fetch each of the features in turn.  If iterator is
false or absent, then all the features are returned as a list.
.PP
The \-attributes argument is a hashref containing one or more
attributes to match against:
.PP
.Vb 2
\&  \-attributes => { Gene => \*(Aqabc\-1\*(Aq,
\&                   Note => \*(Aqconfirmed\*(Aq }
.Ve
.PP
Attribute matching is simple string matching, and multiple attributes
are ANDed together.
.SS "get_SeqFeatures"
.IX Subsection "get_SeqFeatures"
.Vb 5
\& Title   : get_SeqFeatures
\& Usage   :
\& Function: returns the top level sequence features
\& Returns : L<Bio::SeqFeatureI> objects
\& Args    : none
.Ve
.PP
Segments do not ordinarily return any subfeatures.
.SS "feature_count"
.IX Subsection "feature_count"
.Vb 5
\& Title   : feature_count
\& Usage   : $seq\->feature_count()
\& Function: Return the number of SeqFeatures attached to a sequence
\& Returns : integer representing the number of SeqFeatures
\& Args    : none
.Ve
.PP
This method comes through extension of Bio::FeatureHolderI. See
Bio::FeatureHolderI for more information.
.SS "get_feature_stream"
.IX Subsection "get_feature_stream"
.Vb 6
\& Title   : features
\& Usage   : $stream = $s\->get_feature_stream(@args)
\& Function: get a stream of features that overlap this segment
\& Returns : a Bio::SeqIO::Stream\-compliant stream
\& Args    : see below
\& Status  : Public
.Ve
.PP
This is the same as \fIfeatures()\fR, but returns a stream.  Use like this:
.PP
.Vb 4
\& $stream = $s\->get_feature_stream(\*(Aqexon\*(Aq);
\& while (my $exon = $stream\->next_seq) {
\&    print $exon\->start,"\en";
\& }
.Ve
.SS "get_seq_stream"
.IX Subsection "get_seq_stream"
.Vb 6
\& Title   : get_seq_stream
\& Usage   : $stream = $s\->get_seq_stream(@args)
\& Function: get a stream of features that overlap this segment
\& Returns : a Bio::SeqIO::Stream\-compliant stream
\& Args    : see below
\& Status  : Public
.Ve
.PP
This is the same as \fIfeature_stream()\fR, and is provided for Bioperl
compatibility.  Use like this:
.PP
.Vb 4
\& $stream = $s\->get_seq_stream(\*(Aqexon\*(Aq);
\& while (my $exon = $stream\->next_seq) {
\&    print $exon\->start,"\en";
\& }
.Ve
.SS "overlapping_features"
.IX Subsection "overlapping_features"
.Vb 6
\& Title   : overlapping_features
\& Usage   : @features = $s\->overlapping_features(@args)
\& Function: get features that overlap this segment
\& Returns : a list of Bio::DB::GFF::Feature objects
\& Args    : see features()
\& Status  : Public
.Ve
.PP
This is an alias for the \fIfeatures()\fR method, and takes the same
arguments.
.SS "contained_features"
.IX Subsection "contained_features"
.Vb 6
\& Title   : contained_features
\& Usage   : @features = $s\->contained_features(@args)
\& Function: get features that are contained by this segment
\& Returns : a list of Bio::DB::GFF::Feature objects
\& Args    : see features()
\& Status  : Public
.Ve
.PP
This is identical in behavior to \fIfeatures()\fR except that it returns
only those features that are completely contained within the segment,
rather than any that overlap.
.SS "contained_in"
.IX Subsection "contained_in"
.Vb 6
\& Title   : contained_in
\& Usage   : @features = $s\->contained_in(@args)
\& Function: get features that contain this segment
\& Returns : a list of Bio::DB::GFF::Feature objects
\& Args    : see features()
\& Status  : Public
.Ve
.PP
This is identical in behavior to \fIfeatures()\fR except that it returns
only those features that completely contain the segment.
.SS "delete"
.IX Subsection "delete"
.Vb 6
\& Title   : delete
\& Usage   : $db\->delete(@args)
\& Function: delete features
\& Returns : count of features deleted \-\- if available
\& Args    : numerous, see below
\& Status  : public
.Ve
.PP
This method deletes all features that overlap the specified region or
are of a particular type.  If no arguments are provided and the \-force
argument is true, then deletes \s-1ALL\s0 features.
.PP
Arguments:
.PP
.Vb 2
\& \-type,\-types  Either a single scalar type to be deleted, or an
\&               reference to an array of types.
\&
\& \-range_type   Control the range type of the deletion.  One of "overlaps" (default)
\&               "contains" or "contained_in"
.Ve
.PP
Examples:
.PP
.Vb 4
\&  $segment\->delete(\-type=>[\*(Aqintron\*(Aq,\*(Aqrepeat:repeatMasker\*(Aq]);  # remove all introns & repeats
\&  $segment\->delete(\-type=>[\*(Aqintron\*(Aq,\*(Aqrepeat:repeatMasker\*(Aq]
\&                   \-range_type => \*(Aqcontains\*(Aq);                # remove all introns & repeats
\&                                                              # strictly contained in segment
.Ve
.PP
\&\s-1IMPORTANT\s0 \s-1NOTE:\s0 This method only deletes features.  It does *NOT*
delete the names of groups that contain the deleted features.  Group
IDs will be reused if you later load a feature with the same group
name as one that was previously deleted.
.PP
\&\s-1NOTE\s0 \s-1ON\s0 \s-1FEATURE\s0 \s-1COUNTS:\s0 The DBI-based versions of this call return the
result code from the \s-1SQL\s0 \s-1DELETE\s0 operation.  Some dbd drivers return the
count of rows deleted, while others return 0E0.  Caveat emptor.
.SS "_process_feature_args"
.IX Subsection "_process_feature_args"
.Vb 7
\& Title   : _process_feature_args
\& Usage   : @args = $s\->_process_feature_args(@args)
\& Function: preprocess arguments passed to features, 
\&           contained_features, and overlapping_features
\& Returns : a list of parsed arguents
\& Args    : see feature()
\& Status  : Internal
.Ve
.PP
This is an internal method that is used to check and format the
arguments to \fIfeatures()\fR before passing them on to the adaptor.
.SS "types"
.IX Subsection "types"
.Vb 6
\& Title   : types
\& Usage   : @types = $s\->types([\-enumerate=>1])
\& Function: list feature types that overlap this segment
\& Returns : a list of Bio::DB::GFF::Typename objects or a hash
\& Args    : see below
\& Status  : Public
.Ve
.PP
The \fItypes()\fR method will return a list of Bio::DB::GFF::Typename
objects, each corresponding to a feature that overlaps the segment.
If the optional \-enumerate parameter is set to a true value, then the
method will return a hash in which the keys are the type names and the 
values are the number of times a feature of that type is present on
the segment.  For example:
.PP
.Vb 1
\&  %count = $s\->types(\-enumerate=>1);
.Ve
.SH "Internal Methods"
.IX Header "Internal Methods"
The following are internal methods and should not be called directly.
.SS "new_from_segment"
.IX Subsection "new_from_segment"
.Vb 6
\& Title   : new_from_segment
\& Usage   : $s = $segment\->new_from_segment(@args)
\& Function: create a new relative segment
\& Returns : a new Bio::DB::GFF::RelSegment object
\& Args    : see below
\& Status  : Internal
.Ve
.PP
This constructor is used internally by the \fIsubseq()\fR method.  It forces
the new segment into the Bio::DB::GFF::RelSegment package, regardless
of the package that it is called from.  This causes subclass-specfic
information, such as feature types, to be dropped when a subsequence
is created.
.SS "_abs2rel"
.IX Subsection "_abs2rel"
.Vb 6
\& Title   : _abs2rel
\& Usage   : @coords = $s\->_abs2rel(@coords)
\& Function: convert absolute coordinates into relative coordinates
\& Returns : a list of relative coordinates
\& Args    : a list of absolute coordinates
\& Status  : Internal
.Ve
.PP
This is used internally to map from absolute to relative
coordinates. It does not take the offset of the reference sequence
into account, so please use \fIabs2rel()\fR instead.
.SS "rel2abs"
.IX Subsection "rel2abs"
.Vb 6
\& Title   : rel2abs
\& Usage   : @coords = $s\->rel2abs(@coords)
\& Function: convert relative coordinates into absolute coordinates
\& Returns : a list of absolute coordinates
\& Args    : a list of relative coordinates
\& Status  : Public
.Ve
.PP
This function takes a list of positions in relative coordinates to the
segment, and converts them into absolute coordinates.
.SS "abs2rel"
.IX Subsection "abs2rel"
.Vb 6
\& Title   : abs2rel
\& Usage   : @rel_coords = $s\->abs2rel(@abs_coords)
\& Function: convert absolute coordinates into relative coordinates
\& Returns : a list of relative coordinates
\& Args    : a list of absolute coordinates
\& Status  : Public
.Ve
.PP
This function takes a list of positions in absolute coordinates
and returns a list expressed in relative coordinates.
.SS "Bio::RangeI Methods"
.IX Subsection "Bio::RangeI Methods"
The following Bio::RangeI methods are supported:
.PP
\&\fIoverlaps()\fR, \fIcontains()\fR, \fIequals()\fR,\fIintersection()\fR,\fIunion()\fR,\fIoverlap_extent()\fR
.SH "BUGS"
.IX Header "BUGS"
Schemas need some work.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
bioperl
.SH "AUTHOR"
.IX Header "AUTHOR"
Lincoln Stein <lstein@cshl.org>.
.PP
Copyright (c) 2001 Cold Spring Harbor Laboratory.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
