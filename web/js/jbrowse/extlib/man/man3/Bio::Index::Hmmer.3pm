.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Index::Hmmer 3"
.TH Bio::Index::Hmmer 3 "2013-05-09" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::Index::Hmmer \- indexes HMMER reports and supports retreival based on query
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&        # Complete Code for indexing a set of report files
\&        #!/usr/bin/perl \-w
\&        use strict;
\&        use Bio::Index::Hmmer;
\&        my $indexfile = shift;
\&        my $index = Bio::Index::Hmmer\->new(
\&                \-filename => $indexfile,
\&                \-write_flag => 1
\&        );
\&        $index\->make_index(@ARGV);
\&
\&
\&        # Complete code for fetching a report
\&        use strict;
\&        use Bio::Index::Hmmer;
\&        my $indexfile = shift;
\&        my $index = Bio::Index::Hmmer\->new(
\&                \-filename => $indexfile,
\&                \-write_flag => 0
\&        );
\&
\&        foreach my $id (@ARGV) {
\&                my $report = $index\->fetch_report($id);
\&                print "Query: ", $report\->query_name(), "\en";
\&                while( my $hit = $report\->next_hit() ) {
\&                        print "\etHit Name: ", $hit\->name(), "\en";
\&                        while( my $hsp = $hit\->next_domain() ) {
\&                                print "\et\etE\-Value: ", $hsp\->evalue(), "\en";
\&                        }
\&                }
\&        }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This object allows one to build an index on a \s-1HMMER\s0 file (or files)
and provide quick access to the \s-1HMMER\s0 report for that accession.
For best results 'use strict'.
.PP
You can also set or customize the unique key used to retrieve by 
writing your own function and calling the \fIid_parser()\fR method.
For example:
.PP
.Vb 3
\&   $inx\->id_parser(\e&get_id);
\&   # make the index
\&   $inx\->make_index($file_name);
\&
\&   # here is where the retrieval key is specified
\&   sub get_id {
\&      my $line = shift;
\&      $line =~ /^KW\es+([A\-Z]+)/i;
\&      $1;
\&   }
.Ve
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to
the Bioperl mailing list.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
of the bugs and their resolution. Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  https://redmine.open\-bio.org/projects/bioperl/
.Ve
.SH "AUTHOR \- Josh Lauricha"
.IX Header "AUTHOR - Josh Lauricha"
Email laurichj@bioinfo.ucr.edu
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _
.SS "new"
.IX Subsection "new"
.Vb 10
\& Usage   : $index = Bio::Index::Hmmer\->new(
\&               \-filename    => $dbm_file,
\&               \-write_flag  => 0,
\&               \-dbm_package => \*(AqDB_File\*(Aq,
\&               \-verbose     => 0
\&           );
\& Function: Returns a new index object.  If filename is
\& specified, then open_dbm() is immediately called.
\& Returns : A new index object
\& Args    : \-filename    The name of the dbm index file.
\&           \-write_flag  TRUE if write access to the dbm file is
\&                        needed.
\&           \-dbm_package The Perl dbm module to use for the
\&                        index.
\&           \-verbose     Print debugging output to STDERR if
\&                        TRUE.
.Ve
.SS "Bio::Index::Hmmer implemented methods"
.IX Subsection "Bio::Index::Hmmer implemented methods"
.SS "fetch_report"
.IX Subsection "fetch_report"
.Vb 6
\& Title   : fetch_report
\& Usage   : my $report = $idx\->fetch_report($id);
\& Function: Returns a Bio::Search::Result::HMMERResult report object
\&           for a specific HMMER report
\& Returns : Bio::Search::Result::HMMERResult
\& Args    : valid id
.Ve
.SS "id_parser"
.IX Subsection "id_parser"
.Vb 10
\&  Title   : id_parser
\&  Usage   : $index\->id_parser( CODE )
\&  Function: Stores or returns the code used by record_id to
\&            parse the ID for record from a string.  Useful
\&            for (for instance) specifying a different
\&            parser for different flavours of blast dbs. 
\&            Returns \e&default_id_parser (see below) if not
\&            set. If you supply your own id_parser
\&            subroutine, then it should expect a fasta
\&            description line.  An entry will be added to
\&            the index for each string in the list returned.
\&  Example : $index\->id_parser( \e&my_id_parser )
\&  Returns : ref to CODE if called without arguments
\&  Args    : CODE
.Ve
.SS "default_id_parser"
.IX Subsection "default_id_parser"
.Vb 7
\&  Title   : default_id_parser
\&  Usage   : $id = default_id_parser( $header )
\&  Function: The default Blast Query ID parser for Bio::Index::Blast.pm
\&            Returns $1 from applying the regexp /^>\es*(\eS+)/
\&            to $header.
\&  Returns : ID string
\&  Args    : a header line string
.Ve
.SS "Require methods from Bio::Index::Abstract"
.IX Subsection "Require methods from Bio::Index::Abstract"
.SS "_index_file"
.IX Subsection "_index_file"
.Vb 8
\&  Title   : _index_file
\&  Usage   : $index\->_index_file( $file_name, $i )
\&  Function: Specialist function to index HMMER report file(s).
\&            Is provided with a filename and an integer
\&            by make_index in its SUPER class.
\&  Example : 
\&  Returns : 
\&  Args    :
.Ve
.SS "Bio::Index::Abstract methods"
.IX Subsection "Bio::Index::Abstract methods"
.SS "filename"
.IX Subsection "filename"
.Vb 7
\& Title   : filename
\& Usage   : $value = $self\->filename();
\&           $self\->filename($value);
\& Function: Gets or sets the name of the dbm index file.
\& Returns : The current value of filename
\& Args    : Value of filename if setting, or none if
\&           getting the value.
.Ve
.SS "write_flag"
.IX Subsection "write_flag"
.Vb 9
\& Title   : write_flag
\& Usage   : $value = $self\->write_flag();
\&           $self\->write_flag($value);
\& Function: Gets or sets the value of write_flag, which
\&           is wether the dbm file should be opened with
\&           write access.
\& Returns : The current value of write_flag (default 0)
\& Args    : Value of write_flag if setting, or none if
\&           getting the value.
.Ve
.SS "dbm_package"
.IX Subsection "dbm_package"
.Vb 2
\& Usage   : $value = $self\->dbm_package();
\&           $self\->dbm_package($value);
\&
\& Function: Gets or sets the name of the Perl dbm module used. 
\&           If the value is unset, then it returns the value of
\&           the package variable $USE_DBM_TYPE or if that is
\&           unset, then it chooses the best available dbm type,
\&           choosing \*(AqDB_File\*(Aq in preference to \*(AqSDBM_File\*(Aq. 
\&           Bio::Abstract::Index may work with other dbm file
\&           types.
\&
\& Returns : The current value of dbm_package
\& Args    : Value of dbm_package if setting, or none if
\&           getting the value.
.Ve
.SS "get_stream"
.IX Subsection "get_stream"
.Vb 4
\& Title   : get_stream
\& Usage   : $stream = $index\->get_stream( $id );
\& Function: Returns a file handle with the file pointer
\&           at the approprite place
\&
\&           This provides for a way to get the actual
\&           file contents and not an object 
\&
\&           WARNING: you must parse the record deliminter
\&           *yourself*. Abstract wont do this for you 
\&           So this code
\&
\&           $fh = $index\->get_stream($myid);
\&           while( <$fh> ) {
\&              # do something
\&           }
\&           will parse the entire file if you don\*(Aqt put in
\&           a last statement in, like
\&
\&           while( <$fh> ) {
\&              /^\e/\e// && last; # end of record
\&              # do something
\&           }
\&
\& Returns : A filehandle object
\& Args    : string represents the accession number
\& Notes   : This method should not be used without forethought
.Ve
.SS "open_dbm"
.IX Subsection "open_dbm"
.Vb 8
\&  Usage   : $index\->open_dbm()
\&  Function: Opens the dbm file associated with the index
\&            object.  Write access is only given if explicitly
\&            asked for by calling new(\-write => 1) or having set
\&            the write_flag(1) on the index object.  The type of
\&            dbm file opened is that returned by dbm_package(). 
\&            The name of the file to be is opened is obtained by
\&            calling the filename() method.
\&
\&  Example : $index\->_open_dbm()
\&  Returns : 1 on success
.Ve
.SS "_version"
.IX Subsection "_version"
.Vb 9
\&  Title   : _version
\&  Usage   : $type = $index\->_version()
\&  Function: Returns a string which identifes the version of an
\&            index module.  Used to permanently identify an index
\&            file as having been created by a particular version
\&            of the index module.  Must be provided by the sub class
\&  Example : 
\&  Returns : 
\&  Args    : none
.Ve
.SS "_filename"
.IX Subsection "_filename"
.Vb 6
\&  Title   : _filename
\&  Usage   : $index\->_filename( FILE INT )
\&  Function: Indexes the file
\&  Example : 
\&  Returns : 
\&  Args    :
.Ve
.SS "_file_handle"
.IX Subsection "_file_handle"
.Vb 10
\&  Title   : _file_handle
\&  Usage   : $fh = $index\->_file_handle( INT )
\&  Function: Returns an open filehandle for the file
\&            index INT.  On opening a new filehandle it
\&            caches it in the @{$index\->_filehandle} array.
\&            If the requested filehandle is already open,
\&            it simply returns it from the array.
\&  Example : $fist_file_indexed = $index\->_file_handle( 0 );
\&  Returns : ref to a filehandle
\&  Args    : INT
.Ve
.SS "_file_count"
.IX Subsection "_file_count"
.Vb 9
\&  Title   : _file_count
\&  Usage   : $index\->_file_count( INT )
\&  Function: Used by the index building sub in a sub class to
\&            track the number of files indexed.  Sets or gets
\&            the number of files indexed when called with or
\&            without an argument.
\&  Example : 
\&  Returns : INT
\&  Args    : INT
.Ve
.SS "add_record"
.IX Subsection "add_record"
.Vb 10
\&  Title   : add_record
\&  Usage   : $index\->add_record( $id, @stuff );
\&  Function: Calls pack_record on @stuff, and adds the result
\&            of pack_record to the index database under key $id.
\&            If $id is a reference to an array, then a new entry
\&            is added under a key corresponding to each element
\&            of the array.
\&  Example : $index\->add_record( $id, $fileNumber, $begin, $end )
\&  Returns : TRUE on success or FALSE on failure
\&  Args    : ID LIST
.Ve
.SS "pack_record"
.IX Subsection "pack_record"
.Vb 8
\&  Title   : pack_record
\&  Usage   : $packed_string = $index\->pack_record( LIST )
\&  Function: Packs an array of scalars into a single string
\&            joined by ASCII 034 (which is unlikely to be used
\&            in any of the strings), and returns it. 
\&  Example : $packed_string = $index\->pack_record( $fileNumber, $begin, $end )
\&  Returns : STRING or undef
\&  Args    : LIST
.Ve
.SS "unpack_record"
.IX Subsection "unpack_record"
.Vb 7
\&  Title   : unpack_record
\&  Usage   : $index\->unpack_record( STRING )
\&  Function: Splits the sting provided into an array,
\&            splitting on ASCII 034.
\&  Example : ( $fileNumber, $begin, $end ) = $index\->unpack_record( $self\->db\->{$id} )
\&  Returns : A 3 element ARRAY
\&  Args    : STRING containing ASCII 034
.Ve
.SS "\s-1DESTROY\s0"
.IX Subsection "DESTROY"
.Vb 6
\& Title   : DESTROY
\& Usage   : Called automatically when index goes out of scope
\& Function: Closes connection to database and handles to
\&           sequence files
\& Returns : NEVER
\& Args    : NONE
.Ve
