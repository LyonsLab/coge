.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Search::Hit::PullHitI 3"
.TH Bio::Search::Hit::PullHitI 3 "2013-05-09" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::Search::Hit::PullHitI \- Bio::Search::Hit::HitI interface for pull parsers.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        # This is an interface and cannot be instantiated
\&
\&    # typically one gets HitI objects from a SearchIO stream via a ResultI
\&    use Bio::SearchIO;
\&    my $parser = Bio::SearchIO\->new(\-format => \*(Aqhmmer_pull\*(Aq,
\&                                   \-file => \*(Aqt/data/hmmpfam.out\*(Aq);
\&
\&    my $result = $parser\->next_result;
\&    my $hit    = $result\->next_hit;
\&
\&    $hit_name = $hit\->name();
\&
\&    $desc = $hit\->description();
\&
\&    $len = $hit\->length
\&
\&    $alg = $hit\->algorithm();
\&
\&    $score = $hit\->raw_score();
\&
\&    $significance = $hit\->significance();
\&
\&    $rank = $hit\->rank(); # the Nth hit for a specific query
\&
\&    while( $hsp = $obj\->next_hsp()) { ... } # process in iterator fashion
\&
\&    for my $hsp ( $obj\->hsps()()) { ... } # process in list fashion
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This object handles the hit data from a database sequence search.
.PP
PullHitI is for fast implementations that only do parsing work on the hit
data when you actually request information by calling one of the HitI
methods.
.PP
Many methods of HitI are implemented in a way suitable for inheriting classes
that use Bio::PullParserI. It only really makes sense for PullHit modules to be
created by (and have as a \-parent) PullResult modules.
.PP
In addition to the usual \-chunk and \-parent, \-hit_data is all you should supply
when making a PullHit object. This will store that data and make it accessible
via _raw_hit_data, which you can access in your subclass. It would be best to
simply provide the data as the input \-chunk instead, if the raw data is large
enough.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  https://redmine.open\-bio.org/projects/bioperl/
.Ve
.SH "AUTHOR \- Sendu Bala"
.IX Header "AUTHOR - Sendu Bala"
Email bix@sendu.me.uk
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2006 Sendu Bala. All Rights Reserved.
.SH "DISCLAIMER"
.IX Header "DISCLAIMER"
This software is provided \*(L"as is\*(R" without warranty of any kind.
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object
methods. Internal methods are usually preceded with a _
.SS "_setup"
.IX Subsection "_setup"
.Vb 6
\& Title   : _setup
\& Usage   : $self\->_setup(@args)
\& Function: Implementers should call this to setup common fields and deal with
\&           common arguments to new().
\& Returns : n/a
\& Args    : @args received in new().
.Ve
.SS "name"
.IX Subsection "name"
.Vb 5
\& Title   : name
\& Usage   : $hit_name = $hit\->name();
\& Function: returns the name of the Hit sequence
\& Returns : a scalar string
\& Args    : none
.Ve
.PP
The \fBname\fR of a hit is unique within a Result or within an Iteration.
.SS "description"
.IX Subsection "description"
.Vb 5
\& Title   : description
\& Usage   : $desc = $hit\->description();
\& Function: Retrieve the description for the hit
\& Returns : a scalar string
\& Args    : none
.Ve
.SS "accession"
.IX Subsection "accession"
.Vb 5
\& Title   : accession
\& Usage   : $acc = $hit\->accession();
\& Function: Retrieve the accession (if available) for the hit
\& Returns : a scalar string (empty string if not set)
\& Args    : none
.Ve
.SS "locus"
.IX Subsection "locus"
.Vb 5
\& Title   : locus
\& Usage   : $acc = $hit\->locus();
\& Function: Retrieve the locus(if available) for the hit
\& Returns : a scalar string (empty string if not set)
\& Args    : none
.Ve
.SS "length"
.IX Subsection "length"
.Vb 5
\& Title   : length
\& Usage   : my $len = $hit\->length
\& Function: Returns the length of the hit 
\& Returns : integer
\& Args    : none
.Ve
.SS "algorithm"
.IX Subsection "algorithm"
.Vb 9
\& Title   : algorithm
\& Usage   : $alg = $hit\->algorithm();
\& Function: Gets the algorithm specification that was used to obtain the hit
\&           For BLAST, the algorithm denotes what type of sequence was aligned 
\&           against what (BLASTN: dna\-dna, BLASTP prt\-prt, BLASTX translated 
\&           dna\-prt, TBLASTN prt\-translated dna, TBLASTX translated 
\&           dna\-translated dna).
\& Returns : a scalar string 
\& Args    : none
.Ve
.SS "raw_score"
.IX Subsection "raw_score"
.Vb 7
\& Title   : raw_score
\& Usage   : $score = $hit\->raw_score();
\& Function: Gets the "raw score" generated by the algorithm.  What
\&           this score is exactly will vary from algorithm to algorithm,
\&           returning undef if unavailable.
\& Returns : a scalar value
\& Args    : none
.Ve
.SS "score"
.IX Subsection "score"
Equivalent to \fIraw_score()\fR
.SS "significance"
.IX Subsection "significance"
.Vb 8
\& Title   : significance
\& Usage   : $significance = $hit\->significance();
\& Function: Used to obtain the E or P value of a hit, i.e. the probability that
\&           this particular hit was obtained purely by random chance.  If
\&           information is not available (nor calculatable from other
\&           information sources), return undef.
\& Returns : a scalar value or undef if unavailable
\& Args    : none
.Ve
.SS "bits"
.IX Subsection "bits"
.Vb 6
\& Usage     : $hit_object\->bits();
\& Purpose   : Gets the bit score of the best HSP for the current hit.
\& Example   : $bits = $hit_object\->bits();
\& Returns   : Integer or double for FASTA reports
\& Argument  : n/a
\& Comments  : For BLAST1, the non\-bit score is listed in the summary line.
.Ve
.PP
See Also   : \fIscore()\fR
.SS "next_hsp"
.IX Subsection "next_hsp"
.Vb 6
\& Title    : next_hsp
\& Usage    : while( $hsp = $obj\->next_hsp()) { ... }
\& Function : Returns the next available High Scoring Pair
\& Example  : 
\& Returns  : L<Bio::Search::HSP::HSPI> object or null if finished
\& Args     : none
.Ve
.SS "hsps"
.IX Subsection "hsps"
.Vb 10
\& Usage     : $hit_object\->hsps();
\& Purpose   : Get a list containing all HSP objects.
\&           : Get the numbers of HSPs for the current hit.
\& Example   : @hsps = $hit_object\->hsps();
\&           : $num  = $hit_object\->hsps();  # alternatively, use num_hsps()
\& Returns   : Array context : list of L<Bio::Search::HSP::BlastHSP> objects.
\&           : Scalar context: integer (number of HSPs).
\&           :                 (Equivalent to num_hsps()).
\& Argument  : n/a. Relies on wantarray
\& Throws    : Exception if the HSPs have not been collected.
.Ve
.PP
See Also   : \fIhsp()\fR, \fInum_hsps()\fR
.SS "num_hsps"
.IX Subsection "num_hsps"
.Vb 6
\& Usage     : $hit_object\->num_hsps();
\& Purpose   : Get the number of HSPs for the present Blast hit.
\& Example   : $nhsps = $hit_object\->num_hsps();
\& Returns   : Integer
\& Argument  : n/a
\& Throws    : Exception if the HSPs have not been collected.
.Ve
.PP
See Also   : \fIhsps()\fR
.SS "seq_inds"
.IX Subsection "seq_inds"
.Vb 10
\& Usage     : $hit\->seq_inds( seq_type, class, collapse );
\& Purpose   : Get a list of residue positions (indices) across all HSPs
\&           : for identical or conserved residues in the query or sbjct sequence.
\& Example   : @s_ind = $hit\->seq_inds(\*(Aqquery\*(Aq, \*(Aqidentical\*(Aq);
\&           : @h_ind = $hit\->seq_inds(\*(Aqhit\*(Aq, \*(Aqconserved\*(Aq);
\&           : @h_ind = $hit\->seq_inds(\*(Aqhit\*(Aq, \*(Aqconserved\*(Aq, 1);
\& Returns   : Array of integers 
\&           : May include ranges if collapse is non\-zero.
\& Argument  : [0] seq_type  = \*(Aqquery\*(Aq or \*(Aqhit\*(Aq or \*(Aqsbjct\*(Aq  (default = \*(Aqquery\*(Aq)
\&           :                 (\*(Aqsbjct\*(Aq is synonymous with \*(Aqhit\*(Aq)
\&           : [1] class = \*(Aqidentical\*(Aq or \*(Aqconserved\*(Aq or \*(Aqnomatch\*(Aq or \*(Aqgap\*(Aq
\&                   :         (default = \*(Aqidentical\*(Aq)
\&           :         (can be shortened to \*(Aqid\*(Aq or \*(Aqcons\*(Aq)
\&                   :         Note that \*(Aqconserved\*(Aq includes identical unless you use
\&                   :         \*(Aqconserved\-not\-identical\*(Aq
\&           : [2] collapse = boolean, if non\-zero, consecutive positions are
\&           :             merged using a range notation, e.g.,
\&           :             "1 2 3 4 5 7 9 10 11" collapses to "1\-5 7 9\-11". This
\&           :             is useful for  consolidating long lists. Default = no
\&           :             collapse.
\& Throws    : n/a.
.Ve
.PP
See Also   : \fIBio::Search::HSP::HSPI::seq_inds()\fR
.SS "rewind"
.IX Subsection "rewind"
.Vb 5
\& Title   : rewind
\& Usage   : $hit\->rewind;
\& Function: Allow one to reset the HSP iterator to the beginning if possible
\& Returns : none
\& Args    : none
.Ve
.SS "overlap"
.IX Subsection "overlap"
.Vb 10
\& Usage     : $hit_object\->overlap( [integer] );
\& Purpose   : Gets/Sets the allowable amount overlap between different HSP
\&             sequences.
\& Example   : $hit_object\->overlap(5);
\&           : $overlap = $hit_object\->overlap;
\& Returns   : Integer.
\& Argument  : integer.
\& Throws    : n/a
\& Status    : Deprecated
\& Comments  : This value isn\*(Aqt used for anything
.Ve
.SS "n"
.IX Subsection "n"
.Vb 10
\& Usage     : $hit_object\->n();
\& Purpose   : Gets the N number for the current Blast hit.
\&           : This is the number of HSPs in the set which was ascribed
\&           : the lowest P\-value (listed on the description line).
\&           : This number is not the same as the total number of HSPs.
\&           : To get the total number of HSPs, use num_hsps().
\& Example   : $n = $hit_object\->n();
\& Returns   : Integer
\& Argument  : n/a
\& Throws    : Exception if HSPs have not been set (BLAST2 reports).
\& Comments  : Note that the N parameter is not reported in gapped BLAST2.
\&           : Calling n() on such reports will result in a call to num_hsps().
\&           : The num_hsps() method will count the actual number of
\&           : HSPs in the alignment listing, which may exceed N in
\&           : some cases.
.Ve
.PP
See Also   : \fInum_hsps()\fR
.SS "p"
.IX Subsection "p"
.Vb 10
\& Usage     : $hit_object\->p( [format] );
\& Purpose   : Get the P\-value for the best HSP of the given BLAST hit.
\&           : (Note that P\-values are not provided with NCBI Blast2 reports).
\& Example   : $p =  $sbjct\->p;
\&           : $p =  $sbjct\->p(\*(Aqexp\*(Aq);  # get exponent only.
\&           : ($num, $exp) =  $sbjct\->p(\*(Aqparts\*(Aq); # split sci notation into parts
\& Returns   : Float or scientific notation number (the raw P\-value, DEFAULT).
\&           : Integer if format == \*(Aqexp\*(Aq (the magnitude of the base 10 exponent).
\&           : 2\-element list (float, int) if format == \*(Aqparts\*(Aq and P\-value
\&           :                is in scientific notation (See Comments).
\& Argument  : format: string of \*(Aqraw\*(Aq | \*(Aqexp\*(Aq | \*(Aqparts\*(Aq
\&           :    \*(Aqraw\*(Aq returns value given in report. Default. (1.2e\-34)
\&           :    \*(Aqexp\*(Aq returns exponent value only (34)
\&           :    \*(Aqparts\*(Aq returns the decimal and exponent as a 
\&           :            2\-element list (1.2, \-34) (See Comments).
\& Throws    : Warns if no P\-value is defined. Uses expect instead.
\& Comments  : Using the \*(Aqparts\*(Aq argument is not recommended since it will not
\&           : work as expected if the P\-value is not in scientific notation.
\&           : That is, floats are not converted into sci notation before
\&           : splitting into parts.
.Ve
.PP
See Also   : \fIexpect()\fR, \fIsignif()\fR,
             \fIBio::Search::BlastUtils::get_exponent()\fR
.SS "hsp"
.IX Subsection "hsp"
.Vb 11
\& Usage     : $hit_object\->hsp( [string] );
\& Purpose   : Get a single HSPI object for the present HitI object.
\& Example   : $hspObj  = $hit_object\->hsp;  # same as \*(Aqbest\*(Aq
\&           : $hspObj  = $hit_object\->hsp(\*(Aqbest\*(Aq);
\&           : $hspObj  = $hit_object\->hsp(\*(Aqworst\*(Aq);
\& Returns   : Object reference for a L<Bio::Search::HSP::HSPI> object.
\& Argument  : String (or no argument).
\&           :   No argument (default) = highest scoring HSP (same as \*(Aqbest\*(Aq).
\&           :   \*(Aqbest\*(Aq  = highest scoring HSP.
\&           :   \*(Aqworst\*(Aq = lowest scoring HSP.
\& Throws    : Exception if an unrecognized argument is used.
.Ve
.PP
See Also   : \fIhsps()\fR, num_hsps()
.SS "logical_length"
.IX Subsection "logical_length"
.Vb 10
\& Usage     : $hit_object\->logical_length( [seq_type] );
\&           : (mostly intended for internal use).
\& Purpose   : Get the logical length of the hit sequence.
\&           : If the Blast is a TBLASTN or TBLASTX, the returned length 
\&           : is the length of the would\-be amino acid sequence (length/3).
\&           : For all other BLAST flavors, this function is the same as length().
\& Example   : $len    = $hit_object\->logical_length();
\& Returns   : Integer 
\& Argument  : seq_type = \*(Aqquery\*(Aq or \*(Aqhit\*(Aq or \*(Aqsbjct\*(Aq (default = \*(Aqquery\*(Aq)
\&             (\*(Aqsbjct\*(Aq is synonymous with \*(Aqhit\*(Aq)
\& Throws    : n/a
\& Comments  : This is important for functions like frac_aligned_query()
\&           : which need to operate in amino acid coordinate space when dealing
\&           : with [T]BLAST[NX] type reports.
.Ve
.PP
See Also   : \fIlength()\fR, \fIfrac_aligned_query()\fR,
             \fIfrac_aligned_hit()\fR
.SS "rank"
.IX Subsection "rank"
.Vb 6
\& Title   : rank
\& Usage   : $obj\->rank($newval)
\& Function: Get/Set the rank of this Hit in the Query search list
\&           i.e. this is the Nth hit for a specific query
\& Returns : value of rank
\& Args    : newvalue (optional)
.Ve
.SS "each_accession_number"
.IX Subsection "each_accession_number"
.Vb 7
\& Title   : each_accession_number
\& Usage   : $obj\->each_accession_number
\& Function: Get each accession number listed in the description of the hit.
\&           If there are no alternatives, then only the primary accession will 
\&           be given (if there is one).
\& Returns : list of all accession numbers in the description
\& Args    : none
.Ve
.SS "tiled_hsps"
.IX Subsection "tiled_hsps"
.Vb 10
\& Usage     : $hit_object\->tiled_hsps( [integer] );
\& Purpose   : Gets/Sets an indicator for whether or not the HSPs in this Hit 
\&           : have been tiled.
\& Example   : $hit_object\->tiled_hsps(1);
\&           : if( $hit_object\->tiled_hsps ) { # do something }
\& Returns   : Boolean (1 or 0) 
\& Argument  : integer (optional)
\& Throws    : n/a
\& Status    : Deprecated
\& Notes     : This value is not used for anything
.Ve
.SS "strand"
.IX Subsection "strand"
.Vb 10
\& Usage     : $sbjct\->strand( [seq_type] );
\& Purpose   : Gets the strand(s) for the query, sbjct, or both sequences
\&           : in the best HSP of the BlastHit object after HSP tiling.
\&           : Only valid for BLASTN, TBLASTX, BLASTX\-query, TBLASTN\-hit.
\& Example   : $qstrand = $sbjct\->strand(\*(Aqquery\*(Aq);
\&           : $sstrand = $sbjct\->strand(\*(Aqhit\*(Aq);
\&           : ($qstrand, $sstrand) = $sbjct\->strand();
\& Returns   : scalar context: integer \*(Aq1\*(Aq, \*(Aq\-1\*(Aq, or \*(Aq0\*(Aq
\&           : array context without args: list of two strings (queryStrand, sbjctStrand)
\&           : Array context can be "induced" by providing an argument of \*(Aqlist\*(Aq or \*(Aqarray\*(Aq.
\& Argument  : In scalar context: seq_type = \*(Aqquery\*(Aq or \*(Aqhit\*(Aq or \*(Aqsbjct\*(Aq (default = \*(Aqquery\*(Aq)
\&             (\*(Aqsbjct\*(Aq is synonymous with \*(Aqhit\*(Aq)
\& Throws    : n/a
\& Comments  : This method requires that all HSPs be tiled. If they have not
\&           : already been tiled, they will be tiled first automatically..
\&           : If you don\*(Aqt want the tiled data, iterate through each HSP
\&           : calling strand() on each (use hsps() to get all HSPs).
\&           :
\&           : Formerly (prior to 10/21/02), this method would return the
\&           : string "\-1/1" for hits with HSPs on both strands.
\&           : However, now that strand and frame is properly being accounted
\&           : for during HSP tiling, it makes more sense for strand()
\&           : to return the strand data for the best HSP after tiling.
\&           :
\&           : If you really want to know about hits on opposite strands,
\&           : you should be iterating through the HSPs using methods on the
\&           : HSP objects.
\&           :
\&           : A possible use case where knowing whether a hit has HSPs 
\&           : on both strands would be when filtering via SearchIO for hits with 
\&           : this property. However, in this case it would be better to have a
\&           : dedicated method such as $hit\->hsps_on_both_strands(). Similarly
\&           : for frame. This could be provided if there is interest.
.Ve
.PP
See Also   : Bio::Search::HSP::HSPI::strand()
.SS "frame"
.IX Subsection "frame"
.Vb 11
\& Usage     : $hit_object\->frame();
\& Purpose   : Gets the reading frame for the best HSP after HSP tiling.
\&           : This is only valid for BLASTX and TBLASTN/X type reports.
\& Example   : $frame = $hit_object\->frame();
\& Returns   : Integer (\-2 .. +2)
\& Argument  : n/a
\& Throws    : Exception if HSPs have not been set.
\& Comments  : This method requires that all HSPs be tiled. If they have not
\&           : already been tiled, they will be tiled first automatically..
\&           : If you don\*(Aqt want the tiled data, iterate through each HSP
\&           : calling frame() on each (use hsps() to get all HSPs).
.Ve
.PP
See Also   : \fIhsps()\fR
.SS "length_aln"
.IX Subsection "length_aln"
.Vb 12
\& Usage     : $hit_object\->length_aln( [seq_type] );
\& Purpose   : Get the total length of the aligned region for query or sbjct seq.
\&           : This number will include all HSPs, and excludes gaps.
\& Example   : $len    = $hit_object\->length_aln(); # default = query
\&           : $lenAln = $hit_object\->length_aln(\*(Aqquery\*(Aq);
\& Returns   : Integer 
\& Argument  : seq_Type = \*(Aqquery\*(Aq or \*(Aqhit\*(Aq or \*(Aqsbjct\*(Aq (Default = \*(Aqquery\*(Aq)
\&             (\*(Aqsbjct\*(Aq is synonymous with \*(Aqhit\*(Aq)
\& Throws    : Exception if the argument is not recognized.
\& Comments  : This method will report the logical length of the alignment,
\&           : meaning that for TBLAST[NX] reports, the length is reported
\&           : using amino acid coordinate space (i.e., nucleotides / 3).
.Ve
.PP
See Also   : \fIlength()\fR, \fIfrac_aligned_query()\fR,
             \fIfrac_aligned_hit()\fR, \fIgaps()\fR,
             \fIBio::Search::SearchUtils::tile_hsps()\fR,
             \fIBio::Search::HSP::BlastHSP::length()\fR
.SS "gaps"
.IX Subsection "gaps"
.Vb 10
\& Usage     : $hit_object\->gaps( [seq_type] );
\& Purpose   : Get the number of gaps in the aligned query, hit, or both sequences.
\&           : Data is summed across all HSPs.
\& Example   : $qgaps = $hit_object\->gaps(\*(Aqquery\*(Aq);
\&           : $hgaps = $hit_object\->gaps(\*(Aqhit\*(Aq);
\&           : $tgaps = $hit_object\->gaps();    # default = total (query + hit)
\& Returns   : scalar context: integer
\&           : array context without args: two\-element list of integers  
\&           :    (queryGaps, hitGaps)
\&           : Array context can be forced by providing an argument of \*(Aqlist\*(Aq or
\&                   : \*(Aqarray\*(Aq.
\&           :
\&           : CAUTION: Calling this method within printf or sprintf is arrray
\&                   : context.
\&           : So this function may not give you what you expect. For example:
\&           :          printf "Total gaps: %d", $hit\->gaps();
\&           : Actually returns a two\-element array, so what gets printed 
\&           : is the number of gaps in the query, not the total
\&           :
\& Argument  : seq_type: \*(Aqquery\*(Aq | \*(Aqhit\*(Aq or \*(Aqsbjct\*(Aq | \*(Aqtotal\*(Aq | \*(Aqlist\*(Aq
\&           : (default = \*(Aqtotal\*(Aq) (\*(Aqsbjct\*(Aq is synonymous with \*(Aqhit\*(Aq)
\& Comments  : If you need data for each HSP, use hsps() and then interate
\&           : through each HSP object.
.Ve
.SS "matches"
.IX Subsection "matches"
.Vb 10
\& Usage     : $hit_object\->matches( [class] );
\& Purpose   : Get the total number of identical or conserved matches 
\&           : (or both) across all HSPs.
\&           : (Note: \*(Aqconservative\*(Aq matches are indicated as \*(Aqpositives\*(Aq 
\&           :         in BLAST reports.)
\& Example   : ($id,$cons) = $hit_object\->matches(); # no argument
\&           : $id = $hit_object\->matches(\*(Aqid\*(Aq);
\&           : $cons = $hit_object\->matches(\*(Aqcons\*(Aq); 
\& Returns   : Integer or a 2\-element array of integers 
\& Argument  : [0] class = \*(Aqid\*(Aq | \*(Aqcons\*(Aq OR none.
\&           : [1] seq_type  = \*(Aqquery\*(Aq or \*(Aqhit\*(Aq or \*(Aqsbjct\*(Aq  (default = \*(Aqquery\*(Aq)
\&           :                 (\*(Aqsbjct\*(Aq is synonymous with \*(Aqhit\*(Aq)
\&           : If no argument is provided, both identical and conservative 
\&           : numbers are returned in a two element list.
\&           : (Other terms can be used to refer to the conservative
\&           :  matches, e.g., \*(Aqpositive\*(Aq. All that is checked is whether or
\&           :  not the supplied string starts with \*(Aqid\*(Aq. If not, the 
\&           : conservative matches are returned.)
.Ve
.SS "start"
.IX Subsection "start"
.Vb 10
\& Usage     : $sbjct\->start( [seq_type] );
\& Purpose   : Gets the start coordinate for the query, sbjct, or both sequences
\&           : in the object. If there is more than one HSP, the lowest start
\&           : value of all HSPs is returned.
\& Example   : $qbeg = $sbjct\->start(\*(Aqquery\*(Aq);
\&           : $sbeg = $sbjct\->start(\*(Aqhit\*(Aq);
\&           : ($qbeg, $sbeg) = $sbjct\->start();
\& Returns   : scalar context: integer 
\&           : array context without args: list of two integers (queryStart,
\&           : sbjctStart)
\&           : Array context can be "induced" by providing an argument of \*(Aqlist\*(Aq
\&           : or \*(Aqarray\*(Aq.
\& Argument  : \*(Aqquery\*(Aq or \*(Aqhit\*(Aq or \*(Aqsbjct\*(Aq (default = \*(Aqquery\*(Aq) (\*(Aqsbjct\*(Aq is
\&             synonymous with \*(Aqhit\*(Aq)
.Ve
.SS "end"
.IX Subsection "end"
.Vb 10
\& Usage     : $sbjct\->end( [seq_type] );
\& Purpose   : Gets the end coordinate for the query, sbjct, or both sequences
\&           : in the object. If there is more than one HSP, the largest end
\&           : value of all HSPs is returned.
\& Example   : $qend = $sbjct\->end(\*(Aqquery\*(Aq);
\&           : $send = $sbjct\->end(\*(Aqhit\*(Aq);
\&           : ($qend, $send) = $sbjct\->end();
\& Returns   : scalar context: integer
\&           : array context without args: list of two integers 
\&           : (queryEnd, sbjctEnd)
\&           : Array context can be "induced" by providing an argument 
\&           : of \*(Aqlist\*(Aq or \*(Aqarray\*(Aq.
\& Argument  : \*(Aqquery\*(Aq or \*(Aqhit\*(Aq or \*(Aqsbjct\*(Aq (default = \*(Aqquery\*(Aq) (\*(Aqsbjct\*(Aq is
\&             synonymous with \*(Aqhit\*(Aq)
.Ve
.SS "range"
.IX Subsection "range"
.Vb 9
\& Usage     : $sbjct\->range( [seq_type] );
\& Purpose   : Gets the (start, end) coordinates for the query or sbjct sequence
\&           : in the HSP alignment.
\& Example   : ($qbeg, $qend) = $sbjct\->range(\*(Aqquery\*(Aq);
\&           : ($sbeg, $send) = $sbjct\->range(\*(Aqhit\*(Aq);
\& Returns   : Two\-element array of integers 
\& Argument  : seq_type = string, \*(Aqquery\*(Aq or \*(Aqhit\*(Aq or \*(Aqsbjct\*(Aq  (default = \*(Aqquery\*(Aq)
\&             (\*(Aqsbjct\*(Aq is synonymous with \*(Aqhit\*(Aq)
\& Throws    : n/a
.Ve
.PP
See Also   : \fIstart()\fR, \fIend()\fR
.SS "frac_identical"
.IX Subsection "frac_identical"
.Vb 9
\& Usage     : $hit_object\->frac_identical( [seq_type] );
\& Purpose   : Get the overall fraction of identical positions across all HSPs.
\&           : The number refers to only the aligned regions and does not
\&           : account for unaligned regions in between the HSPs, if any.
\& Example   : $frac_iden = $hit_object\->frac_identical(\*(Aqquery\*(Aq);
\& Returns   : Float (2\-decimal precision, e.g., 0.75).
\& Argument  : seq_type: \*(Aqquery\*(Aq | \*(Aqhit\*(Aq or \*(Aqsbjct\*(Aq | \*(Aqtotal\*(Aq
\&           : default = \*(Aqquery\*(Aq (but see comments below).
\&           : (\*(Aqsbjct\*(Aq is synonymous with \*(Aqhit\*(Aq)
.Ve
.SS "frac_conserved"
.IX Subsection "frac_conserved"
.Vb 9
\& Usage     : $hit_object\->frac_conserved( [seq_type] );
\& Purpose   : Get the overall fraction of conserved positions across all HSPs.
\&           : The number refers to only the aligned regions and does not
\&           : account for unaligned regions in between the HSPs, if any.
\& Example   : $frac_cons = $hit_object\->frac_conserved(\*(Aqhit\*(Aq);
\& Returns   : Float (2\-decimal precision, e.g., 0.75).
\& Argument  : seq_type: \*(Aqquery\*(Aq | \*(Aqhit\*(Aq or \*(Aqsbjct\*(Aq | \*(Aqtotal\*(Aq
\&           : default = \*(Aqquery\*(Aq (but see comments below).
\&           : (\*(Aqsbjct\*(Aq is synonymous with \*(Aqhit\*(Aq)
.Ve
.SS "frac_aligned_query"
.IX Subsection "frac_aligned_query"
.Vb 9
\& Usage     : $hit_object\->frac_aligned_query();
\& Purpose   : Get the fraction of the query sequence which has been aligned
\&           : across all HSPs (not including intervals between non\-overlapping
\&           : HSPs).
\& Example   : $frac_alnq = $hit_object\->frac_aligned_query();
\& Returns   : Float (2\-decimal precision, e.g., 0.75).
\& Argument  : none
\& Comments  : If you need data for each HSP, use hsps() and then interate
\&           : through the HSP objects.
.Ve
.SS "frac_aligned_hit"
.IX Subsection "frac_aligned_hit"
.Vb 9
\& Usage     : $hit_object\->frac_aligned_hit();
\& Purpose   : Get the fraction of the hit (sbjct) sequence which has been aligned
\&           : across all HSPs (not including intervals between non\-overlapping
\&           : HSPs).
\& Example   : $frac_alnq = $hit_object\->frac_aligned_hit();
\& Returns   : Float (2\-decimal precision, e.g., 0.75).
\& Argument  : none
\& Comments  : If you need data for each HSP, use hsps() and then interate
\&           : through the HSP objects.
.Ve
.SS "num_unaligned_hit"
.IX Subsection "num_unaligned_hit"
.Vb 8
\& Usage     : $hit_object\->num_unaligned_hit();
\& Purpose   : Get the number of the unaligned residues in the hit sequence.
\&           : Sums across all all HSPs.
\& Example   : $num_unaln = $hit_object\->num_unaligned_hit();
\& Returns   : Integer
\& Argument  : none
\& Comments  : If you need data for each HSP, use hsps() and then interate
\&           : through the HSP objects.
.Ve
.SS "num_unaligned_query"
.IX Subsection "num_unaligned_query"
.Vb 8
\& Usage     : $hit_object\->num_unaligned_query();
\& Purpose   : Get the number of the unaligned residues in the query sequence.
\&           : Sums across all all HSPs.
\& Example   : $num_unaln = $hit_object\->num_unaligned_query();
\& Returns   : Integer
\& Argument  : none
\& Comments  : If you need data for each HSP, use hsps() and then interate
\&           : through the HSP objects.
.Ve
