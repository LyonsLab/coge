.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::PopGen::HtSNP 3"
.TH Bio::PopGen::HtSNP 3 "2013-05-09" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::PopGen::HtSNP.pm\- Select htSNP from a haplotype set
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Bio::PopGen::HtSNP;
\&
\&    my $obj = Bio::PopGen::HtSNP\->new($hap,$snp,$pop);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Select the minimal set of \s-1SNP\s0 that contains the full information about
the haplotype without redundancies.
.PP
Take as input the followin values:
.IP "\- the haplotype block (array of array)." 4
.IX Item "- the haplotype block (array of array)."
.PD 0
.IP "\- the snp id (array)." 4
.IX Item "- the snp id (array)."
.IP "\- family information and frequency (array of array)." 4
.IX Item "- family information and frequency (array of array)."
.PD
.PP
The final haplotype is generated in a numerical format and the \s-1SNP\s0's
sets can be retrieve from the module.
.PP
\&\fBconsiderations:\fR
.PP
\&\- If you force to include a family with indetermination, the \s-1SNP\s0's
with indetermination will be removed from the analysis, so consider
before to place your data set what do you really want to do.
.PP
\&\- If two families have the same information (identical haplotype), one
of them will be removed and the removed files will be stored classify
as removed.
.PP
\&\- Only are accepted for calculation A, C, G, T and \- (as deletion) and
their combinations. Any other value as n or ? will be considered as
degenerations due to lack of information.
.SS "\s-1RATIONALE\s0"
.IX Subsection "RATIONALE"
On a haplotype set is expected that some of the \s-1SNP\s0 and their
variations contribute in the same way to the haplotype. Eliminating
redundancies will produce a minimal set of \s-1SNP\s0's that can be used as
input for a taging selection process. On the process \s-1SNP\s0's with the
same variation are clustered on the same group.
.PP
The idea is that because the tagging haplotype process is
exponential. All redundant information we could eliminate on the
tagging process will help to find a quick result.
.SS "\s-1CONSTRUCTORS\s0"
.IX Subsection "CONSTRUCTORS"
.Vb 4
\&  my $obj = Bio::PopGen::HtSNP\->new
\&    (\-haplotype_block => \e@haplotype_patterns,
\&     \-snp_ids         => \e@snp_ids,
\&     \-pattern_freq    => \e@pattern_name_and_freq);
.Ve
.PP
where  \f(CW$hap\fR, \f(CW$snp\fR and \f(CW$pop\fR are in the format:
.PP
.Vb 5
\&  my $hap = [
\&             \*(Aqacgt\*(Aq,
\&             \*(Aqagtc\*(Aq,
\&             \*(Aqcgtc\*(Aq
\&            ];                     # haplotype patterns\*(Aq id
\&
\&  my $snp = [qw/s1 s2 s3 s4/];     # snps\*(Aq Id\*(Aqs
\&
\&  my $pop = [
\&             [qw/ uno    0.20/],
\&             [qw/ dos    0.20/],
\&             [qw/ tres   0.15/],
\&            ];                     # haplotype_pattern_id    Frequency
.Ve
.SS "\s-1OBJECT\s0 \s-1METHODS\s0"
.IX Subsection "OBJECT METHODS"
.Vb 1
\&    See Below for more detailed summaries.
.Ve
.SH "DETAILS"
.IX Header "DETAILS"
.SS "How the process is working with one example"
.IX Subsection "How the process is working with one example"
Let's begin with one general example of the code.
.PP
Input haplotype:
.PP
.Vb 4
\&  acgtcca\-t
\&  cggtagtgc
\&  cccccgtgc
\&  cgctcgtgc
.Ve
.PP
The first thing to to is to \fBsplit the haplotype\fR into characters.
.PP
.Vb 4
\&  a       c       g       t       c       c       a       \-       t
\&  c       g       g       t       a       g       t       g       c
\&  c       c       c       c       c       g       t       g       c
\&  c       g       c       t       c       g       t       g       c
.Ve
.PP
Now we have to \fBconvert\fR the haplotype to \fBUpercase\fR. This
will produce the same \s-1SNP\s0 if we have input a or A.
.PP
.Vb 4
\&  A       C       G       T       C       C       A       \-       T
\&  C       G       G       T       A       G       T       G       C
\&  C       C       C       C       C       G       T       G       C
\&  C       G       C       T       C       G       T       G       C
.Ve
.PP
The program admit as values any combination of \s-1ACTG\s0 and \- (deletions).
The haplotype is \fBconverted to number\fR, considering the first variation
as zero and the alternate value as 1 (see expanded description below).
.PP
.Vb 4
\&  0       0       0       0       0       0       0       0       0
\&  1       1       0       0       1       1       1       1       1
\&  1       0       1       1       0       1       1       1       1
\&  1       1       1       0       0       1       1       1       1
.Ve
.PP
Once we have the haplotype converted to numbers we have to generate the
snp type information for the haplotype.
.PP
\&\fB\s-1SNP\s0 code = \s-1SUM\s0 ( value * multiplicity ^ position );\fR
.PP
.Vb 5
\&    where:
\&      SUM is the sum of the values for the SNP
\&      value is the SNP number code (0 [generally for the mayor allele],
\&                                    1 [for the minor allele].
\&      position is the position on the block.
.Ve
.PP
For this example the code is:
.PP
.Vb 6
\&  0       0       0       0       0       0       0       0       0
\&  1       1       0       0       1       1       1       1       1
\&  1       0       1       1       0       1       1       1       1
\&  1       1       1       0       0       1       1       1       1
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  14      10      12      4       2       14      14      14      14
\&
\&  14 = 0*2^0 + 1*2^1 + 1*2^2 + 1*2^3
\&  12 = 0*2^0 + 1*2^1 + 0*2^2 + 1*2^3
\&  ....
.Ve
.PP
Once we have the families classify. We will \fBtake\fR just the \s-1SNP\s0's \fBnot
redundant\fR.
.PP
.Vb 1
\&  14      10      12      4       2
.Ve
.PP
This information will be \fBpassed to the tag module\fR is you want to tag
the htSNP.
.PP
Whatever it happens to one SNPs of a class will happen to a \s-1SNP\s0 of
the same class. Therefore you don't need to scan redundancies
.SS "Working with fuzzy data."
.IX Subsection "Working with fuzzy data."
This module is designed to work with fuzzy data. As the source of the
haplotype is diverse. The program assume that some haplotypes can be
generated using different values. If there is any indetermination (? or n)
or any other degenerated value or invalid. The program will take away
This \s-1SNP\s0 and will leave that for a further analysis.
.PP
On a complex situation:
.PP
.Vb 7
\&  a       c       g       t       ?       c       a       c       t
\&  a       c       g       t       ?       c       a       \-       t
\&  c       g       ?       t       a       g       ?       g       c
\&  c       a       c       t       c       g       t       g       c
\&  c       g       c       t       c       g       t       g       c
\&  c       g       g       t       a       g       ?       g       c
\&  a       c       ?       t       ?       c       a       c       t
.Ve
.PP
On this haplotype everything is happening. We have a multialelic variance.
We have indeterminations. We have deletions and we have even one \s-1SNP\s0
which is not a real \s-1SNP\s0.
.PP
The buiding process will be the same on this situation.
.PP
Convert the haplotype to uppercase.
.PP
.Vb 7
\&  A       C       G       T       ?       C       A       C       T
\&  A       C       G       T       ?       C       A       \-       T
\&  C       G       ?       T       A       G       ?       G       C
\&  C       A       C       T       C       G       T       G       C
\&  C       G       C       T       C       G       T       G       C
\&  C       G       G       T       A       G       ?       G       C
\&  A       C       ?       T       ?       C       A       C       T
.Ve
.PP
All columns that present indeterminations will be removed from the analysis
on this Step.
.PP
hapotype after remove columns:
.PP
.Vb 7
\&  A       C       T       C       C       T
\&  A       C       T       C       \-       T
\&  C       G       T       G       G       C
\&  C       A       T       G       G       C
\&  C       G       T       G       G       C
\&  C       G       T       G       G       C
\&  A       C       T       C       C       T
.Ve
.PP
All changes made on the haplotype matrix, will be also made on the \s-1SNP\s0 list.
.PP
.Vb 1
\&  snp_id_1 snp_id_2 snp_id_4 snp_id_6 snp_id_8 snp_id_9
.Ve
.PP
now the \s-1SNP\s0 that is not one \s-1SNP\s0 will be removed from the analysis.
\&\s-1SNP\s0 with Id snp_id_4 (the one with all T's).
.PP
because of the removing. Some of the families will become the same and will
be clustered. A posteriori analysis will diference these families.
but because of the indetermination can not be distinguish.
.PP
.Vb 7
\&  A       C       C       C       T
\&  A       C       C       \-       T
\&  C       G       G       G       C
\&  C       A       G       G       C
\&  C       G       G       G       C
\&  C       G       G       G       C
\&  A       C       C       C       T
.Ve
.PP
The result of the mergering will go like:
.PP
.Vb 4
\&  A       C       C       C       T
\&  A       C       C       \-       T
\&  C       G       G       G       C
\&  C       A       G       G       C
.Ve
.PP
Once again the changes made on the families and we merge the frequency (\fIto be
implemented\fR)
.PP
Before to convert the haplotype into numbers we consider how many variations
we have on the set. On this case the variations are 3.
.PP
The control code will use on this situation base three as mutiplicity
.PP
.Vb 6
\&  0       0       0       0       0
\&  0       0       0       1       0
\&  1       1       1       2       1
\&  1       2       1       2       1
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  36      63      36      75      36
.Ve
.PP
And the minimal set for this combination is
.PP
.Vb 4
\&  0       0       0
\&  0       0       1
\&  1       1       2
\&  1       2       2
.Ve
.PP
\&\fB\s-1NOTE:\s0\fR this second example is a remote example an on normal conditions. This
conditions makes no sense, but as the haplotypes, can come from many sources
we have to be ready for all kind of combinations.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to
the Bioperl mailing list.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
of the bugs and their resolution. Bug reports can be submitted via
the web:
.PP
.Vb 1
\&  https://redmine.open\-bio.org/projects/bioperl/
.Ve
.SH "AUTHOR \- Pedro M. Gomez-Fabre"
.IX Header "AUTHOR - Pedro M. Gomez-Fabre"
Email pgf18872\-at\-gsk\-dot\-com
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _
.SS "new"
.IX Subsection "new"
.Vb 10
\& Title   : new
\& Function: constructor of the class.
\& Usage   : $obj\-> Bio::PopGen::HtSNP\->new(\-haplotype_block
\&                                          \-snp_ids
\&                                          \-pattern_freq)
\& Returns : self hash
\& Args    : input haplotype (array of array)
\&           snp_ids         (array)
\&           pop_freq        (array of array)
\& Status  : public
.Ve
.SS "haplotype_block"
.IX Subsection "haplotype_block"
.Vb 5
\& Title   : haplotype_block 
\& Usage   : my $haplotype_block = $HtSNP\->haplotype_block();
\& Function: Get the haplotype block for a haplotype tagging selection
\& Returns : reference of array 
\& Args    : reference of array with haplotype pattern
.Ve
.SS "snp_ids"
.IX Subsection "snp_ids"
.Vb 5
\& Title   : snp_ids 
\& Usage   : my $snp_ids = $HtSNP\->$snp_ids();
\& Function: Get the ids for a haplotype tagging selection
\& Returns : reference of array
\& Args    : reference of array with SNP ids
.Ve
.SS "pattern_freq"
.IX Subsection "pattern_freq"
.Vb 6
\& Title   : pattern_freq
\& Usage   : my $pattern_freq = $HtSNP\->pattern_freq();
\& Function: Get the pattern id and frequency  for a haplotype
\&           tagging selection
\& Returns : reference of array
\& Args    : reference of array with SNP ids
.Ve
.SS "_check_input"
.IX Subsection "_check_input"
.Vb 6
\& Title   : _check_input
\& Usage   : _check_input($self)
\& Function: check for errors on the input
\& Returns : self hash
\& Args    : self
\& Status  : internal
.Ve
.SS "_haplotype_length_error"
.IX Subsection "_haplotype_length_error"
.Vb 7
\& Title   : _haplotype_length_error
\& Usage   : _haplotype_length_error($self)
\& Function: check if the haplotype length is the same that the one on the
\&           SNP id list. If not break and exit
\& Returns : self hash
\& Args    : self
\& Status  : internal
.Ve
.SS "_population_error"
.IX Subsection "_population_error"
.Vb 7
\& Title   : _population_error
\& Usage   : _population_error($self)
\& Function: use input_block and pop_freq test if the number of elements
\&           match. If doesn\*(Aqt break and quit.
\& Returns : self hash
\& Args    : self
\& Status  : internal
.Ve
.SS "_do_it"
.IX Subsection "_do_it"
.Vb 6
\& Title   : _do_it
\& Usage   : _do_it($self)
\& Function: Process the input generating the results.
\& Returns : self hash
\& Args    : self
\& Status  : internal
.Ve
.SS "input_block"
.IX Subsection "input_block"
.Vb 6
\& Title   : input_block
\& Usage   : $obj\->input_block()
\& Function: returns input block
\& Returns : reference to array of array
\& Args    : none
\& Status  : public
.Ve
.SS "hap_length"
.IX Subsection "hap_length"
.Vb 6
\& Title   : hap_length
\& Usage   : $obj\->hap_length()
\& Function: get numbers of SNP on the haplotype
\& Returns : scalar
\& Args    : none
\& Status  : public
.Ve
.SS "pop_freq"
.IX Subsection "pop_freq"
.Vb 6
\& Title   : pop_freq
\& Usage   : $obj\->pop_freq()
\& Function: returns population frequency
\& Returns : reference to array
\& Args    : none
\& Status  : public
.Ve
.SS "deg_snp"
.IX Subsection "deg_snp"
.Vb 6
\& Title   : deg_snp
\& Usage   : $obj\->deg_snp()
\& Function: returns snp_removes due to indetermination on their values
\& Returns : reference to array
\& Args    : none
\& Status  : public
.Ve
.SS "snp_type"
.IX Subsection "snp_type"
.Vb 6
\& Title   : snp_type
\& Usage   : $obj\->snp_type()
\& Function: returns hash with SNP type
\& Returns : reference to hash
\& Args    : none
\& Status  : public
.Ve
.SS "silent_snp"
.IX Subsection "silent_snp"
.Vb 7
\& Title   : silent_snp
\& Usage   : $obj\->silent_snp()
\& Function: some SNP\*(Aqs are silent (not contibuting to the haplotype)
\&           and are not considering for this analysis
\& Returns : reference to a array
\& Args    : none
\& Status  : public
.Ve
.SS "useful_snp"
.IX Subsection "useful_snp"
.Vb 8
\& Title   : useful_snp
\& Usage   : $obj\->useful_snp()
\& Function: returns list of SNP\*(Aqs that are can be used as htSNP. Some
\&           of them can produce the same information. But this is
\&           not considered here.
\& Returns : reference to a array
\& Args    : none
\& Status  : public
.Ve
.SS "ht_type"
.IX Subsection "ht_type"
.Vb 8
\& Title   : ht_type
\& Usage   : $obj\->ht_type()
\& Function: every useful SNP has a numeric code dependending of its
\&           value and position. For a better description see
\&           description of the module.
\& Returns : reference to a array
\& Args    : none
\& Status  : public
.Ve
.SS "ht_set"
.IX Subsection "ht_set"
.Vb 9
\& Title   : ht_set
\& Usage   : $obj\->ht_set()
\& Function: returns the minimal haplotype in numerical format. This
\&           haplotype contains the maximal information about the
\&           haplotype variations but with no redundancies. It\*(Aqs the
\&           minimal set that describes the haplotype.
\& Returns : reference to an array of arrays
\& Args    : none
\& Status  : public
.Ve
.SS "snp_type_code"
.IX Subsection "snp_type_code"
.Vb 7
\& Title   : snp_type_code
\& Usage   : $obj\->snp_type_code()
\& Function: returns the numeric code of the SNPs that need to be
\&           tagged that correspond to the SNP\*(Aqs considered in ht_set.
\& Returns : reference to an array
\& Args    : none
\& Status  : public
.Ve
.SS "snp_and_code"
.IX Subsection "snp_and_code"
.Vb 9
\& Title   : snp_and_code
\& Usage   : $obj\->snp_and_code()
\& Function: Returns the full list of SNP\*(Aqs and the code associate to
\&           them. If the SNP belongs to the group useful_snp it keep
\&           this code. If the SNP is silent the code is 0. And if the
\&           SNP is degenerated the code is \-1.
\& Returns : reference to an array of array
\& Args    : none
\& Status  : public
.Ve
.SS "deg_pattern"
.IX Subsection "deg_pattern"
.Vb 9
\& Title   : deg_pattern
\& Usage   : $obj\->deg_pattern()
\& Function: Returns the a list with the degenerated haplotype.
\&           Sometimes due to degeneration some haplotypes looks
\&           the same and if we don\*(Aqt remove them it won\*(Aqt find
\&           any tag.
\& Returns : reference to a hash of array
\& Args    : none
\& Status  : public
.Ve
.SS "split_hap"
.IX Subsection "split_hap"
.Vb 7
\& Title   : split_hap
\& Usage   : $obj\->split_hap()
\& Function: simple representation of the haplotype base by base
\&           Same information that input haplotype but base based.
\& Returns : reference to an array of array
\& Args    : none
\& Status  : public
.Ve
.SS "_split_haplo"
.IX Subsection "_split_haplo"
.Vb 6
\& Title   : _split_haplo
\& Usage   : _split_haplo($self)
\& Function: Take a haplotype and split it into bases
\& Returns : self
\& Args    : none
\& Status  : internal
.Ve
.SS "_to_upper_case"
.IX Subsection "_to_upper_case"
.Vb 6
\& Title   : _to_upper_case
\& Usage   : _to_upper_case()
\& Function: make SNP or in\-dels Upper case
\& Returns : self
\& Args    : an AoA ref
\& Status  : private
.Ve
.SS "_remove_deg"
.IX Subsection "_remove_deg"
.Vb 7
\& Title   : _remove_deg
\& Usage   : _remove_deg()
\& Function: when have a indetermination or strange value this SNP
\&           is removed
\& Returns : haplotype family set and degeneration list
\& Args    : ref to an AoA and a ref to an array
\& Status  : internal
.Ve
.SS "_rem_silent_snp"
.IX Subsection "_rem_silent_snp"
.Vb 8
\& Title   : _rem_silent_snp
\& Usage   : _rem_silent_snp()
\& Function: there is the remote possibilty that one SNP won\*(Aqt be a
\&           real SNP on this situation we have to remove this SNP,
\&           otherwise the program won\*(Aqt find any tag
\& Returns : nonthing
\& Args    : ref to an AoA and a ref to an array
\& Status  : internal
.Ve
.SS "_find_silent_snps"
.IX Subsection "_find_silent_snps"
.Vb 8
\& Title   : _find_silent_snps
\& Usage   :
\& Function: list of snps that are not SNPs. All values for that
\&           SNPs on the set is the same one. Look stupid but can
\&           happend and if this happend you will not find any tag
\& Returns : nothing
\& Args    :
\& Status  :
.Ve
.SS "_find_indet"
.IX Subsection "_find_indet"
.Vb 7
\& Title   : _find_indet
\& Usage   :
\& Function: find column (SNP) with invalid or degenerated values
\&           and store this values into the second parameter supplied.
\& Returns : nothing
\& Args    : ref to AoA and ref to an array
\& Status  : internal
.Ve
.SS "_remove_col"
.IX Subsection "_remove_col"
.Vb 7
\& Title   : _remove_col
\& Usage   :
\& Function: remove columns contained on the second array from
\&           the first arr
\& Returns : nothing
\& Args    : array of array reference and array reference
\& Status  : internal
.Ve
.SS "_remove_snp_id"
.IX Subsection "_remove_snp_id"
.Vb 7
\& Title   : _remove_snp_id
\& Usage   :
\& Function: remove columns contained on the second array from
\&           the first arr
\& Returns : nothing
\& Args    : array of array reference and array reference
\& Status  : internal
.Ve
.SS "_find_deg_pattern"
.IX Subsection "_find_deg_pattern"
.Vb 6
\& Title   : _find_deg_pattern
\& Usage   :
\& Function: create a list with the degenerated patterns
\& Returns : @array
\& Args    : a ref to AoA
\& Status  : public
.Ve
.SS "_keep_these_patterns"
.IX Subsection "_keep_these_patterns"
.Vb 7
\& Title   : _keep_these_patterns
\& Usage   :
\& Function: this is a basic approach, take a LoL and a list,
\&           keep just the columns included on the list
\& Returns : nothing
\& Args    : an AoA and an array
\& Status  : public
.Ve
.SS "compare_arrays"
.IX Subsection "compare_arrays"
.Vb 7
\& Title   : compare_arrays
\& Usage   :
\& Function: take two arrays and compare their values
\& Returns : 1 if the two values are the same
\&           0 if the values are different
\& Args    : an AoA and an array
\& Status  : public
.Ve
.SS "_convert_to_numbers"
.IX Subsection "_convert_to_numbers"
.Vb 7
\& Title   : _convert_to_numbers
\& Usage   : _convert_to_numbers()
\& Function: tranform the haplotype into numbers. before to do that
\&           we have to consider the variation on the set.
\& Returns : nonthing
\& Args    : ref to an AoA and a ref to an array
\& Status  : internal
.Ve
.SS "_snp_type_code"
.IX Subsection "_snp_type_code"
.Vb 5
\& Title   : _snp_type_code
\& Usage   :
\& Function:
\&           we have to create the snp type code for each version.
\&           The way the snp type is created is the following:
\&
\&           we take the number value for every SNP and do the
\&           following calculation
\&
\&           let be a SNP set as follow:
\&
\&           0    0
\&           1    1
\&           1    2
\&
\&           and multiplicity 3
\&           on this case the situation is:
\&
\&           sum (value * multiplicity ^ position) for each SNP
\&
\&           0 * 3 ^ 0 + 1 * 3 ^ 1 + 1 * 3 ^ 2 = 12
\&           0 * 3 ^ 0 + 1 * 3 ^ 1 + 2 * 3 ^ 2 = 21
\& Returns : nothing
\& Args    : $self
\& Status  : private
.Ve
.SS "_alleles_number"
.IX Subsection "_alleles_number"
.Vb 8
\& Title   : _alleles_number
\& Usage   :
\& Function: calculate the max number of alleles for a haplotype and
\&           if the number. For each SNP the number is stored and the
\&           max number of alleles for a SNP on the set is returned
\& Returns : max number of alleles (a scalar storing a number)
\& Args    : ref to AoA
\& Status  : public
.Ve
.SS "_htSNP"
.IX Subsection "_htSNP"
.Vb 7
\& Title   : _htSNP
\& Usage   : _htSNP()
\& Function: calculate the minimal set that contains all information of the
\&           haplotype.
\& Returns : nonthing
\& Args    : ref to an AoA and a ref to an array
\& Status  : internal
.Ve
.SS "_snp_and_code_summary"
.IX Subsection "_snp_and_code_summary"
.Vb 6
\& Title   : _snp_and_code_summary
\& Usage   : _snp_and_code_summary()
\& Function: compile on a list all SNP and the code for each. This
\&           information can be also obtained combining snp_type and
\&           snp_type_code but on these results the information about
\&           the rest of SNP\*(Aqs are not compiled as table.
\&
\&           0 will be silent SNPs
\&           \-1 are degenerated SNPs
\&           and the rest of positive values are the code for useful SNP
\&
\& Returns : nonthing
\& Args    : ref to an AoA and a ref to an array
\& Status  : internal
.Ve
