.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::SeqIO::agave 3"
.TH Bio::SeqIO::agave 3 "2013-05-09" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::SeqIO::agave \- AGAVE sequence output stream.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
It is probably best not to use this object directly, but
rather go through the SeqIO handler system. Go:
.PP
.Vb 2
\&  $in  = Bio::SeqIO\->new(\*(Aq\-file\*(Aq   => "$file_in",
\&                         \*(Aq\-format\*(Aq => \*(AqEMBL\*(Aq);
\&
\&  $out = Bio::SeqIO\->new(\*(Aq\-file\*(Aq   => ">$file_out",
\&                         \*(Aq\-format\*(Aq => \*(AqAGAVE\*(Aq);
\&
\&  while (my $seq = $in\->next_seq){
\&        $out\->write_seq($seq);
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This object can transform Bio::Seq objects to agave xml file and
vice-versa.  I (Simon) coded up this module because I needed a parser
to extract data from \s-1AGAVE\s0 xml to be utitlized by the GenQuire genome
annotation system (See http://www.bioinformatics.org/Genquire).
.PP
***NOTE*** At the moment, not all of the tags are implemented.  In
general, I followed the output format for the \s-1XEMBL\s0 project
http://www.ebi.ac.uk/xembl/
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.
Bug reports can be submitted via the web:
.PP
.Vb 1
\&  https://redmine.open\-bio.org/projects/bioperl/
.Ve
.SH "AUTHOR \- Simon K. Chan"
.IX Header "AUTHOR - Simon K. Chan"
Email:
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object
methods. Internal methods are usually preceded with a _
.SS "_process"
.IX Subsection "_process"
.Vb 8
\&  Title    : _process
\&  Usage    : $self\->_process
\&  Function : Parses the agave xml file.
\&  Args     : None.
\&  Returns  : Nothing.
\&  Note     : Method(s) that call(s) this method : _initialize
\&             Method(s) that this method calls   : _process_sciobj
\&             FIRST/START sub.
.Ve
.SS "_process_sciobj"
.IX Subsection "_process_sciobj"
.Vb 9
\&  Title    : _process_sciobj
\&  Usage    : $self\->_process_sciobj
\&  Function : Parses the data between the <sciobj></sciobj> tags.
\&  Args     : The string that holds the attributes for <sciobj>.
\&  Returns  : Data structure holding the values parsed between
\&             the <sciobj></sciobj> tags.
\&  Note     : Method(s) that call(s) this method : _process
\&             Method(s) that this method calls   :
\&             _helper_store_attribute_list , _process_contig
.Ve
.SS "_process_contig"
.IX Subsection "_process_contig"
.Vb 12
\&  Title    : _process_contig
\&  Usage    : $self\->_process_contig
\&  Function : Parses the data between the <contig></contig> tags.
\&  Args     : 2 scalars:
\&             \- reference to a scalar holding the line to be parsed.
\&             \- scalar holding the attributes for the <contig> tag
\&               to be parsed.
\&  Returns  : Data structure holding the values parsed between
\&             the <contig></contig> tags.
\&  Note     : Method(s) that call(s) this method : _process_sciobj
\&             Method(s) that this method calls   :
\&             _helper_store_attribute_list, _one_tag , _process_fragment_order
.Ve
.SS "_process_fragment_order"
.IX Subsection "_process_fragment_order"
.Vb 10
\&  Title    : _process_fragment_order
\&  Usage    : $self\->_process_fragment_order
\&  Function : Parses the data between the <fragment_order></fragment_order> tags.
\&  Args     : 2 scalars:
\&             \- reference to a scalar holding the value of the line to be parsed.
\&             \- reference to a data structure to store the <fragment_order> data.
\&  Returns  : Nothing.
\&  Note     : Method(s) that call(s) this method : _process_contig
\&             Method(s) that this method calls   :
\&             _helper_store_attribute_list , _process_fragment_orientation
.Ve
.SS "_process_fragment_orientation"
.IX Subsection "_process_fragment_orientation"
.Vb 9
\&  Title    : _process_fragment_orientation
\&  Usage    : $self\->_process_fragment_orientation
\&  Function : Parses the data between the <fragment_orientation> and
\&             </fragment_orientation> tags.
\&  Args     : 2 scalars:
\&             \- reference to a scalar holding the value of the line to be parsed.
\&             \- reference to a data structure to store the <fragment_orientation> data.
\&  Returns  : Nothing.
\&  Note     : Method(s) that call(s) this method : _process_fragment_order
.Ve
.PP
Method(s) that this method calls : _helper_store_attribute_list ,
_process_bio_sequence
.SS "_process_bio_sequence"
.IX Subsection "_process_bio_sequence"
.Vb 8
\&  Title    : _process_bio_sequence
\&  Usage    : $self\->_process_bio_sequence
\&  Function : Parses the data between the <bio_sequence></bio_sequence> tags.
\&  Args     : 2 scalars:
\&             \- reference to a scalar holding the value of the line to be parsed.
\&             \- scalar holding the value of the attributes for <bio_sequence>
\&  Returns  : data structure holding the values between <bio_sequence></bio_sequence>
\&  Note     : Method(s) that call(s) this method : _process_fragment_orientation
.Ve
.PP
Method(s) that this method calls : _helper_store_attribute_list ,
_one_tag , _question_mark_tag , _star_tag , _process_alt_ids ,
_process_xrefs , _process_sequence_map
.SS "_process_xrefs"
.IX Subsection "_process_xrefs"
.Vb 7
\&  Title    : _process_xrefs
\&  Usage    : $self\->_process_xrefs
\&  Function : Parse the data between the <xrefs></xrefs> tags.
\&  Args     : reference to a scalar holding the value of the line to be parsed.
\&  Return   : Nothing.
\&  Note     : Method(s) that call(s) this method: _process_bio_sequence
\&             Method(s) that this method calls: _one_tag , _process_xref
.Ve
.SS "_process_xref"
.IX Subsection "_process_xref"
.Vb 9
\&  Title    : _process_xref
\&  Usage    : $self\->_process_xref
\&  Function : Parses the data between the <xref></xref> tags.
\&  Args     : 2 scalars:
\&             \- reference to a scalar holding the value of the line to be parsed.
\&             \- reference to a data structure to store the <xref> data.
\&  Returns  : Nothing.
\&  Note     : Method(s) that call(s) this method : _process_xrefs (note the \*(Aqs\*(Aq in \*(Aqxrefs\*(Aq)
\&             Method(s) that this method calls   : _helper_store_attribute_list , _star_tag
.Ve
.SS "_process_sequence_map"
.IX Subsection "_process_sequence_map"
.Vb 8
\&  Title    : _process_sequence_map
\&  Usage    : $self\->_process_sequence_map
\&  Function : Parses the data between the <sequence_map></sequence_map> tags.
\&  Args     : Reference to scalar holding the line to be parsed.
\&  Returns  : Data structure that holds the values that were parsed.
\&  Note     : Method(s) that call(s) this method : _process_bio_sequence
\&             Method(s) that this method calls   : _helper_store_attribute_list ,
\&                _question_mark_tag , _process_annotations
.Ve
.SS "_process_annotations"
.IX Subsection "_process_annotations"
.Vb 7
\&  Title    : _process_annotations
\&  Usage    : $self\->_process_annotations
\&  Function : Parse the data between the <annotations></annotations> tags.
\&  Args     : Reference to scalar holding the line to be parsed.
\&  Returns  : Data structure that holds the values that were parsed.
\&  Note     : Method(s) that call(s) this method : _process_sequence_map
\&             Method(s) that this method calls   : _process_seq_feature
.Ve
.SS "_process_seq_feature"
.IX Subsection "_process_seq_feature"
.Vb 8
\&  Title    : _process_seq_feature
\&  Usage    : $self\->_process_seq_feature
\&  Function : Parses the data between the <seq_feature></seq_feature> tag.
\&  Args     : 2 scalars:
\&             \- Reference to scalar holding the line to be parsed.
\&             \- Scalar holding the attributes for <seq_feature>.
\&  Returns  : Data structure holding the values parsed.
\&  Note     : Method(s) that call(s) this method: _process_annotations
.Ve
.PP
Method(s) that this method calls: _helper_store_attribute_list ,
_process_classification , _question_mark_tag , _one_tag ,
_process_evidence , _process_qualifier , _process_seq_feature ,
_process_related_annot
.SS "_process_qualifier"
.IX Subsection "_process_qualifier"
.Vb 9
\&  Title    : _process_qualifier
\&  Usage    : $self\->_process_qualifier
\&  Function : Parse the data between the <qualifier></qualifier> tags.
\&  Args     : 2 scalars:
\&             \- reference to a scalar holding the value of the line to be parsed.
\&             \- reference to a data structure to store the <qualifer> data.
\&  Returns  : Nothing.
\&  Note     : Method(s) that call(s) this method : _process_seq_feature
\&             Method(s) that this method calls   : _star_tag
.Ve
.SS "_process_classification"
.IX Subsection "_process_classification"
.Vb 8
\&  Title   : _process_classification
\&  Usage   : $self\->_process_classification
\&  Function: Parse the data between the <classification></classification> tags.
\&  Args    :   2 scalars:
\&            \- reference to a scalar holding the value of the line to be parsed.
\&            \- reference to a data structure to store the <qualifer> data.
\&  Returns : Nothing.
\&  Note    : Method(s) that call(s) this method: _process_seq_feature
\&
\&  Method(s) that this method calls: _helper_store_attribute_list ,
\&  _question_mark_tag , _star_tag, _process_evidence
.Ve
.SS "_tag_processing_helper"
.IX Subsection "_tag_processing_helper"
.Vb 10
\&  Title    : _tag_processing_helper
\&  Usage    : $self\->_tag_processing_helper
\&  Function : Stores the tag value within the data structure.
\&             Also calls _helper_store_attribute_list to store the 
\&             attributes and their values in the data structure.
\&  Args     : 5 scalars:
\&             \- Scalar holding the value of the attributes
\&             \- Reference to a data structure to store the data for <$tag_name>
\&             \- Scalar holding the tag name.
\&             \- Scalar holding the value of the tag.
\&             \- Scalar holding the value of either \*(Aqstar\*(Aq, \*(Aqplus\*(Aq, 
\&               or \*(Aqquestion mark\*(Aq which specifies what type of method
\&               called this method.
\&  Returns  : Nothing.
\&  Note     : Method(s) that call(s) this method:
\&             Method(s) that this method calls: _helper_store_attribute_list
.Ve
.SS "_one_tag"
.IX Subsection "_one_tag"
.Vb 9
\&  Title    : _one_tag
\&  Usage    : $self\->_one_tag
\&  Function : A method to store data from tags that occurs just once.
\&  Args     : 2 scalars:
\&             \- reference to a scalar holding the value of the line to be parsed.
\&             \- reference to a data structure to store the data for <$tag_name>
\&  Returns  : Nothing.
\&  Note     : Method(s) that call(s) this method : many
\&             Method(s) that this method calls   : _tag_processing_helper
.Ve
.SS "_question_mark_tag"
.IX Subsection "_question_mark_tag"
.Vb 10
\&  Title    : _question_mark_tag
\&  Usage    : $self\->_question_mark_tag
\&  Function : Parses values from tags that occurs zero or one time. ie: tag_name?
\&  Args     : 3 scalars:
\&             \- reference to a scalar holding the value of the line to be parsed.
\&             \- reference to a data structure to store the data for <$tag_name>
\&             \- scalar holding the name of the tag.
\&  Returns  : Nothing.
\&  Note     : Method(s) that call(s) this method : many.
\&             Method(s) that this method calls   : _tag_processing_helper
.Ve
.SS "_star_tag"
.IX Subsection "_star_tag"
.Vb 10
\&  Title    : _star_tag
\&  Usage    : $self\->_star_tag
\&  Function : Parses values from tags that occur zero or more times. ie: tag_name*
\&  Args     : 3 scalars:
\&             \- reference to a scalar holding the value of the line to be parsed.
\&             \- reference to a data structure to store the data for <$tag_name>
\&             \- scalar holding the name of the tag.
\&  Returns  : Nothing.
\&  Note     : Method(s) that call(s) this method : many.
\&             Method(s) that this method calls   : _tag_processing_helper
.Ve
.SS "_plus_tag"
.IX Subsection "_plus_tag"
.Vb 10
\&  Title    : _plus_tag
\&  Usage    : $self\->_plus_tag
\&  Function : Handles \*(Aqplus\*(Aq tags (tags that occur one or more times).  tag_name+
\&  Args     : 3 scalars:
\&             \- reference to a scalar holding the value of the line to be parsed.
\&             \- reference to a data structure to store the data for <$tag_name>
\&             \- scalar holding the name of the tag.
\&  Returns  : Nothing.
\&  Note     : Method(s) that call(s) this method : many.
\&             Method(s) that this method calls   : _star_tag
.Ve
.SS "_helper_store_attribute_list"
.IX Subsection "_helper_store_attribute_list"
.Vb 10
\&  Title    : _helper_store_attribute_list
\&  Usage    : $self\->_helper_store_attribute_list
\&  Function : A helper method used to store the attributes from
\&             the tags into the data structure.
\&  Args     : 2 scalars:
\&             \- scalar holding the attribute values to be parsed.
\&             \- reference to a data structure to store the data between the 2 tags.
\&  Returns  : Nothing.
\&  Note     : Method(s) that call(s) this method : Many.
\&             Method(s) that this method call(s) : None.
.Ve
.SS "_store_seqs"
.IX Subsection "_store_seqs"
.Vb 9
\&  Title    : _store_seqs
\&  Usage    : $self\->_store_seqs
\&  Function : This method is called once in the life time of the script.
\&             It stores the data parsed from the agave xml file into
\&             the Bio::Seq object.
\&  Args     : None.
\&  Returns  : Nothing.
\&  Note     : Method(s) that call(s) this method : next_seq
\&             Method(s) that this method calls   : None.
.Ve
.SS "next_seq"
.IX Subsection "next_seq"
.Vb 5
\&        Title    : next_seq
\&        Usage    : $seq = $stream\->next_seq()
\&        Function : Returns the next sequence in the stream.
\&        Args     : None.
\&        Returns  : Bio::Seq object
.Ve
.PP
Method is called from the script.  Method(s) that this method calls:
_store_seqs (only once throughout the life time of script execution).
.SS "next_primary_seq"
.IX Subsection "next_primary_seq"
.Vb 5
\&  Title   : next_primary_seq
\&  Usage   : $seq = $stream\->next_primary_seq()
\&  Function: returns the next primary sequence (ie no seq_features) in the stream
\&  Returns : Bio::PrimarySeq object
\&  Args    : NONE
.Ve
.SS "write_seq"
.IX Subsection "write_seq"
.Vb 5
\&  Title   : write_seq
\&  Usage   : Not Yet Implemented! $stream\->write_seq(@seq)
\&  Function: writes the $seq object into the stream
\&  Returns : 1 for success and 0 for error
\&  Args    : Bio::Seq object
.Ve
.SS "_write_each_record"
.IX Subsection "_write_each_record"
.Vb 5
\&  Title   : _write_each_record
\&  Usage   : $agave\->_write_each_record( $seqI )
\&  Function: change data into agave format
\&  Returns : NONE
\&  Args    : Bio::SeqI object
.Ve
.SS "_write_seqfeature"
.IX Subsection "_write_seqfeature"
.Vb 4
\&  Usage   : $agave\->_write_each_record( $seqfeature, $write )
\&  Function: change seeqfeature data into agave format
\&  Returns : NONE
\&  Args    : Bio::SeqFeature object and XML::writer object
.Ve
.SS "_filehandle"
.IX Subsection "_filehandle"
.Vb 6
\&  Title   : _filehandle
\&  Usage   : $obj\->_filehandle($newval)
\&  Function:
\&  Example :
\&  Returns : value of _filehandle
\&  Args    : newvalue (optional)
.Ve
.SS "throw"
.IX Subsection "throw"
.Vb 7
\&  Title    : throw
\&  Usage    : $self\->throw;
\&  Function : Throw\*(Aqs error message.  Calls SeqIO\*(Aqs throw method.
\&  Args     : Array of string(s), holding error message(s).
\&  Returns  : Nothing.
\&  Note     : Method(s) that call(s) this method: many.
\&             Method(s) that this method calls: Bio::SeqIO\*(Aqs throw method.
.Ve
