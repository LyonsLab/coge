.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::DB::SeqFeature::NormalizedFeature 3"
.TH Bio::DB::SeqFeature::NormalizedFeature 3 "2013-05-09" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::DB::SeqFeature::NormalizedFeature \-\- Normalized feature for use with Bio::DB::SeqFeature::Store
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 7
\& use Bio::DB::SeqFeature::Store;
\& # Open the sequence database
\& my $db      = Bio::DB::SeqFeature::Store\->new( \-adaptor => \*(AqDBI::mysql\*(Aq,
\&                                                \-dsn     => \*(Aqdbi:mysql:test\*(Aq);
\& my ($feature)   = $db\->get_features_by_name(\*(AqZK909\*(Aq);
\& my @subfeatures = $feature\->get_SeqFeatures();
\& my @exons_only  = $feature\->get_SeqFeatures(\*(Aqexon\*(Aq);
\&
\& # create a new object
\& $db\->seqfeature_class(\*(AqBio::DB::SeqFeature::NormalizedFeature\*(Aq);
\& my $new = $db\->new_feature(\-primary_tag=>\*(Aqgene\*(Aq,
\&                            \-seq_id     => \*(Aqchr3\*(Aq,
\&                            \-start      => 10000,
\&                            \-end        => 11000);
\&
\& # add a new exon
\& $feature\->add_SeqFeature($db\->new_feature(\-primary_tag=>\*(Aqexon\*(Aq,
\&                                           \-seq_id     => \*(Aqchr3\*(Aq,
\&                                           \-start      => 5000,
\&                                           \-end        => 5551));
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Bio::DB::SeqFeature::NormalizedFeature object is an alternative
representation of SeqFeatures for use with Bio::DB::SeqFeature::Store
database system. It is identical to Bio::DB::SeqFeature, except that
instead of storing feature/subfeature relationships in a database
table, the information is stored in the object itself. This actually
makes the objects somewhat inconvenient to work with from \s-1SQL\s0, but
does speed up access somewhat.
.PP
To use this class, pass the name of the class to the
Bio::DB::SeqFeature::Store object's \fIseqfeature_class()\fR method. After
this, \f(CW$db\fR\->\fInew_feature()\fR will create objects of type
Bio::DB::SeqFeature::NormalizedFeature. If you are using the \s-1GFF3\s0
loader, pass Bio::DB::SeqFeature::Store::GFF3Loader\->\fInew()\fR the
\&\-seqfeature_class argument:
.PP
.Vb 1
\&  use Bio::DB::SeqFeature::Store::GFF3Loader;
\&
\&  my $store  = connect_to_db_somehow();
\&  my $loader = Bio::DB::SeqFeature::Store::GFF3Loader\->new(
\&                \-store=>$db,
\&                \-seqfeature_class => \*(AqBio::DB::SeqFeature::NormalizedFeature\*(Aq
\&               );
.Ve
.SS "new"
.IX Subsection "new"
.Vb 6
\& Title   : new
\& Usage   : $feature = Bio::DB::SeqFeature::NormalizedFeature\->new(@args)
\& Function: create a new feature
\& Returns : the new seqfeature
\& Args    : see below
\& Status  : public
.Ve
.PP
This method creates and, if possible stores into a database, a new
Bio::DB::SeqFeature::NormalizedFeature object using the specialized
Bio::DB::SeqFeature class.
.PP
The arguments are the same to Bio::SeqFeature::Generic\->\fInew()\fR and
Bio::Graphics::Feature\->\fInew()\fR. The most important difference is the
\&\fB\-store\fR option, which if present creates the object in a
Bio::DB::SeqFeature::Store database, and he \fB\-index\fR option, which
controls whether the feature will be indexed for retrieval (default is
true). Ordinarily, you would only want to turn indexing on when
creating top level features, and off only when storing
subfeatures. The default is on.
.PP
Arguments are as follows:
.PP
.Vb 10
\&  \-seq_id       the reference sequence
\&  \-start        the start position of the feature
\&  \-end          the stop position of the feature
\&  \-display_name the feature name (returned by seqname)
\&  \-primary_tag  the feature type (returned by primary_tag)
\&  \-source       the source tag
\&  \-score        the feature score (for GFF compatibility)
\&  \-desc         a description of the feature
\&  \-segments     a list of subfeatures (see Bio::Graphics::Feature)
\&  \-subtype      the type to use when creating subfeatures
\&  \-strand       the strand of the feature (one of \-1, 0 or +1)
\&  \-phase        the phase of the feature (0..2)
\&  \-url          a URL to link to when rendered with Bio::Graphics
\&  \-attributes   a hashref of tag value attributes, in which the key is the tag
\&                  and the value is an array reference of values
\&  \-store        a previously\-opened Bio::DB::SeqFeature::Store object
\&  \-index        index this feature if true
.Ve
.PP
Aliases:
.PP
.Vb 6
\&  \-id           an alias for \-display_name
\&  \-seqname      an alias for \-display_name
\&  \-display_id   an alias for \-display_name
\&  \-name         an alias for \-display_name
\&  \-stop         an alias for end
\&  \-type         an alias for primary_tag
.Ve
.SS "Bio::SeqFeatureI methods"
.IX Subsection "Bio::SeqFeatureI methods"
The following Bio::SeqFeatureI methods are supported:
.PP
.Vb 5
\& seq_id(), start(), end(), strand(), get_SeqFeatures(),
\& display_name(), primary_tag(), source_tag(), seq(),
\& location(), primary_id(), overlaps(), contains(), equals(),
\& intersection(), union(), has_tag(), remove_tag(),
\& add_tag_value(), get_tag_values(), get_all_tags()
.Ve
.PP
Some methods that do not make sense in the context of a genome
annotation database system, such as \fIattach_seq()\fR, are not supported.
.PP
Please see Bio::SeqFeatureI for more details.
.SS "add_SeqFeature"
.IX Subsection "add_SeqFeature"
.Vb 6
\& Title   : add_SeqFeature
\& Usage   : $flag = $feature\->add_SeqFeature(@features)
\& Function: Add subfeatures to the feature
\& Returns : true if successful
\& Args    : list of Bio::SeqFeatureI objects
\& Status  : public
.Ve
.PP
Add one or more subfeatures to the feature. For best results,
subfeatures should be of the same class as the parent feature
(i.e. don't try mixing Bio::DB::SeqFeature::NormalizedFeature with
other feature types).
.PP
An alias for this method is \fIadd_segment()\fR.
.SS "update"
.IX Subsection "update"
.Vb 6
\& Title   : update
\& Usage   : $flag = $feature\->update()
\& Function: Update feature in the database
\& Returns : true if successful
\& Args    : none
\& Status  : public
.Ve
.PP
After changing any fields in the feature, call \fIupdate()\fR to write it to
the database. This is not needed for \fIadd_SeqFeature()\fR as \fIupdate()\fR is
invoked automatically.
.SS "get_SeqFeatures"
.IX Subsection "get_SeqFeatures"
.Vb 6
\& Title   : get_SeqFeature
\& Usage   : @subfeatures = $feature\->get_SeqFeatures([@types])
\& Function: return subfeatures of this feature
\& Returns : list of subfeatures
\& Args    : list of subfeature primary_tags (optional)
\& Status  : public
.Ve
.PP
This method extends the Bio::SeqFeatureI \fIget_SeqFeatures()\fR slightly by
allowing you to pass a list of primary_tags, in which case only
subfeatures whose primary_tag is contained on the list will be
returned. Without any types passed all subfeatures are returned.
.SS "object_store"
.IX Subsection "object_store"
.Vb 6
\& Title   : object_store
\& Usage   : $store = $feature\->object_store([$new_store])
\& Function: get or set the database handle
\& Returns : current database handle
\& Args    : new database handle (optional)
\& Status  : public
.Ve
.PP
This method will get or set the Bio::DB::SeqFeature::Store object that
is associated with the feature. After changing the store, you should
probably unset the feature's \fIprimary_id()\fR and call \fIupdate()\fR to ensure
that the object is written into the database as a new feature.
.SS "overloaded_names"
.IX Subsection "overloaded_names"
.Vb 6
\& Title   : overloaded_names
\& Usage   : $overload = $feature\->overloaded_names([$new_overload])
\& Function: get or set overloading of object strings
\& Returns : current flag
\& Args    : new flag (optional)
\& Status  : public
.Ve
.PP
For convenience, when objects of this class are stringified, they are
represented in the form \*(L"primary_tag(display_name)\*(R". To turn this
feature off, call \fIoverloaded_names()\fR with a false value. You can
invoke this on an individual feature object or on the class:
.PP
.Vb 1
\&  Bio::DB::SeqFeature::NormalizedFeature\->overloaded_names(0);
.Ve
.SS "segment"
.IX Subsection "segment"
.Vb 6
\& Title   : segment
\& Usage   : $segment = $feature\->segment
\& Function: return a Segment object corresponding to feature
\& Returns : a Bio::DB::SeqFeature::Segment
\& Args    : none
\& Status  : public
.Ve
.PP
This turns the feature into a Bio::DB::SeqFeature::Segment object,
which you can then use to query for overlapping features. See
Bio::DB::SeqFeature::Segment.
.SS "\s-1AUTOLOADED\s0 methods"
.IX Subsection "AUTOLOADED methods"
.Vb 1
\& @subfeatures = $feature\->Exon;
.Ve
.PP
If you use an unknown method that begins with a capital letter, then
the feature autogenerates a call to \fIget_SeqFeatures()\fR using the
lower-cased method name as the primary_tag. In other words
\&\f(CW$feature\fR\->Exon is equivalent to:
.PP
.Vb 1
\& @subfeature s= $feature\->get_SeqFeatures(\*(Aqexon\*(Aq)
.Ve
.PP
If you use an unknown method that begins with Tag_(tagname),
Att_(tagname) Is_(tagname), then it will be the same as calling the
\&\fIeach_tag_value()\fR method with the tagname. In a list context, these
autogenerated procedures return the list of results. In scalar
context, they return the first item in the list!!
.SS "load_id"
.IX Subsection "load_id"
.Vb 6
\& Title   : load_id
\& Usage   : $id = $feature\->load_id
\& Function: get the GFF3 load ID
\& Returns : the GFF3 load ID (string)
\& Args    : none
\& Status  : public
.Ve
.PP
For features that were originally loaded by the \s-1GFF3\s0 loader, this
method returns the \s-1GFF3\s0 load \s-1ID\s0. This method may not be supported in
future versions of the module.
.SS "notes"
.IX Subsection "notes"
.Vb 6
\& Title   : notes
\& Usage   : @notes = $feature\->notes
\& Function: get contents of the GFF3 Note tag
\& Returns : List of GFF3 Note tags
\& Args    : none
\& Status  : public
.Ve
.PP
For features that were originally loaded by the \s-1GFF3\s0 loader, this
method returns the contents of the Note tag as a list. This is a
convenience for Bio::Graphics, which looks for \fInotes()\fR when it
constructs a default description line.
.SS "primary_id"
.IX Subsection "primary_id"
.Vb 6
\& Title   : primary_id
\& Usage   : $id = $feature\->primary_id([$new_id])
\& Function: get/set the feature\*(Aqs database ID
\& Returns : the current primary ID
\& Args    : none
\& Status  : public
.Ve
.PP
This method gets or sets the primary \s-1ID\s0 of the feature in the
underlying Bio::DB::SeqFeature::Store database. If you change this
field and then call \fIupdate()\fR, it will have the effect of making a copy
of the feature in the database under a new \s-1ID\s0.
.SS "target"
.IX Subsection "target"
.Vb 6
\& Title   : target
\& Usage   : $segment = $feature\->target
\& Function: return the segment correspondent to the "Target" attribute
\& Returns : a Bio::DB::SeqFeature::Segment object
\& Args    : none
\& Status  : public
.Ve
.PP
For features that are aligned with others via the \s-1GFF3\s0 Target
attribute, this returns a segment corresponding to the aligned
region. The \s-1CIGAR\s0 gap string is not yet supported.
.SS "Internal methods"
.IX Subsection "Internal methods"
.ie n .IP "$feature\->\fIas_string()\fR" 4
.el .IP "\f(CW$feature\fR\->\fIas_string()\fR" 4
.IX Item "$feature->as_string()"
Internal method used to implement overloaded stringification.
.ie n .IP "$boolean = $feature\->type_match(@list_of_types)" 4
.el .IP "\f(CW$boolean\fR = \f(CW$feature\fR\->type_match(@list_of_types)" 4
.IX Item "$boolean = $feature->type_match(@list_of_types)"
Internal method that will return true if the feature's primary_tag and
source_tag match any of the list of types (in primary_tag:source_tag
format) provided.
.SH "BUGS"
.IX Header "BUGS"
This is an early version, so there are certainly some bugs. Please
use the BioPerl bug tracking system to report bugs.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
bioperl,
Bio::DB::SeqFeature,
Bio::DB::SeqFeature::Store,
Bio::DB::SeqFeature::Segment,
Bio::DB::SeqFeature::GFF3Loader,
Bio::DB::SeqFeature::Store::DBI::mysql,
Bio::DB::SeqFeature::Store::bdb
.SH "AUTHOR"
.IX Header "AUTHOR"
Lincoln Stein <lstein@cshl.org>.
.PP
Copyright (c) 2006 Cold Spring Harbor Laboratory.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
