.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::LiveSeq::SeqI 3"
.TH Bio::LiveSeq::SeqI 3 "2013-05-09" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::LiveSeq::SeqI \- Abstract sequence interface class for LiveSeq
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  # documentation needed
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class implements BioPerl PrimarySeqI interface for Live Seq objects.
.PP
One of the main difference in LiveSequence compared to traditional
\&\*(L"string\*(R" sequences is that coordinate systems are flexible. Typically
gene nucleotide numbering starts from 1 at the first character of the
initiator codon (A in \s-1ATG\s0). This means that negative positions are
possible and common!
.PP
Secondly, the sequence manipulation methods do not return a new
sequence object but change the current object. The current status can
be written out to BioPerl sequence objects.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and
reponsive experts will be able look at the problem and quickly
address it. Please include a thorough description of the problem
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  https://redmine.open\-bio.org/projects/bioperl/
.Ve
.SH "AUTHOR \- Joseph A.L. Insana"
.IX Header "AUTHOR - Joseph A.L. Insana"
Email:  Insana@ebi.ac.uk, jinsana@gmx.net
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object
methods. Internal methods are usually preceded with a _
.PP
Some note on the terminology/notation of method names:
 label: a unique pointer to a single nucleotide
 position: the position of a nucleotide according to a particular coordinate
           system (e.g. counting downstream from a particular label taken as
           number 1)
 base: the one letter code for a nucleotide (i.e.: \*(L"a\*(R" \*(L"t\*(R" \*(L"c\*(R" \*(L"g\*(R")
.PP
.Vb 2
\&       a base is the "value" that an "element" of a "chain" can assume
\&         (see documentation on the Chain datastructure if interested)
.Ve
.SS "seq"
.IX Subsection "seq"
.Vb 6
\& Title   : seq
\& Usage   : $string    = $obj\->seq()
\& Function: Returns the complete sequence of an object as a string of letters.
\&           Suggested cases are upper case for proteins and lower case for
\&           DNA sequence (IUPAC standard),
\& Returns : a string
.Ve
.SS "all_labels"
.IX Subsection "all_labels"
.Vb 5
\& Title   : all_labels
\& Usage   : @labels = $obj\->all_labels()
\& Function: all the labels of every nucleotide an object is composed of
\& Returns : an array of labels
\& Args    : none
.Ve
.SS "labelsubseq"
.IX Subsection "labelsubseq"
.Vb 10
\&  Title   : labelsubseq
\&  Usage   : $dna\->labelsubseq();
\&          : $dna\->labelsubseq($startlabel);
\&          : $dna\->labelsubseq($startlabel,$length);
\&          : $dna\->labelsubseq($startlabel,undef,$endlabel);
\&  e.g.    : $dna\->labelsubseq(4,undef,8);
\&  Function: prints the sequence as string. The difference between labelsubseq
\&            and normal subseq is that it uses /labels/ as arguments, instead
\&            than positions. This allows for faster and more efficient lookup,
\&            skipping the (usually) lengthy conversion of positions into labels.
\&            This is especially useful for manipulating with high power
\&            LiveSeq objects, knowing the labels and exploiting their
\&            usefulness.
\&  Returns : a string
\&  Errorcode \-1
\&  Args    : without arguments it returns the entire sequence
\&            with a startlabel it returns the sequence downstream that label
\&            if a length is specified, it returns only that number of bases
\&            if an endlabel is specified, it overrides the length argument
\&             and prints instead up to that label (included)
\&  Defaults: $startlabel defaults to the beginning of the entire sequence
\&            $endlabel defaults to the end of the entire sequence
.Ve
.SS "subseq"
.IX Subsection "subseq"
.Vb 6
\& Title   : subseq
\& Usage   : $substring = $obj\->subseq(10,40);
\&         : $substring = $obj\->subseq(10,undef,4);
\& Function: returns the subseq from start to end, where the first base
\&           is 1 and the number is inclusive, ie 1\-2 are the first two
\&           bases of the sequence
\&
\&           Start cannot be larger than end but can be equal.
\&
\&           Allows for negative numbers $obj\->subseq(\-10,\-1). By
\&           definition, there is no 0!
\&                       \-5  \-1 1   5
\&                gctagcgcccaac atggctcgctg
\&
\&           This allows one to retrieve sequences upstream from given position.
\&
\&           The precedence is from left to right: if END is given LENGTH is
\&           ignored.
\&
\& Examples: $obj\->subseq(\-10,undef,10) returns 10 elements before position 1
\&           $obj\->subseq(4,8) returns elements from the 4th to the 8th, inclusive
\&
\& Returns : a string
\& Errorcode: \-1
\& Args    : start,  integer, defaults to start of the sequence
\&           end,    integer, \*(Aq\*(Aq or undef, defaults to end of the sequence
\&           length, integer, \*(Aq\*(Aq or undef
\&           an optional strand (1 or \-1) 4th argument
\&            if strand argument is not given, it will default to the object
\&            argment. This argument is useful when a call is issued from a child
\&            of a parent object containing the subseq method
.Ve
.SS "length"
.IX Subsection "length"
.Vb 7
\&  Title   : length
\&  Usage   : $seq\->length();
\&  Function: returns the number of nucleotides (or the number of aminoacids)
\&            in the entire sequence
\&  Returns : an integer
\&  Errorcode \-1
\&  Args    : none
.Ve
.SS "display_id"
.IX Subsection "display_id"
.Vb 3
\& Title   : display_id
\& Usage   : $id_string = $obj\->display_id();
\& Function: returns the display id, alias the common name of the object
\&
\&           The semantics of this is that it is the most likely string
\&           to be used as an identifier of the sequence, and likely to
\&           have "human" readability.  The id is equivalent to the ID
\&           field of the GenBank/EMBL databanks and the id field of the
\&           Swissprot/sptrembl database. In fasta format, the >(\eS+) is
\&           presumed to be the id, though some people overload the id
\&           to embed other information.
\&
\& See also: accession_number
\& Returns : a string
\& Args    : none
.Ve
.SS "accession_number"
.IX Subsection "accession_number"
.Vb 7
\& Title   : accession_number
\& Usage   : $unique_biological_key = $obj\->accession_number;
\& Function: Returns the unique biological id for a sequence, commonly
\&           called the accession_number.
\&           Notice that primary_id() provides the unique id for the
\&           implemetation, allowing multiple objects to have the same accession
\&           number in a particular implementation.
\&
\&           For objects with no accession_number this method returns "unknown".
\& Returns : a string
\& Args    : none
.Ve
.SS "primary_id"
.IX Subsection "primary_id"
.Vb 6
\& Title   : primary_id
\& Usage   : $unique_implementation_key = $obj\->primary_id;
\& Function: Returns the unique id for this object in this
\&           implementation. This allows implementations to manage their own
\&           object ids in a way the implementation can control. Clients can
\&           expect one id to map to one object.
\&
\&           For sequences with no primary_id, this method returns
\&           a stringified memory location.
\&
\& Returns : A string
\& Args    : None
.Ve
.SS "change"
.IX Subsection "change"
.Vb 10
\& Title   : change
\& Usage   : $substring = $obj\->change(\*(AqAA\*(Aq, 10);
\& Function: changes, modifies, mutates the LiveSequence
\& Examples:
\&        $obj\->change(\*(Aq\*(Aq,   10);      delete nucleotide #10
\&        $obj\->change(\*(Aq\*(Aq,   10, 2);   delete two nucleotides starting from #10
\&        $obj\->change(\*(AqG\*(Aq,  10);      change nuc #10 to \*(AqG\*(Aq
\&        $obj\->change(\*(AqGA\*(Aq, 10, 4);   replace #10 and 3 following with \*(AqGA\*(Aq
\&        $obj\->change(\*(AqGA\*(Aq, 10, 2));  is same as $obj\->change(\*(AqGA\*(Aq,  10);
\&        $obj\->change(\*(AqGA\*(Aq, 10, 0 );  insert \*(AqGA\*(Aq before nucleotide at #10
\&        $obj\->change(\*(AqGA\*(Aq, 10, 1);   GA inserted before #10, #10 deleted
\&        $obj\->change(\*(AqGATC\*(Aq, 10, 2); GATC inserted before #10, #10&#11 deleted
\&        $obj\->change(\*(AqGATC\*(Aq, 10, 6); GATC inserted before #10, #10\-#15 deleted
\&
\&
\& Returns : a string of deleted bases (if any) or 1 (everything OK)
\& Errorcode: \-1
\& Args    : seq,    string, or \*(Aq\*(Aq (\*(Aq\*(Aq = undef = 0 = deletion)
\&           start,  integer
\&           length, integer (optional)
.Ve
.SS "positionchange"
.IX Subsection "positionchange"
.Vb 2
\& Title   : positionchange
\& Function: Exactly like change. I.e. change() defaults to positionchange()
.Ve
.SS "labelchange"
.IX Subsection "labelchange"
.Vb 10
\& Title   : labelchange
\& Function: Exactly like change but uses a /label/ instead than a position
\&           as second argument. This allows for multiple changes in a LiveSeq
\&           without the burden of recomputing positions. I.e. for a multiple
\&           change in two different points of the LiveSeq, the approach would
\&           be the following: fetch the correct labels out of the two different
\&           positions (method: label($position)) and then use the labelchange()
\&           method to modify the sequence using those labels instead than
\&           relying on the positions (that would have modified after the
\&           first change).
.Ve
.SS "valid"
.IX Subsection "valid"
.Vb 5
\&  Title   : valid
\&  Usage   : $boolean = $obj\->valid($label)
\&  Function: tests if a label exists inside the object
\&  Returns : boolean
\&  Args    : label
.Ve
.SS "start"
.IX Subsection "start"
.Vb 5
\&  Title   : start
\&  Usage   : $startlabel=$obj\->start()
\&  Function: returns the label of the first nucleotide of the object (exon, CDS)
\&  Returns : label
\&  Args    : none
.Ve
.SS "end"
.IX Subsection "end"
.Vb 5
\&  Title   : end
\&  Usage   : $endlabel=$obj\->end()
\&  Function: returns the label of the last nucleotide of the object (exon, CDS)
\&  Returns : label
\&  Args    : none
.Ve
.SS "strand"
.IX Subsection "strand"
.Vb 6
\&  Title   : strand
\&  Usage   : $strand=$obj\->strand()
\&            $obj\->strand($strand)
\&  Function: gets or sets strand information, being 1 or \-1 (forward or reverse)
\&  Returns : \-1 or 1
\&  Args    : none OR \-1 or 1
.Ve
.SS "alphabet"
.IX Subsection "alphabet"
.Vb 4
\& Title   : alphabet
\& Usage   : if( $obj\->alphabet eq \*(Aqdna\*(Aq ) { /Do Something/ }
\& Function: Returns the type of sequence being one of
\&           \*(Aqdna\*(Aq, \*(Aqrna\*(Aq or \*(Aqprotein\*(Aq. This is case sensitive.
\&
\& Returns : a string either \*(Aqdna\*(Aq,\*(Aqrna\*(Aq,\*(Aqprotein\*(Aq.
\& Args    : none
.Ve
.SS "coordinate_start"
.IX Subsection "coordinate_start"
.Vb 7
\&  Title   : coordinate_start
\&  Usage   : $coordstartlabel=$obj\->coordinate_start()
\&          : $coordstartlabel=$obj\->coordinate_start($label)
\&  Function: returns and optionally sets the first label of the coordinate
\&            system used
\&            For some objects only labels inside the object or in frame (for
\&            Translation objects) will be allowed to get set as coordinate start
\&
\&  Returns : label. It returns 0 if label not found.
\&  Errorcode \-1
\&  Args    : an optional reference $label that is position 1
.Ve
.SS "label"
.IX Subsection "label"
.Vb 5
\&  Title   : label
\&  Usage   : $seq\->label($position)
\&          : $seq\->label($position,$firstlabel)
\&  Examples: $nextlabel=$seq\->label(2,$label) \-> retrieves the following label
\&          : $prevlabel=$seq\->label(\-1,$label) \-> retrieves the preceding label
\&
\&  Function: returns the label of the nucleotide at $position from current
\&            coordinate start
\&  Returns : a label. It returns 0 if label not found.
\&  Errorcode \-1
\&  Args    : a position,
\&            an optional reference $firstlabel that is to be used as position 1
\&            an optional strand (1 or \-1) argument
\&             if strand argument is not given, it will default to the object
\&             argument. This argument is useful when a call is issued from a child
\&             of a parent object containing the subseq method
.Ve
.SS "position"
.IX Subsection "position"
.Vb 12
\&  Title   : position
\&  Usage   : $seq\->position($label)
\&          : $seq\->position($label,$firstlabel)
\&  Function: returns the position of nucleotide at $label
\&  Returns : the position of the label from current coordinate start
\&  Errorcode 0
\&  Args    : a label pointing to a certain nucleotide (e.g. start of exon)
\&            an optional "firstlabel" as reference to count from
\&            an optional strand (1 or \-1) argument
\&             if strand argument is not given, it will default to the object
\&             argument. This argument is useful when a call is issued from a child
\&             of a parent object containing the subseq method
.Ve
.SS "follows"
.IX Subsection "follows"
.Vb 10
\&  Title   : follows
\&  Usage   : $seq\->follows($firstlabel,$secondlabel)
\&          : $seq\->follows($firstlabel,$secondlabel,$strand)
\&  Function: checks if SECONDlabel follows FIRSTlabel, undependent of the strand
\&            i.e. it checks downstream for forward strand and
\&            upstream for reverse strand
\&  Returns : 1 or 0
\&  Errorcode \-1
\&  Args    : two labels
\&            an optional strand (1 or \-1) argument
\&             if strand argument is not given, it will default to the object
\&             argument. This argument is useful when a call is issued from a child
\&             of a parent object containing the subseq method
.Ve
.SS "gene"
.IX Subsection "gene"
.Vb 5
\& Title   : gene
\& Usage   : my $gene=$obj\->gene;
\& Function: Gets or sets the reference to the LiveSeq::Gene object.
\&           Objects that are features of a LiveSeq Gene will have this
\&           attribute set automatically.
\&
\& Returns : reference to an object of class Gene
\& Note    : if Gene object is not set, this method will return 0;
\& Args    : none or reference to object of class Bio::LiveSeq::Gene
.Ve
.SS "obj_valid"
.IX Subsection "obj_valid"
.Vb 6
\& Title   : obj_valid
\& Usage   : if ($obj\->obj_valid) {do something;}
\& Function: Checks if start and end labels are still valid for the ojbect,
\&           i.e. tests if the LiveSeq object is still valid
\& Returns : boolean
\& Args    : none
.Ve
.SS "name"
.IX Subsection "name"
.Vb 7
\& Title   : name
\& Usage   : $name = $obj\->name;
\&         : $name = $obj\->name("ABCD");
\& Function: Returns or sets the name of the object.
\&           If there is no name, it will return "unknown";
\& Returns : A string
\& Args    : None
.Ve
.SS "desc"
.IX Subsection "desc"
.Vb 7
\& Title   : desc
\& Usage   : $desc = $obj\->desc;
\&         : $desc = $obj\->desc("ABCD");
\& Function: Returns or sets the description of the object.
\&           If there is no description, it will return "unknown";
\& Returns : A string
\& Args    : None
.Ve
.SS "source"
.IX Subsection "source"
.Vb 7
\& Title   : source
\& Usage   : $name = $obj\->source;
\&         : $name = $obj\->source("Homo sapiens");
\& Function: Returns or sets the organism that is source of the object.
\&           If there is no source, it will return "unknown";
\& Returns : A string
\& Args    : None
.Ve
