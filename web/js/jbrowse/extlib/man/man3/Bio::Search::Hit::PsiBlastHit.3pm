.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Search::Hit::PsiBlastHit 3"
.TH Bio::Search::Hit::PsiBlastHit 3 "2013-05-09" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::Search::Hit::PsiBlastHit \- Bioperl BLAST Hit object
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
See Bio::Search::Result::BlastResult.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Bio::Search::Hit::PsiBlastHit.pm module encapsulates data and
methods for manipulating \*(L"hits\*(R" from a \s-1BLAST\s0 report. A \s-1BLAST\s0 hit is a
collection of HSPs along with other metadata such as sequence name and
score information. Hit objects are accessed via
Bio::Search::Result::BlastResult objects after parsing a \s-1BLAST\s0
report using the Bio::SearchIO system.
.PP
In Blast lingo, the \*(L"sbjct\*(R" sequences are all the sequences in a
target database which were compared against a \*(L"query\*(R" sequence.  The
terms \*(L"sbjct\*(R" and \*(L"hit\*(R" will be used interchangeably in this module.
All methods that take 'sbjct' as an argument also support 'hit' as a
synonym.
.PP
This module supports \s-1BLAST\s0 versions 1.x and 2.x, gapped and ungapped,
and PSI-BLAST.
.PP
The construction of PsiBlastHit objects is performed by
Bio::SearchIO::blast::PsiBlastHitFactory in a process that is
orchestrated by the Blast parser (Bio::SearchIO::blast).
The resulting PsiBlastHits are then accessed via
Bio::Search::Result::BlastResult). Therefore, you do not need to
use Bio::Search::Hit::PsiBlastHit) directly. If you need to
construct PsiBlastHits directly, see the \f(CW\*(C`new()\*(C'\fR function for details.
.PP
For Bio::SearchIO \s-1BLAST\s0 parsing usage examples, see the
\&\f(CW\*(C`examples/search\-blast\*(C'\fR directory of the Bioperl distribution.
.SS "\s-1HSP\s0 Tiling and Ambiguous Alignments"
.IX Subsection "HSP Tiling and Ambiguous Alignments"
If a Blast hit has more than one \s-1HSP\s0, the Bio::Search::Hit::PsiBlastHit.pm
object has the ability to merge overlapping HSPs into contiguous
blocks. This permits the PsiBlastHit object to sum data across all HSPs
without counting data in the overlapping regions multiple times, which
would happen if data from each overlapping \s-1HSP\s0 are simply summed.  \s-1HSP\s0
tiling is performed automatically when methods of the PsiBlastHit object
that rely on tiled data are invoked. These include
\&\fIfrac_identical()\fR, \fIfrac_conserved()\fR, \fIgaps()\fR,
\&\fIfrac_aligned_query()\fR, \fIfrac_aligned_hit()\fR,
\&\fInum_unaligned_query()\fR, \fInum_unaligned_hit()\fR.
.PP
It also permits the assessment of an \*(L"ambiguous alignment\*(R" if the
query (or sbjct) sequences from different HSPs overlap
(see \fIambiguous_aln()\fR). The existence
of an overlap could indicate a biologically interesting region in the
sequence, such as a repeated domain.  The PsiBlastHit object uses the
\&\f(CW\*(C`\-OVERLAP\*(C'\fR parameter to determine when two sequences overlap; if this is
set to 2 \*(-- the default \*(-- then any two sbjct or query \s-1HSP\s0 sequences
must overlap by more than two residues to get merged into the same
contig and counted as an overlap. See the \s-1BUGS\s0  section below for
\&\*(L"issues\*(R" with \s-1HSP\s0 tiling.
.PP
The results of the \s-1HSP\s0 tiling is reported with the following ambiguity codes:
.PP
.Vb 2
\&   \*(Aqq\*(Aq = Query sequence contains multiple sub\-sequences matching
\&         a single region in the sbjct sequence.
\&
\&   \*(Aqs\*(Aq = Subject (PsiBlastHit) sequence contains multiple sub\-sequences matching
\&         a single region in the query sequence.
\&
\&   \*(Aqqs\*(Aq = Both query and sbjct sequences contain more than one
\&          sub\-sequence with similarity to the other sequence.
.Ve
.PP
For addition information about ambiguous \s-1BLAST\s0 alignments, see
\&\fIBio::Search::BlastUtils::tile_hsps()\fR
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
Bio::Search::Hit::PsiBlastHit.pm is a concrete class that inherits from
Bio::Root::Root and Bio::Search::Hit::HitI.  and relies on
Bio::Search::HSP::BlastHSP.
.SH "BUGS"
.IX Header "BUGS"
One consequence of the \s-1HSP\s0 tiling is that methods that rely on \s-1HSP\s0
tiling such as \fIfrac_identical()\fR, \fIfrac_conserved()\fR, \fIgaps()\fR
etc. may report misleading numbers when \f(CW\*(C`\-OVERLAP\*(C'\fR is set to a large
number.  For example, say we have two HSPs and the query sequence tile
as follows:
.PP
.Vb 6
\&            1      8             22      30        40             60
\& Full seq:  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&                    *  ** *   **
\& HSP1:             \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-                    (6 identical matches)
\&                              **   **  **
\& HSP2:                        \-\-\-\-\-\-\-\-\-\-\-\-\-           (6 identical matches)
.Ve
.PP
If \f(CW\*(C`\-OVERLAP\*(C'\fR is set to some number over 4, \s-1HSP1\s0 and \s-1HSP2\s0 will not be
tiled into a single contig and their numbers of identical matches will
be added, giving a total of 12, not 10 if they had be combined into
one contig. This can lead to number greater than 1.0 for methods
\&\fIfrac_identical()\fR and \fIfrac_conserved()\fR. This is less of an issue
with gapped Blast since it tends to combine HSPs that would be listed
separately without gapping.  (Fractions >1.0 can be viewed as a
signal for an interesting alignment that warrants further inspection,
thus turning this bug into a feature :\-).
.PP
Using large values for \f(CW\*(C`\-OVERLAP\*(C'\fR can lead to incorrect numbers
reported by methods that rely on \s-1HSP\s0 tiling but can be useful if you
care more about detecting ambiguous alignments.  Setting \f(CW\*(C`\-OVERLAP\*(C'\fR
to zero will lead to the most accurate numbers for the
tiling-dependent methods but will be useless for detecting overlapping
HSPs since all HSPs will appear to overlap.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.Vb 4
\& Bio::Search::HSP::BlastHSP.pm         \- Blast HSP object.
\& Bio::Search::Result::BlastResult.pm   \- Blast Result object.
\& Bio::Search::Hit::HitI.pm             \- Interface implemented by PsiBlastHit.pm
\& Bio::Root::Root.pm                    \- Base class for PsiBlastHit.pm
.Ve
.PP
Links:
.PP
.Vb 1
\& http://bio.perl.org/                       \- Bioperl Project Homepage
.Ve
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules.  Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution. Bug reports can be submitted via the
web:
.PP
.Vb 1
\&    https://redmine.open\-bio.org/projects/bioperl/
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Steve Chervitz <sac@bioperl.org>
.PP
See the \s-1FEEDBACK\s0 section  for where to send bug reports and comments.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
This software was originally developed in the Department of Genetics
at Stanford University. I would also like to acknowledge my
colleagues at Affymetrix for useful feedback.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1996\-2001 Steve Chervitz. All Rights Reserved.
.SH "DISCLAIMER"
.IX Header "DISCLAIMER"
This software is provided \*(L"as is\*(R" without warranty of any kind.
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _
.SS "new"
.IX Subsection "new"
.Vb 10
\& Usage     : $hit = Bio::Search::Hit::PsiBlastHit\->new( %named_params );
\&           : Bio::Search::Hit::PsiBlastHit.pm objects are constructed
\&           : automatically by Bio::SearchIO::PsiBlastHitFactory.pm,
\&           : so there is no need for direct instantiation.
\& Purpose   : Constructs a new PsiBlastHit object and Initializes key variables
\&           : for the hit.
\& Returns   : A Bio::Search::Hit::PsiBlastHit object
\& Argument  : Named Parameters:
\&           : Parameter keys are case\-insensitive.
\&           :     \-RAW_DATA   => array reference holding raw BLAST report data
\&           :                    for a single hit. This includes all lines
\&           :                    within the HSP alignment listing section of a
\&           :                    traditional BLAST or PSI\-BLAST (non\-XML) report,
\&           :                    starting at (or just after) the leading \*(Aq>\*(Aq.
\&           :         \-HOLD_RAW_DATA => boolean, should \-RAW_DATA be saved within the object.
\&           :         \-QUERY_LEN  => Length of the query sequence
\&           :         \-ITERATION  => integer (PSI\-BLAST iteration number in which hit was found)
\&           :         \-OVERLAP    => integer (maximum overlap between adjacent
\&           :                    HSPs when tiling)
\&           :         \-PROGRAM    => string (type of Blast: BLASTP, BLASTN, etc)
\&           :         \-SIGNIF     => significance
\&           :         \-IS_PVAL    => boolean, true if \-SIGNIF contains a P\-value
\&           :         \-SCORE      => raw BLAST score
\&           :         \-FOUND_AGAIN   => boolean, true if this was a hit from the
\&           :                       section of a PSI\-BLAST with iteration > 1
\&           :                       containing sequences that were also found
\&           :                       in iteration 1.
\& Comments  : This object accepts raw Blast report data not because it
\&           : is required for parsing, but in order to retrieve it
\&           : (only available if \-HOLD_RAW_DATA is set to true).
.Ve
.PP
See Also   : \fIBio::Search::BlastUtils::tile_hsps()\fR, \fIBio::Root::Root::new()\fR
.SS "algorithm"
.IX Subsection "algorithm"
.Vb 9
\& Title   : algorithm
\& Usage   : $alg = $hit\->algorithm();
\& Function: Gets the algorithm specification that was used to obtain the hit
\&           For BLAST, the algorithm denotes what type of sequence was aligned
\&           against what (BLASTN: dna\-dna, BLASTP prt\-prt, BLASTX translated
\&           dna\-prt, TBLASTN prt\-translated dna, TBLASTX translated
\&           dna\-translated dna).
\& Returns : a scalar string
\& Args    : none
.Ve
.SS "name"
.IX Subsection "name"
.Vb 8
\& Usage     : $hit\->name([string]);
\& Purpose   : Set/Get a string to identify the hit.
\& Example   : $name = $hit\->name;
\&           : $hit\->name(\*(AqM81707\*(Aq);
\& Returns   : String consisting of the hit\*(Aqs name or undef if not set.
\& Comments  : The name is parsed out of the "Query=" line as the first chunk of
\&             non\-whitespace text. If you want the rest of the line, use
\&             $hit\->description().
.Ve
.PP
See Also: \fIaccession()\fR
.SS "description"
.IX Subsection "description"
.Vb 10
\& Usage     : $hit_object\->description( [integer] );
\& Purpose   : Set/Get a description string for the hit.
\&             This is parsed out of the "Query=" line as everything after
\&             the first chunk of non\-whitespace text. Use $hit\->name()
\&             to get the first chunk (the ID of the sequence).
\& Example   : $description = $hit\->description;
\&           : $desc_60char = $hit\->description(60);
\& Argument  : Integer (optional) indicating the desired length of the
\&           : description string to be returned.
\& Returns   : String consisting of the hit\*(Aqs description or undef if not set.
.Ve
.SS "accession"
.IX Subsection "accession"
.Vb 8
\& Title   : accession
\& Usage   : $acc = $hit\->accession();
\& Function: Retrieve the accession (if available) for the hit
\& Returns : a scalar string (empty string if not set)
\& Args    : none
\& Comments: Accession numbers are extracted based on the assumption that they
\&           are delimited by | characters (NCBI\-style). If this is not the case,
\&           use the name() method and parse it as necessary.
.Ve
.PP
See Also: \fIname()\fR
.SS "raw_score"
.IX Subsection "raw_score"
.Vb 6
\& Usage     : $hit_object\->raw_score();
\& Purpose   : Gets the BLAST score of the best HSP for the current Blast hit.
\& Example   : $score = $hit_object\->raw_score();
\& Returns   : Integer
\& Argument  : n/a
\& Throws    : n/a
.Ve
.PP
See Also   : \fIbits()\fR
.SS "length"
.IX Subsection "length"
.Vb 8
\& Usage     : $hit_object\->length();
\& Purpose   : Get the total length of the hit sequence.
\& Example   : $len = $hit_object\->length();
\& Returns   : Integer
\& Argument  : n/a
\& Throws    : n/a
\& Comments  : Developer note: when using the built\-in length function within
\&           : this module, call it as CORE::length().
.Ve
.PP
See Also   : \fIlogical_length()\fR,  \fIlength_aln()\fR
.SS "significance"
.IX Subsection "significance"
Equivalent to \fIsignif()\fR
.SS "next_hsp"
.IX Subsection "next_hsp"
.Vb 6
\& Title    : next_hsp
\& Usage    : $hsp = $obj\->next_hsp();
\& Function : returns the next available High Scoring Pair object
\& Example  :
\& Returns  : Bio::Search::HSP::BlastHSP or undef if finished
\& Args     : none
.Ve
.SS "score"
.IX Subsection "score"
Equivalent to \fIraw_score()\fR
.SS "hit_length"
.IX Subsection "hit_length"
Equivalent to \fIlength()\fR
.SS "signif"
.IX Subsection "signif"
.Vb 10
\& Usage     : $hit_object\->signif( [format] );
\& Purpose   : Get the P or Expect value for the best HSP of the given BLAST hit.
\&           : The value returned is the one which is reported in the description
\&           : section of the Blast report. For Blast1 and WU\-Blast2, this
\&           : is a P\-value, for Blast2, it is an Expect value.
\& Example   : $obj\->signif()        # returns 1.3e\-34
\&           : $obj\->signif(\*(Aqexp\*(Aq)   # returns \-34
\&           : $obj\->signif(\*(Aqparts\*(Aq) # returns (1.3, \-34)
\& Returns   : Float or scientific notation number (the raw P/Expect value, DEFAULT).
\&           : Integer if format == \*(Aqexp\*(Aq (the magnitude of the base 10 exponent).
\&           : 2\-element list (float, int) if format == \*(Aqparts\*(Aq and P/Expect value
\&           :                is in scientific notation (see Comments).
\& Argument  : format: string of \*(Aqraw\*(Aq | \*(Aqexp\*(Aq | \*(Aqparts\*(Aq
\&           :    \*(Aqraw\*(Aq returns value given in report. Default. (1.2e\-34)
\&           :    \*(Aqexp\*(Aq returns exponent value only (34)
\&           :    \*(Aqparts\*(Aq returns the decimal and exponent as a
\&           :            2\-element list (1.2, \-34)  (see Comments).
\& Throws    : n/a
\& Comments  : The signif() method provides a way to deal with the fact that
\&           : Blast1 and Blast2 formats (and WU\- vs. NCBI\-BLAST) differ in
\&           : what is reported in the description lines of each hit in the
\&           : Blast report. The signif() method frees any client code from
\&           : having to know if this is a P\-value or an Expect value,
\&           : making it easier to write code that can process both
\&           : Blast1 and Blast2 reports. This is not necessarily a good thing,
\&           : since one should always know when one is working with P\-values or
\&           : Expect values (hence the deprecated status).
\&           : Use of expect() is recommended since all hits will have an Expect value.
\&           :
\&           : Using the \*(Aqparts\*(Aq argument is not recommended since it will not
\&           : work as expected if the expect value is not in scientific notation.
\&           : That is, floats are not converted into sci notation before
\&           : splitting into parts.
.Ve
.PP
See Also   : p(), \fIexpect()\fR, \fIBio::Search::BlastUtils::get_exponent()\fR
.SS "to_string"
.IX Subsection "to_string"
.Vb 10
\& Title   : to_string
\& Usage   : print $hit\->to_string;
\& Function: Returns a string representation for the Blast Hit.
\&           Primarily intended for debugging purposes.
\& Example : see usage
\& Returns : A string of the form:
\&           [PsiBlastHit] <name> <description>
\&           e.g.:
\&           [PsiBlastHit] emb|Z46660|SC9725 S.cerevisiae chromosome XIII cosmid
\& Args    : None
.Ve
.SS "ambiguous_aln"
.IX Subsection "ambiguous_aln"
.Vb 10
\& Usage     : $ambig_code = $hit_object\->ambiguous_aln();
\& Purpose   : Sets/Gets ambiguity code data member.
\& Example   : (see usage)
\& Returns   : String = \*(Aqq\*(Aq, \*(Aqs\*(Aq, \*(Aqqs\*(Aq, \*(Aq\-\*(Aq
\&           :   \*(Aqq\*(Aq  = query sequence contains overlapping sub\-sequences
\&           :          while sbjct does not.
\&           :   \*(Aqs\*(Aq  = sbjct sequence contains overlapping sub\-sequences
\&           :          while query does not.
\&           :   \*(Aqqs\*(Aq = query and sbjct sequence contains overlapping sub\-sequences
\&           :          relative to each other.
\&           :   \*(Aq\-\*(Aq  = query and sbjct sequence do not contains multiple domains
\&           :          relative to each other OR both contain the same distribution
\&           :          of similar domains.
\& Argument  : n/a
\& Throws    : n/a
\& Status    : Experimental
.Ve
.PP
See Also   : Bio::Search::BlastUtils::tile_hsps, \*(L"\s-1HSP\s0 Tiling and Ambiguous Alignments\*(R"
.SS "overlap"
.IX Subsection "overlap"
.Vb 11
\& Usage     : $blast_object\->overlap( [integer] );
\& Purpose   : Gets/Sets the allowable amount overlap between different HSP sequences.
\& Example   : $blast_object\->overlap(5);
\&           : $overlap = $blast_object\->overlap;
\& Returns   : Integer.
\& Argument  : integer.
\& Throws    : n/a
\& Status    : Experimental
\& Comments  : Any two HSPs whose sequences overlap by less than or equal
\&           : to the overlap() number of resides will be considered separate HSPs
\&           : and will not get tiled by Bio::Search::BlastUtils::_adjust_contigs().
.Ve
.PP
See Also   : \fIBio::Search::BlastUtils::_adjust_contigs()\fR, \s-1BUGS\s0
.SS "bits"
.IX Subsection "bits"
.Vb 7
\& Usage     : $hit_object\->bits();
\& Purpose   : Gets the BLAST bit score of the best HSP for the current Blast hit.
\& Example   : $bits = $hit_object\->bits();
\& Returns   : Integer
\& Argument  : n/a
\& Throws    : Exception if bit score is not set.
\& Comments  : For BLAST1, the non\-bit score is listed in the summary line.
.Ve
.PP
See Also   : \fIscore()\fR
.SS "n"
.IX Subsection "n"
.Vb 10
\& Usage     : $hit_object\->n();
\& Purpose   : Gets the N number for the current Blast hit.
\&           : This is the number of HSPs in the set which was ascribed
\&           : the lowest P\-value (listed on the description line).
\&           : This number is not the same as the total number of HSPs.
\&           : To get the total number of HSPs, use num_hsps().
\& Example   : $n = $hit_object\->n();
\& Returns   : Integer
\& Argument  : n/a
\& Throws    : Exception if HSPs have not been set (BLAST2 reports).
\& Comments  : Note that the N parameter is not reported in gapped BLAST2.
\&           : Calling n() on such reports will result in a call to num_hsps().
\&           : The num_hsps() method will count the actual number of
\&           : HSPs in the alignment listing, which may exceed N in
\&           : some cases.
.Ve
.PP
See Also   : \fInum_hsps()\fR
.SS "frame"
.IX Subsection "frame"
.Vb 11
\& Usage     : $hit_object\->frame();
\& Purpose   : Gets the reading frame for the best HSP after HSP tiling.
\&           : This is only valid for BLASTX and TBLASTN/X reports.
\& Example   : $frame = $hit_object\->frame();
\& Returns   : Integer (\-2 .. +2)
\& Argument  : n/a
\& Throws    : Exception if HSPs have not been set (BLAST2 reports).
\& Comments  : This method requires that all HSPs be tiled. If they have not
\&           : already been tiled, they will be tiled first automatically..
\&           : If you don\*(Aqt want the tiled data, iterate through each HSP
\&           : calling frame() on each (use hsps() to get all HSPs).
.Ve
.PP
See Also   : \fIhsps()\fR
.SS "p"
.IX Subsection "p"
.Vb 10
\& Usage     : $hit_object\->p( [format] );
\& Purpose   : Get the P\-value for the best HSP of the given BLAST hit.
\&           : (Note that P\-values are not provided with NCBI Blast2 reports).
\& Example   : $p =  $sbjct\->p;
\&           : $p =  $sbjct\->p(\*(Aqexp\*(Aq);  # get exponent only.
\&           : ($num, $exp) =  $sbjct\->p(\*(Aqparts\*(Aq);  # split sci notation into parts
\& Returns   : Float or scientific notation number (the raw P\-value, DEFAULT).
\&           : Integer if format == \*(Aqexp\*(Aq (the magnitude of the base 10 exponent).
\&           : 2\-element list (float, int) if format == \*(Aqparts\*(Aq and P\-value
\&           :                is in scientific notation (See Comments).
\& Argument  : format: string of \*(Aqraw\*(Aq | \*(Aqexp\*(Aq | \*(Aqparts\*(Aq
\&           :    \*(Aqraw\*(Aq returns value given in report. Default. (1.2e\-34)
\&           :    \*(Aqexp\*(Aq returns exponent value only (34)
\&           :    \*(Aqparts\*(Aq returns the decimal and exponent as a
\&           :            2\-element list (1.2, \-34) (See Comments).
\& Throws    : Warns if no P\-value is defined. Uses expect instead.
\& Comments  : Using the \*(Aqparts\*(Aq argument is not recommended since it will not
\&           : work as expected if the P\-value is not in scientific notation.
\&           : That is, floats are not converted into sci notation before
\&           : splitting into parts.
.Ve
.PP
See Also   : \fIexpect()\fR, \fIsignif()\fR, \fIBio::Search::BlastUtils::get_exponent()\fR
.SS "expect"
.IX Subsection "expect"
.Vb 10
\& Usage     : $hit_object\->expect( [format] );
\& Purpose   : Get the Expect value for the best HSP of the given BLAST hit.
\& Example   : $e =  $sbjct\->expect;
\&           : $e =  $sbjct\->expect(\*(Aqexp\*(Aq);  # get exponent only.
\&           : ($num, $exp) = $sbjct\->expect(\*(Aqparts\*(Aq);  # split sci notation into parts
\& Returns   : Float or scientific notation number (the raw expect value, DEFAULT).
\&           : Integer if format == \*(Aqexp\*(Aq (the magnitude of the base 10 exponent).
\&           : 2\-element list (float, int) if format == \*(Aqparts\*(Aq and Expect
\&           :                is in scientific notation (see Comments).
\& Argument  : format: string of \*(Aqraw\*(Aq | \*(Aqexp\*(Aq | \*(Aqparts\*(Aq
\&           :    \*(Aqraw\*(Aq returns value given in report. Default. (1.2e\-34)
\&           :    \*(Aqexp\*(Aq returns exponent value only (34)
\&           :    \*(Aqparts\*(Aq returns the decimal and exponent as a
\&           :            2\-element list (1.2, \-34)  (see Comments).
\& Throws    : Exception if the Expect value is not defined.
\& Comments  : Using the \*(Aqparts\*(Aq argument is not recommended since it will not
\&           : work as expected if the expect value is not in scientific notation.
\&           : That is, floats are not converted into sci notation before
\&           : splitting into parts.
.Ve
.PP
See Also   : p(), \fIsignif()\fR, \fIBio::Search::BlastUtils::get_exponent()\fR
.SS "hsps"
.IX Subsection "hsps"
.Vb 10
\& Usage     : $hit_object\->hsps();
\& Purpose   : Get a list containing all HSP objects.
\&           : Get the numbers of HSPs for the current hit.
\& Example   : @hsps = $hit_object\->hsps();
\&           : $num  = $hit_object\->hsps();  # alternatively, use num_hsps()
\& Returns   : Array context : list of Bio::Search::HSP::BlastHSP.pm objects.
\&           : Scalar context: integer (number of HSPs).
\&           :                 (Equivalent to num_hsps()).
\& Argument  : n/a. Relies on wantarray
\& Throws    : Exception if the HSPs have not been collected.
.Ve
.PP
See Also   : \fIhsp()\fR, \fInum_hsps()\fR
.SS "hsp"
.IX Subsection "hsp"
.Vb 12
\& Usage     : $hit_object\->hsp( [string] );
\& Purpose   : Get a single BlastHSP.pm object for the present PsiBlastHit.pm object.
\& Example   : $hspObj  = $hit_object\->hsp;  # same as \*(Aqbest\*(Aq
\&           : $hspObj  = $hit_object\->hsp(\*(Aqbest\*(Aq);
\&           : $hspObj  = $hit_object\->hsp(\*(Aqworst\*(Aq);
\& Returns   : Object reference for a Bio::Search::HSP::BlastHSP.pm object.
\& Argument  : String (or no argument).
\&           :   No argument (default) = highest scoring HSP (same as \*(Aqbest\*(Aq).
\&           :   \*(Aqbest\*(Aq or \*(Aqfirst\*(Aq = highest scoring HSP.
\&           :   \*(Aqworst\*(Aq or \*(Aqlast\*(Aq = lowest scoring HSP.
\& Throws    : Exception if the HSPs have not been collected.
\&           : Exception if an unrecognized argument is used.
.Ve
.PP
See Also   : \fIhsps()\fR, num_hsps()
.SS "num_hsps"
.IX Subsection "num_hsps"
.Vb 6
\& Usage     : $hit_object\->num_hsps();
\& Purpose   : Get the number of HSPs for the present Blast hit.
\& Example   : $nhsps = $hit_object\->num_hsps();
\& Returns   : Integer
\& Argument  : n/a
\& Throws    : Exception if the HSPs have not been collected.
.Ve
.PP
See Also   : \fIhsps()\fR
.SS "logical_length"
.IX Subsection "logical_length"
.Vb 10
\& Usage     : $hit_object\->logical_length( [seq_type] );
\&           : (mostly intended for internal use).
\& Purpose   : Get the logical length of the hit sequence.
\&           : For query sequence of BLASTX and TBLASTX reports and the hit
\&           : sequence of TBLASTN and TBLASTX reports, the returned length
\&           : is the length of the would\-be amino acid sequence (length/3).
\&           : For all other BLAST flavors, this function is the same as length().
\& Example   : $len = $hit_object\->logical_length();
\& Returns   : Integer
\& Argument  : seq_type = \*(Aqquery\*(Aq or \*(Aqhit\*(Aq or \*(Aqsbjct\*(Aq (default = \*(Aqquery\*(Aq)
\&             (\*(Aqsbjct\*(Aq is synonymous with \*(Aqhit\*(Aq)
\& Throws    : n/a
\& Comments  : This is important for functions like frac_aligned_query()
\&           : which need to operate in amino acid coordinate space when dealing
\&           : with T?BLASTX type reports.
.Ve
.PP
See Also   : \fIlength()\fR, \fIfrac_aligned_query()\fR, \fIfrac_aligned_hit()\fR
.SS "length_aln"
.IX Subsection "length_aln"
.Vb 10
\& Usage     : $hit_object\->length_aln( [seq_type] );
\& Purpose   : Get the total length of the aligned region for query or sbjct seq.
\&           : This number will include all HSPs
\& Example   : $len    = $hit_object\->length_aln(); # default = query
\&           : $lenAln = $hit_object\->length_aln(\*(Aqquery\*(Aq);
\& Returns   : Integer
\& Argument  : seq_Type = \*(Aqquery\*(Aq or \*(Aqhit\*(Aq or \*(Aqsbjct\*(Aq (Default = \*(Aqquery\*(Aq)
\&             (\*(Aqsbjct\*(Aq is synonymous with \*(Aqhit\*(Aq)
\& Throws    : Exception if the argument is not recognized.
\& Comments  : This method will report the logical length of the alignment,
\&           : meaning that for TBLAST[NX] reports, the length is reported
\&           : using amino acid coordinate space (i.e., nucleotides / 3).
\&           :
\&           : This method requires that all HSPs be tiled. If they have not
\&           : already been tiled, they will be tiled first automatically..
\&           : If you don\*(Aqt want the tiled data, iterate through each HSP
\&           : calling length() on each (use hsps() to get all HSPs).
.Ve
.PP
See Also   : \fIlength()\fR, \fIfrac_aligned_query()\fR, \fIfrac_aligned_hit()\fR, \fIgaps()\fR, \fIBio::Search::BlastUtils::tile_hsps()\fR, \fIBio::Search::HSP::BlastHSP::length()\fR
.SS "gaps"
.IX Subsection "gaps"
.Vb 10
\& Usage     : $hit_object\->gaps( [seq_type] );
\& Purpose   : Get the number of gaps in the aligned query, sbjct, or both sequences.
\&           : Data is summed across all HSPs.
\& Example   : $qgaps = $hit_object\->gaps(\*(Aqquery\*(Aq);
\&           : $hgaps = $hit_object\->gaps(\*(Aqhit\*(Aq);
\&           : $tgaps = $hit_object\->gaps();    # default = total (query + hit)
\& Returns   : scalar context: integer
\&           : array context without args: two\-element list of integers
\&           :    (queryGaps, sbjctGaps)
\&           : Array context can be forced by providing an argument of \*(Aqlist\*(Aq or \*(Aqarray\*(Aq.
\&           :
\&           : CAUTION: Calling this method within printf or sprintf is arrray context.
\&           : So this function may not give you what you expect. For example:
\&           :          printf "Total gaps: %d", $hit\->gaps();
\&           : Actually returns a two\-element array, so what gets printed
\&           : is the number of gaps in the query, not the total
\&           :
\& Argument  : seq_type: \*(Aqquery\*(Aq | \*(Aqhit\*(Aq or \*(Aqsbjct\*(Aq | \*(Aqtotal\*(Aq | \*(Aqlist\*(Aq  (default = \*(Aqtotal\*(Aq)
\&             (\*(Aqsbjct\*(Aq is synonymous with \*(Aqhit\*(Aq)
\& Throws    : n/a
\& Comments  : If you need data for each HSP, use hsps() and then interate
\&           : through each HSP object.
\&           : This method requires that all HSPs be tiled. If they have not
\&           : already been tiled, they will be tiled first automatically..
\&           : Not relying on wantarray since that will fail in situations
\&           : such as printf "%d", $hit\->gaps() in which you might expect to
\&           : be printing the total gaps, but evaluates to array context.
.Ve
.PP
See Also   : \fIlength_aln()\fR
.SS "matches"
.IX Subsection "matches"
.Vb 10
\& Usage     : $hit_object\->matches( [class] );
\& Purpose   : Get the total number of identical or conserved matches
\&           : (or both) across all HSPs.
\&           : (Note: \*(Aqconservative\*(Aq matches are indicated as \*(Aqpositives\*(Aq
\&           :         in the Blast report.)
\& Example   : ($id,$cons) = $hit_object\->matches(); # no argument
\&           : $id = $hit_object\->matches(\*(Aqid\*(Aq);
\&           : $cons = $hit_object\->matches(\*(Aqcons\*(Aq);
\& Returns   : Integer or a 2\-element array of integers
\& Argument  : class = \*(Aqid\*(Aq | \*(Aqcons\*(Aq OR none.
\&           : If no argument is provided, both identical and conservative
\&           : numbers are returned in a two element list.
\&           : (Other terms can be used to refer to the conservative
\&           :  matches, e.g., \*(Aqpositive\*(Aq. All that is checked is whether or
\&           :  not the supplied string starts with \*(Aqid\*(Aq. If not, the
\&           : conservative matches are returned.)
\& Throws    : Exception if the requested data cannot be obtained.
\& Comments  : If you need data for each HSP, use hsps() and then interate
\&           : through the HSP objects.
\&           : Does not rely on wantarray to return a list. Only checks for
\&           : the presence of an argument (no arg = return list).
.Ve
.PP
See Also   : \fIBio::Search::HSP::BlastHSP::matches()\fR, \fIhsps()\fR
.SS "start"
.IX Subsection "start"
.Vb 10
\& Usage     : $sbjct\->start( [seq_type] );
\& Purpose   : Gets the start coordinate for the query, sbjct, or both sequences
\&           : in the PsiBlastHit object. If there is more than one HSP, the lowest start
\&           : value of all HSPs is returned.
\& Example   : $qbeg = $sbjct\->start(\*(Aqquery\*(Aq);
\&           : $sbeg = $sbjct\->start(\*(Aqhit\*(Aq);
\&           : ($qbeg, $sbeg) = $sbjct\->start();
\& Returns   : scalar context: integer
\&           : array context without args: list of two integers (queryStart, sbjctStart)
\&           : Array context can be "induced" by providing an argument of \*(Aqlist\*(Aq or \*(Aqarray\*(Aq.
\& Argument  : In scalar context: seq_type = \*(Aqquery\*(Aq or \*(Aqhit\*(Aq or \*(Aqsbjct\*(Aq (default = \*(Aqquery\*(Aq)
\&             (\*(Aqsbjct\*(Aq is synonymous with \*(Aqhit\*(Aq)
\& Throws    : n/a
\& Comments  : This method requires that all HSPs be tiled. If there is more than one
\&           : HSP and they have not already been tiled, they will be tiled first automatically..
\&           : Remember that the start and end coordinates of all HSPs are
\&           : normalized so that start < end. Strand information can be
\&           : obtained by calling $hit\->strand().
.Ve
.PP
See Also   : \fIend()\fR, \fIrange()\fR, \fIstrand()\fR, \*(L"\s-1HSP\s0 Tiling and Ambiguous Alignments\*(R", Bio::Search::HSP::BlastHSP::start
.SS "end"
.IX Subsection "end"
.Vb 10
\& Usage     : $sbjct\->end( [seq_type] );
\& Purpose   : Gets the end coordinate for the query, sbjct, or both sequences
\&           : in the PsiBlastHit object. If there is more than one HSP, the largest end
\&           : value of all HSPs is returned.
\& Example   : $qend = $sbjct\->end(\*(Aqquery\*(Aq);
\&           : $send = $sbjct\->end(\*(Aqhit\*(Aq);
\&           : ($qend, $send) = $sbjct\->end();
\& Returns   : scalar context: integer
\&           : array context without args: list of two integers (queryEnd, sbjctEnd)
\&           : Array context can be "induced" by providing an argument of \*(Aqlist\*(Aq or \*(Aqarray\*(Aq.
\& Argument  : In scalar context: seq_type = \*(Aqquery\*(Aq or \*(Aqsbjct\*(Aq
\&           :  (case insensitive). If not supplied, \*(Aqquery\*(Aq is used.
\& Throws    : n/a
\& Comments  : This method requires that all HSPs be tiled. If there is more than one
\&           : HSP and they have not already been tiled, they will be tiled first automatically..
\&           : Remember that the start and end coordinates of all HSPs are
\&           : normalized so that start < end. Strand information can be
\&           : obtained by calling $hit\->strand().
.Ve
.PP
See Also   : \fIstart()\fR, \fIrange()\fR, \fIstrand()\fR, \*(L"\s-1HSP\s0 Tiling and Ambiguous Alignments\*(R", Bio::Search::HSP::BlastHSP::end
.SS "range"
.IX Subsection "range"
.Vb 9
\& Usage     : $sbjct\->range( [seq_type] );
\& Purpose   : Gets the (start, end) coordinates for the query or sbjct sequence
\&           : in the HSP alignment.
\& Example   : ($qbeg, $qend) = $sbjct\->range(\*(Aqquery\*(Aq);
\&           : ($sbeg, $send) = $sbjct\->range(\*(Aqhit\*(Aq);
\& Returns   : Two\-element array of integers
\& Argument  : seq_type = string, \*(Aqquery\*(Aq or \*(Aqhit\*(Aq or \*(Aqsbjct\*(Aq  (default = \*(Aqquery\*(Aq)
\&             (\*(Aqsbjct\*(Aq is synonymous with \*(Aqhit\*(Aq)
\& Throws    : n/a
.Ve
.PP
See Also   : \fIstart()\fR, \fIend()\fR
.SS "frac_identical"
.IX Subsection "frac_identical"
.Vb 10
\& Usage     : $hit_object\->frac_identical( [seq_type] );
\& Purpose   : Get the overall fraction of identical positions across all HSPs.
\&           : The number refers to only the aligned regions and does not
\&           : account for unaligned regions in between the HSPs, if any.
\& Example   : $frac_iden = $hit_object\->frac_identical(\*(Aqquery\*(Aq);
\& Returns   : Float (2\-decimal precision, e.g., 0.75).
\& Argument  : seq_type: \*(Aqquery\*(Aq | \*(Aqhit\*(Aq or \*(Aqsbjct\*(Aq | \*(Aqtotal\*(Aq
\&           : default = \*(Aqquery\*(Aq (but see comments below).
\&           : (\*(Aqsbjct\*(Aq is synonymous with \*(Aqhit\*(Aq)
\& Throws    : n/a
\& Comments  : Different versions of Blast report different values for the total
\&           : length of the alignment. This is the number reported in the
\&           : denominators in the stats section:
\&           : "Identical = 34/120 Positives = 67/120".
\&           : NCBI BLAST uses the total length of the alignment (with gaps)
\&           : WU\-BLAST uses the length of the query sequence (without gaps).
\&           :
\&           : Therefore, when called with an argument of \*(Aqtotal\*(Aq,
\&           : this method will report different values depending on the
\&           : version of BLAST used. Total does NOT take into account HSP
\&           : tiling, so it should not be used.
\&           :
\&           : To get the fraction identical among only the aligned residues,
\&           : ignoring the gaps, call this method without an argument or
\&           : with an argument of \*(Aqquery\*(Aq or \*(Aqhit\*(Aq.
\&           :
\&           : If you need data for each HSP, use hsps() and then iterate
\&           : through the HSP objects.
\&           : This method requires that all HSPs be tiled. If they have not
\&           : already been tiled, they will be tiled first automatically.
.Ve
.PP
See Also   : \fIfrac_conserved()\fR, \fIfrac_aligned_query()\fR, \fImatches()\fR, \fIBio::Search::BlastUtils::tile_hsps()\fR
.SS "frac_conserved"
.IX Subsection "frac_conserved"
.Vb 10
\& Usage     : $hit_object\->frac_conserved( [seq_type] );
\& Purpose   : Get the overall fraction of conserved positions across all HSPs.
\&           : The number refers to only the aligned regions and does not
\&           : account for unaligned regions in between the HSPs, if any.
\& Example   : $frac_cons = $hit_object\->frac_conserved(\*(Aqhit\*(Aq);
\& Returns   : Float (2\-decimal precision, e.g., 0.75).
\& Argument  : seq_type: \*(Aqquery\*(Aq | \*(Aqhit\*(Aq or \*(Aqsbjct\*(Aq | \*(Aqtotal\*(Aq
\&           : default = \*(Aqquery\*(Aq (but see comments below).
\&           : (\*(Aqsbjct\*(Aq is synonymous with \*(Aqhit\*(Aq)
\& Throws    : n/a
\& Comments  : Different versions of Blast report different values for the total
\&           : length of the alignment. This is the number reported in the
\&           : denominators in the stats section:
\&           : "Positives = 34/120 Positives = 67/120".
\&           : NCBI BLAST uses the total length of the alignment (with gaps)
\&           : WU\-BLAST uses the length of the query sequence (without gaps).
\&           :
\&           : Therefore, when called with an argument of \*(Aqtotal\*(Aq,
\&           : this method will report different values depending on the
\&           : version of BLAST used. Total does NOT take into account HSP
\&           : tiling, so it should not be used.
\&           :
\&           : To get the fraction conserved among only the aligned residues,
\&           : ignoring the gaps, call this method without an argument or
\&           : with an argument of \*(Aqquery\*(Aq or \*(Aqhit\*(Aq.
\&           :
\&           : If you need data for each HSP, use hsps() and then interate
\&           : through the HSP objects.
\&           : This method requires that all HSPs be tiled. If they have not
\&           : already been tiled, they will be tiled first automatically.
.Ve
.PP
See Also   : \fIfrac_identical()\fR, \fImatches()\fR, \fIBio::Search::BlastUtils::tile_hsps()\fR
.SS "frac_aligned_query"
.IX Subsection "frac_aligned_query"
.Vb 10
\& Usage     : $hit_object\->frac_aligned_query();
\& Purpose   : Get the fraction of the query sequence which has been aligned
\&           : across all HSPs (not including intervals between non\-overlapping
\&           : HSPs).
\& Example   : $frac_alnq = $hit_object\->frac_aligned_query();
\& Returns   : Float (2\-decimal precision, e.g., 0.75).
\& Argument  : n/a
\& Throws    : n/a
\& Comments  : If you need data for each HSP, use hsps() and then interate
\&           : through the HSP objects.
\&           : To compute the fraction aligned, the logical length of the query
\&           : sequence is used, meaning that for [T]BLASTX reports, the
\&           : full length of the query sequence is converted into amino acids
\&           : by dividing by 3. This is necessary because of the way
\&           : the lengths of aligned sequences are computed.
\&           : This method requires that all HSPs be tiled. If they have not
\&           : already been tiled, they will be tiled first automatically.
.Ve
.PP
See Also   : \fIfrac_aligned_hit()\fR, \fIlogical_length()\fR, \fIlength_aln()\fR,  \fIBio::Search::BlastUtils::tile_hsps()\fR
.SS "frac_aligned_hit"
.IX Subsection "frac_aligned_hit"
.Vb 10
\& Usage     : $hit_object\->frac_aligned_hit();
\& Purpose   : Get the fraction of the hit (sbjct) sequence which has been aligned
\&           : across all HSPs (not including intervals between non\-overlapping
\&           : HSPs).
\& Example   : $frac_alnq = $hit_object\->frac_aligned_hit();
\& Returns   : Float (2\-decimal precision, e.g., 0.75).
\& Argument  : n/a
\& Throws    : n/a
\& Comments  : If you need data for each HSP, use hsps() and then interate
\&           : through the HSP objects.
\&           : To compute the fraction aligned, the logical length of the sbjct
\&           : sequence is used, meaning that for TBLAST[NX] reports, the
\&           : full length of the sbjct sequence is converted into amino acids
\&           : by dividing by 3. This is necessary because of the way
\&           : the lengths of aligned sequences are computed.
\&           : This method requires that all HSPs be tiled. If they have not
\&           : already been tiled, they will be tiled first automatically.
.Ve
.PP
See Also   : \fIfrac_aligned_query()\fR, \fImatches()\fR, , \fIlogical_length()\fR, \fIlength_aln()\fR,  \fIBio::Search::BlastUtils::tile_hsps()\fR
.SS "frac_aligned_sbjct"
.IX Subsection "frac_aligned_sbjct"
Same as \fIfrac_aligned_hit()\fR
.SS "num_unaligned_sbjct"
.IX Subsection "num_unaligned_sbjct"
Same as \fInum_unaligned_hit()\fR
.SS "num_unaligned_hit"
.IX Subsection "num_unaligned_hit"
.Vb 10
\& Usage     : $hit_object\->num_unaligned_hit();
\& Purpose   : Get the number of the unaligned residues in the hit sequence.
\&           : Sums across all all HSPs.
\& Example   : $num_unaln = $hit_object\->num_unaligned_hit();
\& Returns   : Integer
\& Argument  : n/a
\& Throws    : n/a
\& Comments  : See notes regarding logical lengths in the comments for frac_aligned_hit().
\&           : They apply here as well.
\&           : If you need data for each HSP, use hsps() and then interate
\&           : through the HSP objects.
\&           : This method requires that all HSPs be tiled. If they have not
\&           : already been tiled, they will be tiled first automatically..
.Ve
.PP
See Also   : \fInum_unaligned_query()\fR,  \fIBio::Search::BlastUtils::tile_hsps()\fR, \fIfrac_aligned_hit()\fR
.SS "num_unaligned_query"
.IX Subsection "num_unaligned_query"
.Vb 10
\& Usage     : $hit_object\->num_unaligned_query();
\& Purpose   : Get the number of the unaligned residues in the query sequence.
\&           : Sums across all all HSPs.
\& Example   : $num_unaln = $hit_object\->num_unaligned_query();
\& Returns   : Integer
\& Argument  : n/a
\& Throws    : n/a
\& Comments  : See notes regarding logical lengths in the comments for frac_aligned_query().
\&           : They apply here as well.
\&           : If you need data for each HSP, use hsps() and then interate
\&           : through the HSP objects.
\&           : This method requires that all HSPs be tiled. If they have not
\&           : already been tiled, they will be tiled first automatically..
.Ve
.PP
See Also   : \fInum_unaligned_hit()\fR, \fIfrac_aligned_query()\fR,  \fIBio::Search::BlastUtils::tile_hsps()\fR
.SS "seq_inds"
.IX Subsection "seq_inds"
.Vb 10
\& Usage     : $hit\->seq_inds( seq_type, class, collapse );
\& Purpose   : Get a list of residue positions (indices) across all HSPs
\&           : for identical or conserved residues in the query or sbjct sequence.
\& Example   : @s_ind = $hit\->seq_inds(\*(Aqquery\*(Aq, \*(Aqidentical\*(Aq);
\&           : @h_ind = $hit\->seq_inds(\*(Aqhit\*(Aq, \*(Aqconserved\*(Aq);
\&           : @h_ind = $hit\->seq_inds(\*(Aqhit\*(Aq, \*(Aqconserved\*(Aq, 1);
\& Returns   : Array of integers
\&           : May include ranges if collapse is non\-zero.
\& Argument  : [0] seq_type  = \*(Aqquery\*(Aq or \*(Aqhit\*(Aq or \*(Aqsbjct\*(Aq  (default = \*(Aqquery\*(Aq)
\&           :                 (\*(Aqsbjct\*(Aq is synonymous with \*(Aqhit\*(Aq)
\&           : [1] class     = \*(Aqidentical\*(Aq or \*(Aqconserved\*(Aq (default = \*(Aqidentical\*(Aq)
\&           :              (can be shortened to \*(Aqid\*(Aq or \*(Aqcons\*(Aq)
\&           :              (actually, anything not \*(Aqid\*(Aq will evaluate to \*(Aqconserved\*(Aq).
\&           : [2] collapse  = boolean, if non\-zero, consecutive positions are merged
\&           :             using a range notation, e.g., "1 2 3 4 5 7 9 10 11"
\&           :             collapses to "1\-5 7 9\-11". This is useful for
\&           :             consolidating long lists. Default = no collapse.
\& Throws    : n/a.
\& Comments  : Note that HSPs are not tiled for this. This could be a problem
\&           : for hits containing mutually exclusive HSPs.
\&           : TODO: Consider tiling and then reporting seq_inds for the
\&           : best HSP contig.
.Ve
.PP
See Also   : \fIBio::Search::HSP::BlastHSP::seq_inds()\fR
.SS "iteration"
.IX Subsection "iteration"
.Vb 8
\& Usage     : $sbjct\->iteration( );
\& Purpose   : Gets the iteration number in which the Hit was found.
\& Example   : $iteration_num = $sbjct\->iteration();
\& Returns   : Integer greater than or equal to 1
\&             Non\-PSI\-BLAST reports will report iteration as 1, but this number
\&             is only meaningful for PSI\-BLAST reports.
\& Argument  : none
\& Throws    : none
.Ve
.PP
See Also   : \fIfound_again()\fR
.SS "found_again"
.IX Subsection "found_again"
.Vb 4
\& Usage     : $sbjct\->found_again;
\& Purpose   : Gets a boolean indicator whether or not the hit has
\&             been found in a previous iteration.
\&             This is only applicable to PSI\-BLAST reports.
\&
\&              This method indicates if the hit was reported in the
\&              "Sequences used in model and found again" section of the
\&              PSI\-BLAST report or if it was reported in the
\&              "Sequences not found previously or not previously below threshold"
\&              section of the PSI\-BLAST report. Only for hits in iteration > 1.
\&
\& Example   : if( $sbjct\->found_again()) { ... };
\& Returns   : Boolean (1 or 0) for PSI\-BLAST report iterations greater than 1.
\&             Returns undef for PSI\-BLAST report iteration 1 and non PSI_BLAST
\&             reports.
\& Argument  : none
\& Throws    : none
.Ve
.PP
See Also   : \fIfound_again()\fR
.SS "strand"
.IX Subsection "strand"
.Vb 10
\& Usage     : $sbjct\->strand( [seq_type] );
\& Purpose   : Gets the strand(s) for the query, sbjct, or both sequences
\&           : in the best HSP of the PsiBlastHit object after HSP tiling.
\&           : Only valid for BLASTN, TBLASTX, BLASTX\-query, TBLASTN\-hit.
\& Example   : $qstrand = $sbjct\->strand(\*(Aqquery\*(Aq);
\&           : $sstrand = $sbjct\->strand(\*(Aqhit\*(Aq);
\&           : ($qstrand, $sstrand) = $sbjct\->strand();
\& Returns   : scalar context: integer \*(Aq1\*(Aq, \*(Aq\-1\*(Aq, or \*(Aq0\*(Aq
\&           : array context without args: list of two strings (queryStrand, sbjctStrand)
\&           : Array context can be "induced" by providing an argument of \*(Aqlist\*(Aq or \*(Aqarray\*(Aq.
\& Argument  : In scalar context: seq_type = \*(Aqquery\*(Aq or \*(Aqhit\*(Aq or \*(Aqsbjct\*(Aq (default = \*(Aqquery\*(Aq)
\&             (\*(Aqsbjct\*(Aq is synonymous with \*(Aqhit\*(Aq)
\& Throws    : n/a
\& Comments  : This method requires that all HSPs be tiled. If they have not
\&           : already been tiled, they will be tiled first automatically..
\&           : If you don\*(Aqt want the tiled data, iterate through each HSP
\&           : calling strand() on each (use hsps() to get all HSPs).
\&           :
\&           : Formerly (prior to 10/21/02), this method would return the
\&           : string "\-1/1" for hits with HSPs on both strands.
\&           : However, now that strand and frame is properly being accounted
\&           : for during HSP tiling, it makes more sense for strand()
\&           : to return the strand data for the best HSP after tiling.
\&           :
\&           : If you really want to know about hits on opposite strands,
\&           : you should be iterating through the HSPs using methods on the
\&           : HSP objects.
\&           :
\&           : A possible use case where knowing whether a hit has HSPs
\&           : on both strands would be when filtering via SearchIO for hits with
\&           : this property. However, in this case it would be better to have a
\&           : dedicated method such as $hit\->hsps_on_both_strands(). Similarly
\&           : for frame. This could be provided if there is interest.
.Ve
.PP
See Also   : Bio::Search::HSP::BlastHSP::strand()
.SH "FOR DEVELOPERS ONLY"
.IX Header "FOR DEVELOPERS ONLY"
.SS "Data Members"
.IX Subsection "Data Members"
Information about the various data members of this module is provided for those
wishing to modify or understand the code. Two things to bear in mind:
.IP "1 Do \s-1NOT\s0 rely on these in any code outside of this module." 4
.IX Item "1 Do NOT rely on these in any code outside of this module."
All data members are prefixed with an underscore to signify that they are private.
Always use accessor methods. If the accessor doesn't exist or is inadequate,
create or modify an accessor (and let me know, too!). (An exception to this might
be for BlastHSP.pm which is more tightly coupled to PsiBlastHit.pm and
may access PsiBlastHit data members directly for efficiency purposes, but probably
should not).
.IP "2 This documentation may be incomplete and out of date." 4
.IX Item "2 This documentation may be incomplete and out of date."
It is easy for these data member descriptions to become obsolete as
this module is still evolving. Always double check this info and search
for members not described here.
.PP
An instance of Bio::Search::Hit::PsiBlastHit.pm is a blessed reference to a hash containing
all or some of the following fields:
.PP
.Vb 10
\& FIELD           VALUE
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& _hsps          : Array ref for a list of Bio::Search::HSP::BlastHSP.pm objects.
\&                :
\& _db            : Database identifier from the summary line.
\&                :
\& _desc          : Description data for the hit from the summary line.
\&                :
\& _length        : Total length of the hit sequence.
\&                :
\& _score         : BLAST score.
\&                :
\& _bits          : BLAST score (in bits). Matrix\-independent.
\&                :
\& _p             : BLAST P value. Obtained from summary section. (Blast1/WU\-Blast only)
\&                :
\& _expect        : BLAST Expect value. Obtained from summary section.
\&                :
\& _n             : BLAST N value (number of HSPs) (Blast1/WU\-Blast2 only)
\&                :
\& _frame         : Reading frame for TBLASTN and TBLASTX analyses.
\&                :
\& _totalIdentical: Total number of identical aligned monomers.
\&                :
\& _totalConserved: Total number of conserved aligned monomers (a.k.a. "positives").
\&                :
\& _overlap       : Maximum number of overlapping residues between adjacent HSPs
\&                : before considering the alignment to be ambiguous.
\&                :
\& _ambiguous_aln : Boolean. True if the alignment of all HSPs is ambiguous.
\&                :
\& _length_aln_query : Length of the aligned region of the query sequence.
\&                   :
\& _length_aln_sbjct : Length of the aligned region of the sbjct sequence.
.Ve
